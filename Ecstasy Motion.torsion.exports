<exports>
<class>
<name>ActionMap</name>
<base>SimObject</base>
<method>
<name>bind</name>
<desc>actionMap.bind( device, action, [modifier spec, mod...], command )@hide</desc>
</method>
<method>
<name>bindCmd</name>
<args>( string device, string action, string makeCmd, string breakCmd="" )</args>
<desc>Bind a make and optional break command to a specified input device action.
@param device The device to bind to.  Can be keyboard, mouse, joystick or gamepad.
@param action The device action to bind to.  The action is dependant upon the device but for keyboard you specify a key.
@param makeCmd The command to execute when the device/action is made.
@param breakCmd The command to execute when the device/action is unmade [optional].
@return Whether the bind was successful.
@tsexample
// Print to the console when the spacebar is pressed
function onSpaceDown()
{
echo("Space bar down!");
}

// Print to the console when the spacebar is released
function onSpaceUp()
{
echo("Space bar up!");
}

// Bind the commands onSpaceDown and onSpaceUp to spacebar events

moveMap.bindCmd(keyboard, "space", "onSpaceDown();", "onSpaceUp();");
@endtsexample</desc>
</method>
<method>
<name>bindObj</name>
<args>(device, action, [modifier spec, mod...], command, object)</args>
<desc>@hide</desc>
</method>
<method>
<name>getBinding</name>
<args>( string command )</args>
<desc>Get ActionMap binding for the specified command.
@param command The specified command to search for.
@return The binding against the specified command.
@tsexample
// Find what the function "jump()" is bound to in moveMap
%bind = moveMap.getBinding( "jump" );

if ( %bind !$= "" )
{
// Find out what device is used in the binding
^%device = getField( %bind, 0 );

// Find out what action (such as a key) is used in the binding
^%action = getField( %bind, 1 );
}
@endtsexample</desc>
</method>
<method>
<name>getCommand</name>
<args>( string device, string action )</args>
<desc>Get ActionMap command for the device and action.
@param device The device that was bound.  Can be keyboard, mouse, joystick or gamepad.
@param action The device action that was bound.  The action is dependant upon the device but for keyboard you specify a key.
@return The command against the specified device and action.
@tsexample
// Find what function is bound to a device's action
// In this example, "jump()" was assigned to the space key in another script
%command = moveMap.getCommand("keyboard", "space");

// Should print "jump" in the console
echo(%command)
@endtsexample</desc>
</method>
<method>
<name>getDeadZone</name>
<args>( string device, string action )</args>
<desc>Get DeadZone for the specified device and action.
@param device The device that was bound.  Can be keyboard, mouse, joystick or gamepad.
@param action The device action that was bound.  The action is dependant upon the device but for keyboard you specify a key.
@return DeadZone for the specified device and action.
@tsexample
%deadZone = moveMap.getDeadZone( "gamepad", "thumbrx");
@endtsexample</desc>
</method>
<method>
<name>getScale</name>
<args>( string device, string action )</args>
<desc>Get any scaling on the specified device and action.
@param device The device that was bound.  Can be keyboard, mouse, joystick or gamepad.
@param action The device action that was bound.  The action is dependant upon the device but for keyboard you specify a key.
@return Any scaling applied to the specified device and action.
@tsexample
%scale = %moveMap.getScale( "gamepad", "thumbrx");
@endtsexample</desc>
</method>
<method>
<name>isInverted</name>
<args>( string device, string action )</args>
<desc>Is the specified device and action binding inverted?
@param device The device that was bound.  Can be keyboard, mouse, joystick or gamepad.
@param action The device action that was bound.  The action is dependant upon the device but for keyboard you specify a key.
@return If the specified device and action is inverted.
@tsexample
%flags = moveMap.isInverted( "mouse", "xaxis") ? "SDI" : "SD";
@endtsexample</desc>
</method>
<method>
<name>pop</name>
<args>()</args>
<desc>Pop the ActionMap off the ActionMap stack.
@tsexample
// Deactivate moveMap
moveMap.pop();
@endtsexample</desc>
</method>
<method>
<name>push</name>
<args>()</args>
<desc>Push the ActionMap onto the ActionMap stack.
@tsexample
// Make moveMap the active action map
moveMap.push();
@endtsexample</desc>
</method>
<method>
<name>save</name>
<args>( string fileName=NULL, bool append=false )</args>
<desc>Save actionmap to the specified file.
@param fileName The specified filename [optional].  If a filename is not specified then the ActionMap is dumped to the console.
@param append Whether to write the ActionMap at the end of the specified file or not [optional].  Default is false.
@tsexample
// write out the control config into the rw/config.cs file
moveMap.save( "scripts/client/config.cs" );@endtsexample</desc>
</method>
<method>
<name>unbind</name>
<args>( string device, string action )</args>
<desc>Remove any binding on specified input device action.
@param device The device to unbind from.  Can be keyboard, mouse, joystick or gamepad.
@param action The device action to unbind from.  The action is dependant upon the device but for keyboard you specify a key.
@return Whether the unbind was successful.

@tsexample
moveMap.unbind("keyboard", "space");
@endtsexample</desc>
</method>
<method>
<name>unbindObj</name>
<args>( string device, string action, string obj )</args>
<desc>Remove any object-binding on specified input device action.
@param device The device to bind to.  Can be keyboard, mouse, joystick or gamepad.
@param action The device action to unbind from.  The action is dependant upon the device but for keyboard you specify a key.
@param object The object to perform unbind against.
@return Whether the unbind was successful.
@tsexample
moveMap.unbindObj("keyboard", "numpad1", "rangeChange", %player);@endtsexample</desc>
</method>
</class>
<class>
<name>ActionMapClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ActionMapGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>ActiveActionMapSet</name>
<base>SimSet</base>
</class>
<class>
<name>AdvancedLightBinManager</name>
<base>RenderTexTargetBinManager</base>
</class>
<class>
<name>AdvancedLightBinManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>AIClient</name>
<base>AIConnection</base>
<method>
<name>getAimLocation</name>
<desc>ai.getAimLocation();</desc>
</method>
<method>
<name>getLocation</name>
<desc>ai.getLocation();</desc>
</method>
<method>
<name>getMoveDestination</name>
<desc>ai.getMoveDestination();</desc>
</method>
<method>
<name>getTargetObject</name>
<desc>ai.getTargetObject();</desc>
</method>
<method>
<name>missionCycleCleanup</name>
<desc>ai.missionCycleCleanup();</desc>
</method>
<method>
<name>move</name>
<desc>ai.move();</desc>
</method>
<method>
<name>moveForward</name>
<desc>ai.moveForward();</desc>
</method>
<method>
<name>setAimLocation</name>
<desc>ai.setAimLocation( x y z );</desc>
</method>
<method>
<name>setMoveDestination</name>
<desc>ai.setMoveDestination( x y z );</desc>
</method>
<method>
<name>setMoveSpeed</name>
<desc>ai.setMoveSpeed( float );</desc>
</method>
<method>
<name>setTargetObject</name>
<desc>ai.setTargetObject( obj );</desc>
</method>
<method>
<name>stop</name>
<desc>ai.stop();</desc>
</method>
</class>
<class>
<name>AIClientClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>AIConnection</name>
<base>GameConnection</base>
<method>
<name>getAddress</name>
</method>
<method>
<name>getFreeLook</name>
<desc>getFreeLook()Is freelook on for the current move?</desc>
</method>
<method>
<name>getMove</name>
<args>(string field)</args>
<desc>Get the given field of a move.

@param field One of {'x','y','z','yaw','pitch','roll'}
@returns The requested field on the current move.</desc>
</method>
<method>
<name>getTrigger</name>
<args>(int trigger)</args>
<desc>Is the given trigger set?</desc>
</method>
<method>
<name>setFreeLook</name>
<args>(bool isFreeLook)</args>
<desc>Enable/disable freelook on the current move.</desc>
</method>
<method>
<name>setMove</name>
<args>(string field, float value)</args>
<desc>Set a field on the current move.

@param   field One of {'x','y','z','yaw','pitch','roll'}
@param   value Value to set field to.</desc>
</method>
<method>
<name>setTrigger</name>
<args>(int trigger, bool set)</args>
<desc>Set a trigger.</desc>
</method>
</class>
<class>
<name>AIConnectionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>AIPlayer</name>
<base>Player</base>
<method>
<name>clearAim</name>
<args>()</args>
<desc>Use this to stop aiming at an object or a point.</desc>
</method>
<method>
<name>getAimLocation</name>
<args>()</args>
<desc>@brief Returns the point the AI aiming at.

This will reflect the position set by setAimLocation(), or the position of the object that the bot is now aiming at, or if the bot is not aiming at anything, this value will change to whatever point the bot's current line-of-sight intercepts.@return World space coordinates of the object AI is aiming at. Formatted as "X Y Z".</desc>
</method>
<method>
<name>getAimObject</name>
<args>()</args>
<desc>@brief Gets the object the AI is targeting.

@return Returns -1 if no object is being aimed at, or a non-zero positive integer ID of the object the bot is aiming at.</desc>
</method>
<method>
<name>getMoveDestination</name>
<args>()</args>
<desc>@brief Push a line onto the back of the list.

@return Returns a vector containing the &lt;x y z&gt; position of the bot's current move destination. If no move destination has yet been set, this returns "0 0 0".</desc>
</method>
<method>
<name>setAimLocation</name>
<args>( Point3F target )</args>
<desc>@brief Tells the AI to aim at the location provided.

@param target An XYZ vector representing a position in the game world.</desc>
</method>
<method>
<name>setAimObject</name>
<args>( GameBase obj, [Point3F offset] )</args>
<desc>Sets the bot's target object. Optionally set an offset from target location.@hide</desc>
</method>
<method>
<name>setMoveDestination</name>
<args>(Point3F goal, bool slowDown=true)</args>
<desc>Tells the AI to move to the location provided.@hide</desc>
</method>
<method>
<name>setMoveSpeed</name>
<args>( float speed )</args>
<desc>@brief Sets the move speed for an AI object.

@param speed A speed multiplier between 0.0 and 1.0. This is multiplied by the bot's base movement rates (from its datablock</desc>
</method>
<method>
<name>stop</name>
<args>()</args>
<desc>Tells the AIPlayer to stop moving.</desc>
</method>
</class>
<class>
<name>AIPlayerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ArrayObject</name>
<base>SimObject</base>
<method>
<name>add</name>
<args>( string key, string value="" )</args>
<desc>Adds a new element to the end of an array</desc>
</method>
<method>
<name>append</name>
<args>( ArrayObject target )</args>
<desc>Appends the target array to the array object</desc>
</method>
<method>
<name>count</name>
<args>()</args>
<desc>Get the number of elements in the array</desc>
</method>
<method>
<name>countKey</name>
<args>( string key )</args>
<desc>Get the number of times a particular key is found in the array</desc>
</method>
<method>
<name>countValue</name>
<args>( string value )</args>
<desc>Get the number of times a particular value is found in the array</desc>
</method>
<method>
<name>crop</name>
<args>( ArrayObject target )</args>
<desc>Removes elements with matching keys from array</desc>
</method>
<method>
<name>duplicate</name>
<args>( ArrayObject target )</args>
<desc>Alters array into an exact duplicate of the target array</desc>
</method>
<method>
<name>echo</name>
<args>()</args>
<desc>Echos the array in the console</desc>
</method>
<method>
<name>empty</name>
<args>()</args>
<desc>Emptys all elements from an array</desc>
</method>
<method>
<name>erase</name>
<args>( int index )</args>
<desc>Removes an element at a specific position from the array</desc>
</method>
<method>
<name>getCurrent</name>
<args>()</args>
<desc>Gets the current pointer index</desc>
</method>
<method>
<name>getIndexFromKey</name>
<args>( string key )</args>
<desc>Search the array from the current position for the key @param value Array key to search for
@return Index of the first element found, or -1 if none</desc>
</method>
<method>
<name>getIndexFromValue</name>
<args>( string value )</args>
<desc>Search the array from the current position for the element @param value Array value to search for
@return Index of the first element found, or -1 if none</desc>
</method>
<method>
<name>getKey</name>
<args>( int index )</args>
<desc>Get the key of the array element at the submitted index</desc>
</method>
<method>
<name>getValue</name>
<args>( int index )</args>
<desc>Get the value of the array element at the submitted index</desc>
</method>
<method>
<name>insert</name>
<args>( string key, string value, int index )</args>
<desc>Adds a new element to a specified position in the array</desc>
</method>
<method>
<name>moveFirst</name>
<args>()</args>
<desc>Moves array pointer to start of array

@return Returns the new array pointer</desc>
</method>
<method>
<name>moveLast</name>
<args>()</args>
<desc>Moves array pointer to end of array

@return Returns the new array pointer</desc>
</method>
<method>
<name>moveNext</name>
<args>()</args>
<desc>Moves array pointer to next position

@return Returns the new array pointer, or -1 if already at the end</desc>
</method>
<method>
<name>movePrev</name>
<args>()</args>
<desc>Moves array pointer to prev position

@return Returns the new array pointer, or -1 if already at the start</desc>
</method>
<method>
<name>pop_back</name>
<args>()</args>
<desc>Removes the last element from the array</desc>
</method>
<method>
<name>pop_front</name>
<args>()</args>
<desc>Removes the first element from the array</desc>
</method>
<method>
<name>push_back</name>
<args>( string key, string value="" )</args>
<desc>Adds a new element to the end of an array</desc>
</method>
<method>
<name>push_front</name>
<args>( string key, string value="" )</args>
<desc>Adds a new element to the front of an array</desc>
</method>
<method>
<name>setCurrent</name>
<args>( int index )</args>
<desc>Sets the current pointer index</desc>
</method>
<method>
<name>setKey</name>
<args>( string key, int index )</args>
<desc>Set the key at the given index</desc>
</method>
<method>
<name>setValue</name>
<args>( string value, int index )</args>
<desc>Set the value at the given index</desc>
</method>
<method>
<name>sort</name>
<args>( bool descending=false )</args>
<desc>Alpha sorts the array by value

@param descending [optional] True for descending sort, false for ascending sort</desc>
</method>
<method>
<name>sorta</name>
<args>()</args>
<desc>Alpha sorts the array by value in ascending order</desc>
</method>
<method>
<name>sortd</name>
<args>()</args>
<desc>Alpha sorts the array by value in descending order</desc>
</method>
<method>
<name>sortf</name>
<args>( string functionName )</args>
<desc>Sorts the array by value in ascending order using the given callback function</desc>
</method>
<method>
<name>sortfd</name>
<args>( string functionName )</args>
<desc>Sorts the array by value in descending order using the given callback function</desc>
</method>
<method>
<name>sortfk</name>
<args>( string functionName )</args>
<desc>Sorts the array by key in ascending order using the given callback function</desc>
</method>
<method>
<name>sortfkd</name>
<args>( string functionName )</args>
<desc>Sorts the array by key in descending order using the given callback function</desc>
</method>
<method>
<name>sortk</name>
<args>( bool descending=false )</args>
<desc>Alpha sorts the array by key

@param descending [optional] True for descending sort, false for ascending sort</desc>
</method>
<method>
<name>sortka</name>
<args>()</args>
<desc>Alpha sorts the array by key in ascending order</desc>
</method>
<method>
<name>sortkd</name>
<args>()</args>
<desc>Alpha sorts the array by key in descending order</desc>
</method>
<method>
<name>sortn</name>
<args>( bool descending=false )</args>
<desc>Numerically sorts the array by value

@param descending [optional] True for descending sort, false for ascending sort</desc>
</method>
<method>
<name>sortna</name>
<args>()</args>
<desc>Numerically sorts the array by value in ascending order</desc>
</method>
<method>
<name>sortnd</name>
<args>()</args>
<desc>Numerically sorts the array by value in descending order</desc>
</method>
<method>
<name>sortnk</name>
<args>( bool descending=false )</args>
<desc>Numerically sorts the array by key

@param descending [optional] True for descending sort, false for ascending sort</desc>
</method>
<method>
<name>sortnka</name>
<args>()</args>
<desc>Numerical sorts the array by key in ascending order</desc>
</method>
<method>
<name>sortnkd</name>
<args>()</args>
<desc>Numerical sorts the array by key in descending order</desc>
</method>
<method>
<name>uniqueKey</name>
<args>()</args>
<desc>Removes any elements that have duplicated keys (leaving the first instance)</desc>
</method>
<method>
<name>uniqueValue</name>
<args>()</args>
<desc>Removes any elements that have duplicated values (leaving the first instance)</desc>
</method>
<field>
<name>caseSensitive</name>
<desc>Makes the keys and values case-sensitive.
By default, comparison of key and value strings will be case-insensitive.</desc>
</field>
<field>
<name>key</name>
<desc>Helper field which allows you to add new key['keyname'] = value pairs.</desc>
</field>
</class>
<class>
<name>ArrayObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>BanList</name>
<method>
<name>add</name>
<args>( int uniqueId, string transportAddress, int banLength )</args>
<desc>Ban a user for banLength seconds.

@param uniqueId Unique ID of the player.
@param transportAddress Address from which the player connected.
@param banLength Time period over which to ban the player.@tsexample
// Kick someone off the server
// %client - This is the connection to the person we are kicking
function kick(%client)
{
^^// Let the server know what happened
^^messageAll( 'MsgAdminForce', '\c2The Admin has kicked %1.', %client.playerName);

^^// If it is not an AI Player, execute the ban.
^^if (!%client.isAIControlled())
^^^BanList::add(%client.guid, %client.getAddress(), $pref::Server::KickBanTime);

^^// Let the player know they messed up
^^%client.delete("You have been kicked from this server");
}
@endtsexample</desc>
</method>
<method>
<name>addAbsolute</name>
<args>( int uniqueId, string transportAddress, int banTime )</args>
<desc>Ban a user until a given time.

@param uniqueId Unique ID of the player.
@param transportAddress Address from which the player connected.
@param banTime Time at which they will be allowed back in.@tsexample
// Kick someone off the server
// %client - This is the connection to the person we are kicking
function kick(%client)
{
^^// Let the server know what happened
^^messageAll( 'MsgAdminForce', '\c2The Admin has kicked %1.', %client.playerName);

^^// If it is not an AI Player, execute the ban.
^^if (!%client.isAIControlled())
^^^BanList::addAbsolute(%client.guid, %client.getAddress(), $pref::Server::KickBanTime);

^^// Let the player know they messed up
^^%client.delete("You have been kicked from this server");
}
@endtsexample</desc>
</method>
<method>
<name>export</name>
<args>( string filename )</args>
<desc>Dump the banlist to a file.

@param filename Path of the file to write the list to.

@tsexample
BanList::Export("./server/banlist.cs");
@endtsexample</desc>
</method>
<method>
<name>isBanned</name>
<args>( int uniqueId, string transportAddress )</args>
<desc>Is someone banned?

@param uniqueId Unique ID of the player.
@param transportAddress Address from which the player connected.

@tsexample
//-----------------------------------------------------------------------------
// This script function is called before a client connection
// is accepted.  Returning  will accept the connection,
// anything else will be sent back as an error to the client.
// All the connect args are passed also to onConnectRequest
function GameConnection::onConnectRequest( %client, %netAddress, %name )
{
^  // Find out who is trying to connect
^  echo("Connect request from: " @ %netAddress);

^  // Are they allowed in?
^  if(BanList::isBanned(%client.guid, %netAddress))
^^  return "CR_YOUAREBANNED";

^  // Is there room for an unbanned player?
^  if($Server::PlayerCount &gt;= $pref::Server::MaxPlayers)
^^  return "CR_SERVERFULL";
^  return ;
}
@endtsexample</desc>
</method>
<method>
<name>removeBan</name>
<args>( int uniqueId, string transportAddress )</args>
<desc>Unban someone.

@param uniqueId Unique ID of the player.
@param transportAddress Address from which the player connected.
@tsexample
BanList::removeBan(%userID, %ipAddress);
@endtsexample</desc>
</method>
</class>
<class>
<name>BasicClouds</name>
<base>SceneObject</base>
<field>
<name>height</name>
<desc>Abstract number which controls the curvature and height of the dome mesh</desc>
</field>
<field>
<name>layerEnabled</name>
<desc>Enable or disable rendering of this layer.</desc>
</field>
<field>
<name>texDirection</name>
<desc>Texture scroll direction for this layer, relative to the world axis.</desc>
</field>
<field>
<name>texOffset</name>
<desc>UV offset for this layer.</desc>
</field>
<field>
<name>texScale</name>
<desc>Texture repeat for this layer.</desc>
</field>
<field>
<name>texSpeed</name>
<desc>Texture scroll speed for this layer.</desc>
</field>
<field>
<name>texture</name>
<desc>Texture for this layer.</desc>
</field>
</class>
<class>
<name>BasicCloudsClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>BehaviorSet</name>
<base>SimSet</base>
</class>
<class>
<name>CachedInterfaceExampleComponent</name>
<base>SimComponent</base>
</class>
<class>
<name>CachedInterfaceExampleComponentClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Camera</name>
<base>ShapeBase</base>
<method>
<name>autoFitRadius</name>
<args>( float radius )</args>
<desc>Move the camera to fully view the given radius.

@note For this operation to take affect a valid edit orbit point must first be specified.  See Camera::setEditOrbitPoint().
@param radius The radius to view.</desc>
</method>
<method>
<name>getAngularVelocity</name>
<args>()</args>
<desc>Get the angular velocity for a Newton mode camera.

@returns The angular velocity in the form of "x y z".
@note Only returns useful results when Camera::newtonRotation is set to true.</desc>
</method>
<method>
<name>getMode</name>
<args>()</args>
<desc>Returns the current camera control mode.

@see CameraMode</desc>
</method>
<method>
<name>getOffset</name>
<args>()</args>
<desc>Get the camera's offset.

The offset is added to the camera's position when set to CameraMode::OrbitObject.
@returns The offset in the form of "x y z".</desc>
</method>
<method>
<name>getPosition</name>
<args>()</args>
<desc>Get the camera's position in the world.

@returns The position in the form of "x y z".</desc>
</method>
<method>
<name>getRotation</name>
<args>()</args>
<desc>Get the camera's Euler rotation in radians.

@returns The rotation in radians in the form of "x y z".</desc>
</method>
<method>
<name>getVelocity</name>
<args>()</args>
<desc>Get the velocity for the camera.

@returns The camera's velocity in the form of "x y z".</desc>
</method>
<method>
<name>isEditOrbitMode</name>
<args>()</args>
<desc>Is the camera in edit orbit mode?

@returns true if the camera is in edit orbit mode.</desc>
</method>
<method>
<name>isRotationDamped</name>
<args>()</args>
<desc>Is this a Newton Fly mode camera with damped rotation?

@returns true if the camera uses a damped rotation.  i.e. Camera::newtonRotation is set to true.</desc>
</method>
<method>
<name>lookAt</name>
<args>( Point3F point )</args>
<desc>Point the camera at the specified position.  Does not work in Orbit or Track modes.

@param point The position to point the camera at.</desc>
</method>
<method>
<name>setAngularDrag</name>
<args>( float drag )</args>
<desc>Set the angular drag for a Newton mode camera.

@param drag The angular drag applied while the camera is rotating.@note Only takes affect when Camera::newtonRotation is set to true.</desc>
</method>
<method>
<name>setAngularForce</name>
<args>( float force )</args>
<desc>Set the angular force for a Newton mode camera.

@param force The angular force applied when attempting to rotate the camera.@note Only takes affect when Camera::newtonRotation is set to true.</desc>
</method>
<method>
<name>setAngularVelocity</name>
<args>( VectorF velocity )</args>
<desc>Set the angular velocity for a Newton mode camera.

@param velocity The angular velocity infor form of "x y z".
@note Only takes affect when Camera::newtonRotation is set to true.</desc>
</method>
<method>
<name>setBrakeMultiplier</name>
<args>( float multiplier )</args>
<desc>Set the Newton mode camera brake multiplier when trigger[1] is active.

@param multiplier The brake multiplier to apply.</desc>
</method>
<method>
<name>setDrag</name>
<args>( float drag )</args>
<desc>Set the drag for a Newton mode camera.

@param drag The drag applied to the camera while moving.</desc>
</method>
<method>
<name>setEditOrbitMode</name>
<args>()</args>
<desc>Set the editor camera to orbit around a point set with Camera::setEditOrbitPoint().

@note This method is generally used only within the World Editor and other tools.  To orbit about an object or point within a game, see Camera::setOrbitMode() and its helper methods.</desc>
</method>
<method>
<name>setEditOrbitPoint</name>
<args>( Point3F point )</args>
<desc>Set the editor camera's orbit point.

@param point The point the camera will orbit in the form of "x y z".</desc>
</method>
<method>
<name>setFlyForce</name>
<args>( float force )</args>
<desc>Set the force applied to a Newton mode camera while moving.

@param force The force applied to the camera while attempting to move.</desc>
</method>
<method>
<name>setFlyMode</name>
<args>()</args>
<desc>Set the camera to fly freely.

Allows the camera to have 6 degrees of freedom.  Provides for instantaneous motion and rotation unless one of the Newton fields has been set to true.  See Camera::newtonMode and Camera::newtonRotation.</desc>
</method>
<method>
<name>setMass</name>
<args>( float mass )</args>
<desc>Set the mass for a Newton mode camera.

@param mass The mass used during ease-in and ease-out calculations.</desc>
</method>
<method>
<name>setNewtonFlyMode</name>
<args>()</args>
<desc>Set the camera to fly freely, but with ease-in and ease-out.

This method allows for the same 6 degrees of freedom as Camera::setFlyMode() but activates the ease-in and ease-out on the camera's movement.  To also activate Newton mode for the camera's rotation, set Camera::newtonRotation to true.</desc>
</method>
<method>
<name>setOffset</name>
<args>( Point3F offset )</args>
<desc>Set the camera's offset.

The offset is added to the camera's position when set to CameraMode::OrbitObject.
@param offset The distance to offset the camera by in the form of "x y z".</desc>
</method>
<method>
<name>setOrbitMode</name>
<args>( GameBase orbitObject, TransformF orbitPoint, float minDistance, float maxDistance, float initDistance, bool ownClientObj=false, Point3F offset=Point3F(0.0f, 0.0f, 0.0f), bool locked=false )</args>
<desc>Set the camera to orbit around the given object, or if none is given, around the given point.

@param orbitObject The object to orbit around.  If no object is given (0 or blank string is passed in) use the orbitPoint instead
@param orbitPoint The point to orbit around when no object is given.  In the form of "x y z ax ay az aa" such as returned by SceneObject::getTransform().
@param minDistance The minimum distance allowed to the orbit object or point.
@param maxDistance The maximum distance allowed from the orbit object or point.
@param initDistance The initial distance from the orbit object or point.
@param ownClientObj [optional] Are we orbiting an object that is owned by us?  Default is false.
@param offset [optional] An offset added to the camera's position.  Default is no offset.
@param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
@see Camera::setOrbitObject()
@see Camera::setOrbitPoint()</desc>
</method>
<method>
<name>setOrbitObject</name>
<args>( GameBase orbitObject, VectorF rotation, float minDistance, float maxDistance, float initDistance, bool ownClientObject=false, Point3F offset=Point3F(0.0f, 0.0f, 0.0f), bool locked=false )</args>
<desc>Set the camera to orbit around a given object.

@param orbitObject The object to orbit around.
@param rotation The initial camera rotation about the object in radians in the form of "x y z".
@param minDistance The minimum distance allowed to the orbit object or point.
@param maxDistance The maximum distance allowed from the orbit object or point.
@param initDistance The initial distance from the orbit object or point.
@param ownClientObj [optional] Are we orbiting an object that is owned by us?  Default is false.
@param offset [optional] An offset added to the camera's position.  Default is no offset.
@param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
@returns false if the given object could not be found.
@see Camera::setOrbitMode()</desc>
</method>
<method>
<name>setOrbitPoint</name>
<args>( TransformF orbitPoint, float minDistance, float maxDistance, float initDistance, Point3F offset=Point3F(0.0f, 0.0f, 0.0f), bool locked=false )</args>
<desc>Set the camera to orbit around a given point.

@param orbitPoint The point to orbit around.  In the form of "x y z ax ay az aa" such as returned by SceneObject::getTransform().
@param minDistance The minimum distance allowed to the orbit object or point.
@param maxDistance The maximum distance allowed from the orbit object or point.
@param initDistance The initial distance from the orbit object or point.
@param offset [optional] An offset added to the camera's position.  Default is no offset.
@param locked [optional] Indicates the camera does not receive input from the player.  Default is false.
@see Camera::setOrbitMode()</desc>
</method>
<method>
<name>setRotation</name>
<args>( Point3F rot )</args>
<desc>Set the camera's Euler rotation in radians.

@param The rotation in radians in the form of "x y z".@note Rotation around the Y axis is ignored</desc>
</method>
<method>
<name>setSpeedMultiplier</name>
<args>( float multiplier )</args>
<desc>Set the Newton mode camera speed multiplier when trigger[0] is active.

@param multiplier The speed multiplier to apply.</desc>
</method>
<method>
<name>setTrackObject</name>
<args>( GameBase trackObject, Point3F offset=Point3F(0.0f, 0.0f, 0.0f) )</args>
<desc>Set the camera to track a given object.

@param objtrackObjectect The object to track.
@param offset [optional] An offset added to the camera's position.  Default is no offset.
@returns false if the given object could not be found.</desc>
</method>
<method>
<name>setValidEditOrbitPoint</name>
<args>( bool validPoint )</args>
<desc>Set if there is a valid editor camera orbit point.

@param validPoint Indicates the validity of the orbit point.</desc>
</method>
<method>
<name>setVelocity</name>
<args>( VectorF velocity )</args>
<desc>Set the velocity for the camera.

@param velocity The camera's velocity in the form of "x y z".</desc>
</method>
<field>
<name>angularDrag</name>
<desc>Drag on camera when rotating.  Default value is 2.</desc>
</field>
<field>
<name>angularForce</name>
<desc>Force applied on camera when asked to rotate.  Default value is 100.</desc>
</field>
<field>
<name>brakeMultiplier</name>
<desc>Speed multiplier when triggering the brake.  Default value is 2.</desc>
</field>
<field>
<name>controlMode</name>
<desc>The current camera control mode.</desc>
</field>
<field>
<name>drag</name>
<desc>Drag on camera when moving.  Default value is 2.</desc>
</field>
<field>
<name>force</name>
<desc>Force applied on camera when asked to move.  Default value is 500.</desc>
</field>
<field>
<name>mass</name>
<desc>The camera's mass.  Default value is 10.</desc>
</field>
<field>
<name>newtonMode</name>
<desc>Apply smoothing (acceleration and damping) to camera movements.</desc>
</field>
<field>
<name>newtonRotation</name>
<desc>Apply smoothing (acceleration and damping) to camera rotations.</desc>
</field>
<field>
<name>speedMultiplier</name>
<desc>Speed multiplier when triggering the accelerator.  Default value is 2.</desc>
</field>
</class>
<class>
<name>CameraBookmark</name>
<base>MissionMarker</base>
</class>
<class>
<name>CameraBookmarkClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>CameraClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>CameraData</name>
<base>ShapeBaseData</base>
</class>
<class>
<name>CameraDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ClientConnectionGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>ClientGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>CloudLayer</name>
<base>SceneObject</base>
<field>
<name>baseColor</name>
<desc>Base cloud color before lighting.</desc>
</field>
<field>
<name>coverage</name>
<desc>Fraction of sky covered by clouds 0-1.</desc>
</field>
<field>
<name>exposure</name>
<desc>Brightness scale so CloudLayer can be overblown if desired.</desc>
</field>
<field>
<name>height</name>
<desc>Abstract number which controls the curvature and height of the dome mesh.</desc>
</field>
<field>
<name>texDirection</name>
<desc>Controls the direction this slot scrolls.</desc>
</field>
<field>
<name>texScale</name>
<desc>Controls the texture repeat of this slot.</desc>
</field>
<field>
<name>texSpeed</name>
<desc>Controls the speed this slot scrolls.</desc>
</field>
<field>
<name>texture</name>
<desc>An RGBA texture which should contain normals and opacity (density).</desc>
</field>
<field>
<name>windSpeed</name>
<desc>Overall scalar to texture scroll speed.</desc>
</field>
</class>
<class>
<name>CloudLayerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>CompoundUndoAction</name>
<base>UndoAction</base>
<method>
<name>addAction</name>
<desc>addAction( UndoAction )</desc>
</method>
</class>
<class>
<name>CompoundUndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ConnectionMessageEvent</name>
</class>
<class>
<name>ConnectionMessageEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ConsoleClassObject</name>
<base>ConsoleReflectionObject</base>
<method>
<name>createObject</name>
<args>( string name=, id group=RootGroup )</args>
<desc>Return a new instance of this class.</desc>
</method>
<method>
<name>getCategory</name>
<args>()</args>
<desc>Return the category string for the class.</desc>
</method>
<method>
<name>getDescription</name>
<args>()</args>
<desc>Return the description string for the class.</desc>
</method>
<method>
<name>getNameOfClass</name>
<args>()</args>
<desc>Return the name of the class.</desc>
</method>
<method>
<name>getSuperClass</name>
<args>()</args>
<desc>Return the meta-object of the superclass (0 for SimObject).</desc>
</method>
<method>
<name>isSubclassOf</name>
<args>( id classObject )</args>
<desc>Return true if this class is a subclass of the class represented by the given class object.</desc>
</method>
<method>
<name>lookup</name>
<args>( string className )</args>
<desc>Return the class object for the given class.</desc>
</method>
<method>
<name>lookupField</name>
<args>( string fieldName )</args>
<desc>Look up the given field in the hierarchy of this class.</desc>
</method>
<method>
<name>lookupMethod</name>
<args>( string methodName )</args>
<desc>Look up the given method in the hierarchy of this class.</desc>
</method>
</class>
<class>
<name>ConsoleClassObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ConsoleClassObjectGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>ConsoleFieldObject</name>
<base>ConsoleReflectionObject</base>
<method>
<name>getDefiningClass</name>
<args>()</args>
<desc>Return the meta-object for the class that defines this field.</desc>
</method>
<method>
<name>getFieldType</name>
<args>()</args>
<desc>Return the field type name.</desc>
</method>
<method>
<name>getNameOfField</name>
<args>()</args>
<desc>Return the name of the field.</desc>
</method>
<method>
<name>getValueFromObject</name>
<args>( id object, int offset=0 )</args>
</method>
</class>
<class>
<name>ConsoleFieldObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ConsoleFunctionObject</name>
<base>ConsoleReflectionObject</base>
<method>
<name>getMaxNumArgs</name>
<args>()</args>
<desc>Return the maximum number of arguments that this function expects.</desc>
</method>
<method>
<name>getMinNumArgs</name>
<args>()</args>
<desc>Return the minimum number of arguments that this function expects.</desc>
</method>
<method>
<name>getReturnType</name>
<args>()</args>
<desc>Return the type of values returned by this function.</desc>
</method>
<method>
<name>getUsage</name>
<args>()</args>
<desc>Return the usage string for the function.</desc>
</method>
</class>
<class>
<name>ConsoleFunctionObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ConsoleLogger</name>
<base>SimObject</base>
<method>
<name>attach</name>
<args>()</args>
<desc>Attaches the logger to the console and begins writing to file@tsexample
// Create the logger
// Will automatically start writing to testLogging.txt with normal priority
new ConsoleLogger(logger, "testLogging.txt", false);

// Send something to the console, with the logger consumes and writes to file
echo("This is logged to the file");

// Stop logging, but do not delete the logger
logger.detach();

echo("This is not logged to the file");

// Attach the logger to the console again
logger.attach();

// Logging has resumed
echo("Logging has resumed");@endtsexample</desc>
</method>
<method>
<name>detach</name>
<args>()</args>
<desc>Detaches the logger from the console and stops writing to file@tsexample
// Create the logger
// Will automatically start writing to testLogging.txt with normal priority
new ConsoleLogger(logger, "testLogging.txt", false);

// Send something to the console, with the logger consumes and writes to file
echo("This is logged to the file");

// Stop logging, but do not delete the logger
logger.detach();

echo("This is not logged to the file");

// Attach the logger to the console again
logger.attach();

// Logging has resumed
echo("Logging has resumed");@endtsexample</desc>
</method>
<field>
<name>level</name>
<desc>Determines the priority level and attention the logged entry gets when recorded</desc>
</field>
</class>
<class>
<name>ConsoleLoggerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ConsoleMethodObject</name>
<base>ConsoleFunctionObject</base>
</class>
<class>
<name>ConsoleMethodObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ConsoleReflectionObject</name>
<base>SimGroup</base>
</class>
<class>
<name>ConsoleReflectionObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ConvexShape</name>
<base>SceneObject</base>
<field>
<name>Material</name>
<desc>Material used to render the ConvexShape surface.</desc>
</field>
<field>
<name>surface</name>
<desc>Do not modify, for internal use.</desc>
</field>
</class>
<class>
<name>ConvexShapeClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>CreatorTree</name>
<base>GuiArrayCtrl</base>
<method>
<name>addGroup</name>
<args>(string group, string name, string value)</args>
</method>
<method>
<name>addItem</name>
<args>(Node group, string name, string value)</args>
</method>
<method>
<name>clear</name>
<desc>Clear the tree.</desc>
</method>
<method>
<name>fileNameMatch</name>
<args>(string world, string type, string filename)</args>
</method>
<method>
<name>getName</name>
<args>(Node item)</args>
</method>
<method>
<name>getParent</name>
<args>(Node n)</args>
</method>
<method>
<name>getSelected</name>
<desc>Return a handle to the currently selected item.</desc>
</method>
<method>
<name>getValue</name>
<args>(Node n)</args>
</method>
<method>
<name>isGroup</name>
<args>(Group g)</args>
</method>
</class>
<class>
<name>CreatorTreeClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>CubemapData</name>
<base>SimObject</base>
<method>
<name>getFilename</name>
<args>()</args>
<desc>Returns the script filename of where the CubemapData object was defined.  This is used by the material editor.</desc>
</method>
<method>
<name>updateFaces</name>
<args>()</args>
<desc>Update the assigned cubemaps faces.</desc>
</method>
<field>
<name>cubeFace</name>
<desc>@breif The 6 cubemap face textures for a static cubemap.

They are in the following order:
- cubeFace[0] is -X
- cubeFace[1] is +X
- cubeFace[2] is -Z
- cubeFace[3] is +Z
- cubeFace[4] is -Y
- cubeFace[5] is +Y</desc>
</field>
<field>
<name>dynamic</name>
<desc>Set to true if this is a dynamic cubemap.  The default is false.</desc>
</field>
<field>
<name>dynamicFarDist</name>
<desc>The far clip distance used when rendering to the dynamic cubemap.</desc>
</field>
<field>
<name>dynamicNearDist</name>
<desc>The near clip distance used when rendering to the dynamic cubemap.</desc>
</field>
<field>
<name>dynamicObjectTypeMask</name>
<desc>The typemask used to filter the objects rendered to the dynamic cubemap.</desc>
</field>
<field>
<name>dynamicSize</name>
<desc>The size of each dynamic cubemap face in pixels.</desc>
</field>
</class>
<class>
<name>CubemapDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>CustomMaterial</name>
<base>Material</base>
<field>
<name>fallback</name>
<desc>Alternate CustomMaterial targeting lower end hardware</desc>
</field>
<field>
<name>shader</name>
<desc>Name of a GFXShaderData for this effect</desc>
</field>
<field>
<name>stateBlock</name>
<desc>Name of a GFXStateBlockData for this effect</desc>
</field>
<field>
<name>target</name>
<desc>String identifier of this material's target texture</desc>
</field>
<field>
<name>version</name>
<desc>Specifies pixel shader version for hardware, such as 2.0, 3.0, etc</desc>
</field>
</class>
<class>
<name>CustomMaterialClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DataBlockGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>DataBlockSet</name>
<base>SimSet</base>
</class>
<class>
<name>DBDeleteUndoAction</name>
<base>UndoAction</base>
</class>
<class>
<name>DBDeleteUndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DbgFileView</name>
<base>GuiArrayCtrl</base>
<method>
<name>clearBreakPositions</name>
<args>()</args>
<desc>Clear all break points in the current file.</desc>
</method>
<method>
<name>findString</name>
<args>(string findThis)</args>
<desc>Find the specified string in the currently viewed file and scroll it into view.</desc>
</method>
<method>
<name>getCurrentLine</name>
<args>()</args>
<desc>Get the currently executing file and line, if any.

@returns A string containing the file, a tab, and then the line number. Use getField() with this.</desc>
</method>
<method>
<name>open</name>
<args>(string filename)</args>
<desc>Open a file for viewing.

@note This loads the file from the local system.</desc>
</method>
<method>
<name>removeBreak</name>
<args>(int line)</args>
<desc>Remove a breakpoint from the specified line.</desc>
</method>
<method>
<name>setBreak</name>
<args>(int line)</args>
<desc>Set a breakpoint at the specified line.</desc>
</method>
<method>
<name>setBreakPosition</name>
<args>(int line)</args>
<desc>Set a breakpoint at the specified line.</desc>
</method>
<method>
<name>setCurrentLine</name>
<args>(int line, bool selected)</args>
<desc>Set the current highlighted line.</desc>
</method>
</class>
<class>
<name>DbgFileViewClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DBRetargetUndoAction</name>
<base>UndoAction</base>
</class>
<class>
<name>DBRetargetUndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Debris</name>
<base>GameBase</base>
<method>
<name>init</name>
<args>( string inputPosition="1.0 1.0 1.0", string inputVelocity="1.0 0.0 0.0" )</args>
<desc>Set this piece of debris at the given position with the given velocity.
@param Position Position to place the debris.
@param Velocity Velocity to move the debris after it has been placed.
@return Always returns true.
@tsexample
// Define the position
%position = "1.0 1.0 1.0";

// Define the velocity
%velocity = "1.0 0.0 0.0";

// Inform the debris object of its new position and velocity
%debris.init(%position,%velocity);
@endtsexample
@see DebrisData

@see Explosion

@see ExplosionData

@ingroup FX</desc>
</method>
<field>
<name>Lifetime</name>
<desc>Length of time for this debris object to exist. When expired, the object will be deleted.</desc>
</field>
</class>
<class>
<name>DebrisClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DebrisData</name>
<base>GameBaseData</base>
<field>
<name>baseRadius</name>
<desc>Radius at which the standard elasticity and friction apply.</desc>
</field>
<field>
<name>bounceVariance</name>
<desc>Allowed variance in the value of numBounces.</desc>
</field>
<field>
<name>elasticity</name>
<desc>A floating-point value specifying how 'bouncy' this object is.</desc>
</field>
<field>
<name>emitters</name>
<desc>List of particle emitters to spawn along with this debris object.</desc>
</field>
<field>
<name>explodeOnMaxBounce</name>
<desc>If true, this debris object will explode after it has bounced max times.</desc>
</field>
<field>
<name>Explosion</name>
<desc>ExplosionData to spawn along with this debris object.</desc>
</field>
<field>
<name>fade</name>
<desc>If true, this debris object will fade out when destroyed.</desc>
</field>
<field>
<name>friction</name>
<desc>A floating-point value specifying how much velocity is lost to impact and sliding friction.</desc>
</field>
<field>
<name>gravModifier</name>
<desc>How much gravity affects debris.</desc>
</field>
<field>
<name>ignoreWater</name>
<desc>If true, this debris object will not collide with water, acting as if the water is not there.</desc>
</field>
<field>
<name>Lifetime</name>
<desc>Amount of time until this debris object is destroyed.</desc>
</field>
<field>
<name>lifetimeVariance</name>
<desc>Allowed variance in the value of lifetime.</desc>
</field>
<field>
<name>maxSpinSpeed</name>
<desc>Maximum speed that this debris object will rotate.</desc>
</field>
<field>
<name>minSpinSpeed</name>
<desc>Minimum speed that this debris object will rotate.</desc>
</field>
<field>
<name>numBounces</name>
<desc>How many times to allow this debris object to bounce until it either explodes, becomes static or snaps (defined in explodeOnMaxBounce, staticOnMaxBounce, snapOnMaxBounce).</desc>
</field>
<field>
<name>shapeFile</name>
<desc>Object model to use for this debris object.</desc>
</field>
<field>
<name>snapOnMaxBounce</name>
<desc>If true, this debris object will snap into a resting position on the last bounce.</desc>
</field>
<field>
<name>staticOnMaxBounce</name>
<desc>If true, this debris object becomes static after it has bounced max times.</desc>
</field>
<field>
<name>terminalVelocity</name>
<desc>Max velocity magnitude.</desc>
</field>
<field>
<name>texture</name>
<desc>Texture imagemap to use for this debris object.</desc>
</field>
<field>
<name>useRadiusMass</name>
<desc>Use mass calculations based on radius.</desc>
</field>
<field>
<name>velocity</name>
<desc>Speed at which this debris object will move.</desc>
</field>
<field>
<name>velocityVariance</name>
<desc>Allowed variance in the value of velocity</desc>
</field>
</class>
<class>
<name>DebrisDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DebugDraw</name>
<base>DebugDrawer</base>
</class>
<class>
<name>DebugDrawer</name>
<base>SimObject</base>
<method>
<name>drawBox</name>
<args>( Point3F a, Point3F b, ColorF color=ColorF::WHITE )</args>
<desc>Draws an axis aligned box primitive within the two 3d points.</desc>
</method>
<method>
<name>drawLine</name>
<args>( Point3F a, Point3F b, ColorF color=ColorF::WHITE )</args>
<desc>Draws a line primitive between two 3d points.</desc>
</method>
<method>
<name>setLastTTL</name>
<args>( int ms )</args>
<desc>Sets the "time to live" (TTL) for the last rendered primitive.</desc>
</method>
<method>
<name>setLastZTest</name>
<args>( bool enabled )</args>
<desc>Sets the z buffer reading state for the last rendered primitive.</desc>
</method>
<method>
<name>toggleDrawing</name>
<args>()</args>
<desc>Toggles the rendering of DebugDrawer primitives.</desc>
</method>
<method>
<name>toggleFreeze</name>
<args>()</args>
<desc>Toggles freeze mode which keeps the currently rendered primitives from expiring.</desc>
</method>
</class>
<class>
<name>DebugDrawerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DecalData</name>
<base>SimDataBlock</base>
<method>
<name>postApply</name>
<args>()</args>
<desc>Reloads imagemap textures for this DecalData.
@tsexample
// Inform the decal object to reload its imagemap and frame data.
%decalData.postApply();
@endtsexample</desc>
</method>
<field>
<name>clippingAngle</name>
<desc>The angle in degrees used to clip geometry that faces away from the decal projection direction.</desc>
</field>
<field>
<name>fadeEndPixelSize</name>
<desc>LOD value - size in pixels at which decals of this type are fully faded out. This should be a smaller value than fadeStartPixelSize.</desc>
</field>
<field>
<name>fadeStartPixelSize</name>
<desc>LOD value - size in pixels at which decals of this type begin to fade out. This should be a larger value than fadeEndPixelSize. However, you may also set this to a negative value to disable lod-based fading.</desc>
</field>
<field>
<name>fadeTime</name>
<desc>Milliseconds of sim time for decal to fade after expiration.</desc>
</field>
<field>
<name>frame</name>
<desc>Index of texture rectangle to use for this decal.</desc>
</field>
<field>
<name>lifeSpan</name>
<desc>Milliseconds of sim time for decal to expire.</desc>
</field>
<field>
<name>Material</name>
<desc>Material for this decal type.</desc>
</field>
<field>
<name>randomize</name>
<desc>If true, a random texture rectangle is picked for each instance of this decal.</desc>
</field>
<field>
<name>renderPriority</name>
<desc>Default renderPriority for decals of this type.</desc>
</field>
<field>
<name>size</name>
<desc>Width/height in meters before scale is applied.</desc>
</field>
<field>
<name>texCols</name>
<desc>Number of columns on the supplied imagemap.</desc>
</field>
<field>
<name>texRows</name>
<desc>Number of rows on the supplied imagemap.</desc>
</field>
<field>
<name>textureCoordCount</name>
<desc>Number of individual frames in this imagemap.</desc>
</field>
<field>
<name>textureCoords</name>
<desc>A RectF in uv space - eg ( topleft.x topleft.y extent.x extent.y )</desc>
</field>
</class>
<class>
<name>DecalDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DecalManager</name>
<base>SceneObject</base>
</class>
<class>
<name>DecalManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DecalRoad</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
<args>()</args>
<desc>Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply. This will transmit the material and other fields ( not including nodes ) to client objects.</desc>
</method>
<method>
<name>regenerate</name>
<args>()</args>
<desc>Intended as a helper to developers and editor scripts.
Force DecalRoad to update it's spline and reclip geometry.</desc>
</method>
<field>
<name>breakAngle</name>
<desc>Angle in degrees - DecalRoad will subdivided the spline if its curve is greater than this threshold.</desc>
</field>
<field>
<name>Material</name>
<desc>Material used for rendering.</desc>
</field>
<field>
<name>Node</name>
<desc>Do not modify, for internal use.</desc>
</field>
<field>
<name>renderPriority</name>
<desc>DecalRoad(s) are rendered in descending renderPriority order.</desc>
</field>
<field>
<name>textureLength</name>
<desc>The length in meters of textures mapped to the DecalRoad</desc>
</field>
</class>
<class>
<name>DecalRoadClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DICreateUndoAction</name>
<base>UndoAction</base>
</class>
<class>
<name>DICreateUndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DIDeleteUndoAction</name>
<base>UndoAction</base>
</class>
<class>
<name>DIDeleteUndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>DynamicConsoleMethodComponent</name>
<base>SimComponent</base>
<method>
<name>callMethod</name>
<args>(methodName, argi)</args>
<desc>Calls script defined method
@param methodName The method's name as a string
@param argi Any arguments to pass to the method
@return No return value@note %obj.callMethod( %methodName, %arg1, %arg2, ... );</desc>
</method>
</class>
<class>
<name>DynamicConsoleMethodComponentClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>EditManager</name>
<base>GuiControl</base>
<method>
<name>editorDisabled</name>
<desc>Perform the onEditorDisabled callback on all SimObjects and set gEditingMission false</desc>
</method>
<method>
<name>editorEnabled</name>
<desc>Perform the onEditorEnabled callback on all SimObjects and set gEditingMission true</desc>
</method>
<method>
<name>gotoBookmark</name>
<args>(int slot)</args>
</method>
<method>
<name>isEditorEnabled</name>
<desc>Return the value of gEditingMission.</desc>
</method>
<method>
<name>setBookmark</name>
<args>(int slot)</args>
</method>
</class>
<class>
<name>EditManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>EditorIconRegistry</name>
<method>
<name>add</name>
<args>( String className, String imageFile [, bool overwrite = true] )</args>
<desc>@internal</desc>
</method>
<method>
<name>clear</name>
<desc>@internal</desc>
</method>
<method>
<name>findIconByClassName</name>
<args>( String className )</args>
<desc>Returns the file path to the icon file if found.@internal</desc>
</method>
<method>
<name>findIconBySimObject</name>
<args>( SimObject )</args>
<desc>Returns the file path to the icon file if found.@internal</desc>
</method>
<method>
<name>loadFromPath</name>
<args>( String imagePath [, bool overwrite = true] )</args>
<desc>@internal</desc>
</method>
</class>
<class>
<name>EditTSCtrl</name>
<base>GuiTSCtrl</base>
<method>
<name>getDisplayType</name>
<args>()</args>
</method>
<method>
<name>getGizmo</name>
<args>()</args>
</method>
<method>
<name>getOrthoFOV</name>
<args>()</args>
<desc>Return the FOV for orthographic views.</desc>
</method>
<method>
<name>isMiddleMouseDown</name>
<args>()</args>
</method>
<method>
<name>renderBox</name>
<args>( Point3F pos, Point3F size )</args>
</method>
<method>
<name>renderCircle</name>
<args>( Point3F pos, Point3F normal, float radius, int segments=0 )</args>
</method>
<method>
<name>renderLine</name>
<args>( Point3F start, Point3F end, float lineWidth=0 )</args>
</method>
<method>
<name>renderSphere</name>
<args>( Point3F pos, float radius, int sphereLevel=0 )</args>
</method>
<method>
<name>renderTriangle</name>
<args>( Point3F a, Point3F b, Point3F c )</args>
</method>
<method>
<name>setDisplayType</name>
<args>( int displayType )</args>
</method>
<method>
<name>setOrthoFOV</name>
<args>( float fov )</args>
<desc>Set the FOV for to use for orthographic views.</desc>
</method>
<field>
<name>allowBorderMove</name>
<desc>bool allowBorderMove</desc>
</field>
<field>
<name>borderMovePixelSize</name>
<desc>int borderMovePixelSize</desc>
</field>
<field>
<name>borderMoveSpeed</name>
<desc>float borderMoveSpeed</desc>
</field>
<field>
<name>consoleCircleSegments</name>
<desc>int consoleCircleSegments</desc>
</field>
<field>
<name>consoleFillColor</name>
<desc>ColorI consoleFillColor</desc>
</field>
<field>
<name>consoleFrameColor</name>
<desc>ColorI consoleFrameColor</desc>
</field>
<field>
<name>consoleLineWidth</name>
<desc>int consoleLineWidth</desc>
</field>
<field>
<name>consoleSphereLevel</name>
<desc>int consoleSphereLevel</desc>
</field>
<field>
<name>GizmoProfile</name>
<desc>GizmoProfile GizmoProfile</desc>
</field>
<field>
<name>gridColor</name>
<desc>ColorI gridColor</desc>
</field>
<field>
<name>gridMinorTickColor</name>
<desc>ColorI gridMinorTickColor</desc>
</field>
<field>
<name>gridOriginColor</name>
<desc>ColorI gridOriginColor</desc>
</field>
<field>
<name>gridSize</name>
<desc>float gridSize</desc>
</field>
<field>
<name>missionAreaFillColor</name>
<desc>ColorI missionAreaFillColor</desc>
</field>
<field>
<name>missionAreaFrameColor</name>
<desc>ColorI missionAreaFrameColor</desc>
</field>
<field>
<name>renderMissionArea</name>
<desc>bool renderMissionArea</desc>
</field>
<field>
<name>renderOrthoGrid</name>
<desc>Whether to render the grid in orthographic axial projections.</desc>
</field>
<field>
<name>renderOrthoGridPixelBias</name>
<desc>Grid patch pixel size below which to switch to coarser grid resolutions.</desc>
</field>
</class>
<class>
<name>EditTSCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>EventManager</name>
<base>SimObject</base>
<method>
<name>dumpEvents</name>
<args>()</args>
<desc>Print all registered events to the console.</desc>
</method>
<method>
<name>dumpSubscribers</name>
<args>( String event )</args>
<desc>Print all subscribers to an event to the console.
@param event The event whose subscribers are to be printed. If this parameter isn't specified, all events will be dumped.</desc>
</method>
<method>
<name>isRegisteredEvent</name>
<args>( String event )</args>
<desc>Check if an event is registered or not.
@param event The event to check.
@return Whether or not the event exists.</desc>
</method>
<method>
<name>postEvent</name>
<args>( String event, String data )</args>
<desc>Trigger an event.
@param event The event to trigger.
@param data The data associated with the event.
@return Whether or not the event was dispatched successfully.</desc>
</method>
<method>
<name>registerEvent</name>
<args>( String event )</args>
<desc>Register an event with the event manager.
@param event The event to register.
@return Whether or not the event was registered successfully.</desc>
</method>
<method>
<name>remove</name>
<args>( SimObject listener, String event )</args>
<desc>Remove a listener from an event.
@param listener The listener to remove.
@param event The event to be removed from.</desc>
</method>
<method>
<name>removeAll</name>
<args>( SimObject listener )</args>
<desc>Remove a listener from all events.
@param listener The listener to remove.</desc>
</method>
<method>
<name>subscribe</name>
<args>( SimObject listener, String event, String callback )</args>
<desc>Subscribe a listener to an event.
@param listener The listener to subscribe.
@param event The event to subscribe to.
@param callback Optional method name to receive the event notification. If this is not specified, "on[event]" will be used.
@return Whether or not the subscription was successful.</desc>
</method>
<method>
<name>unregisterEvent</name>
<args>( String event )</args>
<desc>Remove an event from the EventManager.
@param event The event to remove.</desc>
</method>
<field>
<name>queue</name>
<desc>List of events currently waiting</desc>
</field>
</class>
<class>
<name>EventManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Explosion</name>
<base>GameBase</base>
</class>
<class>
<name>ExplosionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ExplosionData</name>
<base>GameBaseData</base>
<field>
<name>camShakeAmp</name>
<desc>Amplitude to shake the camera, defined as the 3 F32 values of X Y Z.</desc>
</field>
<field>
<name>camShakeDuration</name>
<desc>Duration to shake the camera.</desc>
</field>
<field>
<name>camShakeFalloff</name>
<desc>Falloff value for the camera shake.</desc>
</field>
<field>
<name>camShakeFreq</name>
<desc>Frequency to shake the camera, defined as the 3 F32 values of X Y Z.</desc>
</field>
<field>
<name>camShakeRadius</name>
<desc>Radial distance that a camera's position must be in relation to the center of the explosion to have its camera shaken.</desc>
</field>
<field>
<name>Debris</name>
<desc>List of DebrisData to spawn with this explosion.</desc>
</field>
<field>
<name>debrisNum</name>
<desc>Number of debris objects to create.</desc>
</field>
<field>
<name>debrisNumVariance</name>
<desc>Variance in the number of debris objects to create, from 0 to n.</desc>
</field>
<field>
<name>debrisPhiMax</name>
<desc>Maximum reference angle, from the vertical plane, to eject debris from.</desc>
</field>
<field>
<name>debrisPhiMin</name>
<desc>Minimum reference angle, from the vertical plane, to eject debris from.</desc>
</field>
<field>
<name>debrisThetaMax</name>
<desc>Maximum angle, from the horizontal plane, to eject debris from.</desc>
</field>
<field>
<name>debrisThetaMin</name>
<desc>Minimum angle, from the horizontal plane, to eject debris from.</desc>
</field>
<field>
<name>debrisVelocity</name>
<desc>Velocity to toss debris at.</desc>
</field>
<field>
<name>debrisVelocityVariance</name>
<desc>Variance in the debris velocity, from 0 to n.</desc>
</field>
<field>
<name>delayMS</name>
<desc>Amount of time, in milliseconds, to delay the explosion from starting from the creation of this ExplosionData object.</desc>
</field>
<field>
<name>delayVariance</name>
<desc>Variance of the delayMS, in milliseconds, to delay the expolosion from start from the creation of this ExplosionData object.</desc>
</field>
<field>
<name>emitter</name>
<desc>List of ParticleEmitterData objects to spawn with this explosion.</desc>
</field>
<field>
<name>explosionScale</name>
<desc>Scale size create the explosionShape DTS model at the start of the explosion.</desc>
</field>
<field>
<name>explosionShape</name>
<desc>DTS shape to place at the center of the explosion. The 'ambient' animation of this model will automatically be played at the start of the explosion.</desc>
</field>
<field>
<name>faceViewer</name>
<desc>Boolean, sets if the visual effects of the explosion should or should not face the player.</desc>
</field>
<field>
<name>lifetimeMS</name>
<desc>Lifetime, in milliseconds, of this ExplosionData object.</desc>
</field>
<field>
<name>lifetimeVariance</name>
<desc>Time variance, in milliseconds, for the lifetimeMS of this ExplosionData object.</desc>
</field>
<field>
<name>lightEndBrightness</name>
<desc>float lightEndBrightness</desc>
</field>
<field>
<name>lightEndColor</name>
<desc>ColorF lightEndColor</desc>
</field>
<field>
<name>lightEndRadius</name>
<desc>float lightEndRadius</desc>
</field>
<field>
<name>lightNormalOffset</name>
<desc>float lightNormalOffset</desc>
</field>
<field>
<name>lightStartBrightness</name>
<desc>float lightStartBrightness</desc>
</field>
<field>
<name>lightStartColor</name>
<desc>ColorF lightStartColor</desc>
</field>
<field>
<name>lightStartRadius</name>
<desc>float lightStartRadius</desc>
</field>
<field>
<name>offset</name>
<desc>Allowed offset for the center position of this ExplosionData to be created from the specified position.</desc>
</field>
<field>
<name>particleDensity</name>
<desc>Density of the particles used in the explosion.</desc>
</field>
<field>
<name>ParticleEmitter</name>
<desc>ParticleEmitterData object to be spawned with this explosion.</desc>
</field>
<field>
<name>particleRadius</name>
<desc>Radius distance that particles should travel from the explosion.</desc>
</field>
<field>
<name>playSpeed</name>
<desc>Time scale at which to play the full explosion sequence.</desc>
</field>
<field>
<name>shakeCamera</name>
<desc>Boolean, determines if the camera shakes or not during this explosion.</desc>
</field>
<field>
<name>sizes</name>
<desc>Sizes to set the ExplosionData. Up to 4 allowed. Will transition through sizes based on values set in the times value.</desc>
</field>
<field>
<name>soundProfile</name>
<desc>Non-looping sound effect that will be played at the start of the explosion.</desc>
</field>
<field>
<name>subExplosion</name>
<desc>List of additional ExplosionData objects to create alongside this ExplosionData object.</desc>
</field>
<field>
<name>times</name>
<desc>Times to transition through the explosion effect. Up to 4 allowed. Values are 0.0 - 1.0, and corrispond to the life of the ExplosionData where 0 is the beginning and 1 is end of the lifespace.</desc>
</field>
</class>
<class>
<name>ExplosionDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>FieldBrushObject</name>
<base>SimObject</base>
<method>
<name>copyFields</name>
<args>(simObject, [fieldList])</args>
<desc>Copy selected static-fields for selected object./
@param simObject Object to copy static-fields from.
@param fieldList fields to filter static-fields against.
@return No return value.</desc>
</method>
<method>
<name>pasteFields</name>
<args>(simObject)</args>
<desc>Paste copied static-fields to selected object./
@param simObject Object to paste static-fields to.
@return No return value.</desc>
</method>
<method>
<name>queryFields</name>
<args>(simObject, [groupList])</args>
<desc>Query available static-fields for selected object./
@param simObject Object to query static-fields on.
@param groupList groups to filter static-fields against.
@return Space-seperated static-field list.</desc>
</method>
<method>
<name>queryGroups</name>
<args>(simObject)</args>
<desc>Query available static-field groups for selected object./
@param simObject Object to query static-field groups on.
@return Space-seperated static-field group list.</desc>
</method>
<field>
<name>description</name>
<desc>caseString description</desc>
</field>
<field>
<name>sortName</name>
<desc>string sortName</desc>
</field>
</class>
<class>
<name>FieldBrushObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>FileChunkEvent</name>
</class>
<class>
<name>FileChunkEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>FileDialog</name>
<base>SimObject</base>
<method>
<name>Execute</name>
<args>()</args>
<desc>Launches the OS file browser
@tsexample
// NOTE: This is not he preferred class to use, but this still works

// Create the file dialog
%baseFileDialog = new FileDialog()
{
// Allow browsing of all file types
filters = "*.*";

// No default file
defaultFile = ;

// Set default path relative to project
defaultPath = "./";

// Set the title
title = "Durpa";

// Allow changing of path you are browsing
changePath = true;
};

// Launch the file dialog
%baseFileDialog.Execute();

// Don't forget to cleanup
%baseFileDialog.delete();


// A better alternative is to use the
// derived classes which are specific to file open and save

// Create a dialog dedicated to opening files
%openFileDlg = new OpenFileDialog()
{
// Look for jpg image files
// First part is the descriptor|second part is the extension
Filters = "Jepg Files|*.jpg";
// Allow browsing through other folders
ChangePath = true;

// Only allow opening of one file at a time
MultipleFiles = false;
};

// Launch the open file dialog
%openFileDlg.Execute();

// Cleanup
%openFileDlg.delete();


// Create a dialog dedicated to opening file
%saveFileDlg = new SaveFileDialog()
{
// Only allow for saving of COLLADA files
Filters        = "COLLADA Files (*.dae)|*.dae|";

// Default save path to where the WorldEditor last saved
DefaultPath    = $pref::WorldEditor::LastPath;

// No default file specified
DefaultFile    = "";

// Do not allow the user to change to a new directory
ChangePath     = false;

// Prompt the user if they are going to overwrite an existing file
OverwritePrompt   = true;
};

// Launch the save file dialog
%saveFileDlg.Execute();

// Cleanup
%saveFileDlg.delete();
@endtsexample

@return True if the file was selected was successfully found (opened) and declared (saved).</desc>
</method>
<field>
<name>changePath</name>
<desc>True/False whether to set the working directory to the directory returned by the dialog.</desc>
</field>
<field>
<name>defaultFile</name>
<desc>The default file path when the dialog is shown.</desc>
</field>
<field>
<name>defaultPath</name>
<desc>The default directory path when the dialog is shown.</desc>
</field>
<field>
<name>fileName</name>
<desc>The default file name when the dialog is shown.</desc>
</field>
<field>
<name>filters</name>
<desc>The filter string for limiting the types of files visible in the dialog.  For example:

^ 'All Files|*.*'
^ 'Image Files|*.png;*.jpg|Png Files|*.png|Jepg Files|*.jpg'</desc>
</field>
<field>
<name>title</name>
<desc>The title for the dialog.</desc>
</field>
</class>
<class>
<name>FileDialogClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>FileDownloadRequestEvent</name>
</class>
<class>
<name>FileDownloadRequestEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>FileObject</name>
<base>SimObject</base>
<method>
<name>close</name>
<args>()</args>
<desc>@brief Close the file.

It is EXTREMELY important that you call this function when you are finished reading or writing to a file. Failing to do so is not only a bad programming practice, but could result in bad data or corrupt files. Remember: Open, Read/Write, Close, Delete...in that order!

@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");

// Peek the first line
%line = %fileRead.peekLine();

// Print the line we just peeked
echo(%line);
// If we peek again...
%line = %fileRead.peekLine();

// We will get the same output as the first time
// since the stream did not move forward
echo(%line);

// Close the file when finished
%fileWrite.close();

// Cleanup the file object
%fileWrite.delete();
@endtsexample</desc>
</method>
<method>
<name>isEOF</name>
<args>()</args>
<desc>@brief Determines if the parser for this FileObject has reached the end of the file

@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");

// Keep reading until we reach the end of the file
while( !%fileRead.isEOF() )
{
%line = %fileRead.readline();
echo(%line);
}
// Made it to the end
echo("Finished reading file");
@endtsexample

@return True if the parser has reached the end of the file, false otherwise</desc>
</method>
<method>
<name>openForAppend</name>
<args>( string filename )</args>
<desc>@brief Open a specified file for writing, adding data to the end of the file

There is no limit as to what kind of file you can write. Any format and data is allowable, not just text. Unlike openForWrite, which will erase an existing file if it is opened, openForAppend preserves data in an existing file and adds to it.

@param filename Path, name, and extension of file to append to@tsexample
// Create a file object for writing
%fileWrite = new FileObject();

// Open a file to write to, if it does not exist it will be created
// If it does exist, whatever we write will be added to the end
%fileWrite.OpenForAppend("./test.txt");
@endtsexample

@return True if file was successfully opened, false otherwise</desc>
</method>
<method>
<name>openForRead</name>
<args>( string filename )</args>
<desc>@brief Open a specified file for reading

There is no limit as to what kind of file you can read. Any format and data contained within is accessible, not just text

@param filename Path, name, and extension of file to be read@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");
@endtsexample

@return True if file was successfully opened, false otherwise</desc>
</method>
<method>
<name>openForWrite</name>
<args>( string filename )</args>
<desc>@brief Open a specified file for writing

There is no limit as to what kind of file you can write. Any format and data is allowable, not just text

@param filename Path, name, and extension of file to write to@tsexample
// Create a file object for writing
%fileWrite = new FileObject();

// Open a file to write to, if it does not exist it will be created
%fileWrite.OpenForWrite("./test.txt");
@endtsexample

@return True if file was successfully opened, false otherwise</desc>
</method>
<method>
<name>peekLine</name>
<args>()</args>
<desc>@brief Read a line from the file without moving the stream position.

Emphasis on *line*, as in you cannot parse individual characters or chunks of data. There is no limitation as to what kind of data you can read. Unlike readLine, the parser does not move forward after reading.

@param filename Path, name, and extension of file to be read@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");

// Peek the first line
%line = %fileRead.peekLine();

// Print the line we just peeked
echo(%line);
// If we peek again...
%line = %fileRead.peekLine();

// We will get the same output as the first time
// since the stream did not move forward
echo(%line);
@endtsexample

@return String containing the line of data that was just peeked</desc>
</method>
<method>
<name>readLine</name>
<args>()</args>
<desc>@brief Read a line from file.

Emphasis on *line*, as in you cannot parse individual characters or chunks of data. There is no limitation as to what kind of data you can read.

@tsexample
// Create a file object for reading
%fileRead = new FileObject();

// Open a text file, if it exists
%fileRead.OpenForRead("./test.txt");

// Read in the first line
%line = %fileRead.readline();

// Print the line we just read
echo(%line);
@endtsexample

@return String containing the line of data that was just read</desc>
</method>
<method>
<name>writeLine</name>
<args>( string text )</args>
<desc>@brief Write a line to the file, if it was opened for writing.

There is no limit as to what kind of text you can write. Any format and data is allowable, not just text. Be careful of what you write, as whitespace, current values, and literals will be preserved.

@param text The data we are writing out to file.@tsexample
// Create a file object for writing
%fileWrite = new FileObject();

// Open a file to write to, if it does not exist it will be created
%fileWrite.OpenForWrite("./test.txt");

// Write a line to the text files
%fileWrite.writeLine("READ. READ CODE. CODE");

@endtsexample

@return True if file was successfully opened, false otherwise</desc>
</method>
<method>
<name>writeObject</name>
<desc>FileObject.writeObject(SimObject, object prepend)@hide</desc>
</method>
</class>
<class>
<name>FileObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>FileStreamObject</name>
<base>StreamObject</base>
<method>
<name>close</name>
<args>()</args>
<desc>@brief Close the file. You can no longer read or write to it unless you open it again.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample</desc>
</method>
<method>
<name>open</name>
<args>( string filename, string openMode )</args>
<desc>@brief Open a file for reading, writing, reading and writing, or appending

Using "Read" for the open mode allows you to parse the contents of file, but not making modifications. "Write" will create a new file if it does not exist, or erase the contents of an existing file when opened. Write also allows you to modify the contents of the file.

"ReadWrite" will provide the ability to parse data (read it in) and manipulate data (write it out) interchangeably. Keep in mind the stream can move during each operation. Finally, "WriteAppend" will open a file if it exists, but will not clear the contents. You can write new data starting  at the end of the files existing contents.

@param filename Name of file to open
@param openMode One of "Read", "Write", "ReadWrite" or "WriteAppend"

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Get the status and print it
%status = %fsObject.getStatus();
echo(%status);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return True if the file was successfully opened, false if something went wrong</desc>
</method>
</class>
<class>
<name>FileStreamObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>FlyingVehicle</name>
<base>Vehicle</base>
<method>
<name>useCreateHeight</name>
<args>( bool enabled )</args>
<desc>Set whether the vehicle should temporarily use the createHoverHeight specified in the datablock.
This can help avoid problems with spawning.
@param enabled true to use the datablock createHoverHeight, false otherwise</desc>
</method>
</class>
<class>
<name>FlyingVehicleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>FlyingVehicleData</name>
<base>VehicleData</base>
<field>
<name>autoAngularForce</name>
<desc>Corrective torque applied to level out the vehicle when moving at less than maxAutoSpeed.
The force is inversely proportional to vehicle speed.</desc>
</field>
<field>
<name>autoInputDamping</name>
<desc>Scale factor applied to steering input if speed is less than maxAutoSpeed.
Smaller values make steering less sensitive.</desc>
</field>
<field>
<name>autoLinearForce</name>
<desc>Corrective force applied to slow the vehicle when moving at less than maxAutoSpeed.
The force is inversely proportional to vehicle speed.</desc>
</field>
<field>
<name>backwardJetEmitter</name>
<desc>Emitter to generate particles for backward jet thrust.
Backward jet thrust particles are emitted from model nodes JetNozzleX and JetNozzleY.</desc>
</field>
<field>
<name>createHoverHeight</name>
<desc>The vehicle's height off the ground when useCreateHeight is active.
This can help avoid problems with spawning the vehicle.</desc>
</field>
<field>
<name>downJetEmitter</name>
<desc>Emitter to generate particles for downward jet thrust.
Downward jet thrust particles are emitted from model nodes JetNozzle2 and JetNozzle3.</desc>
</field>
<field>
<name>engineSound</name>
<desc>Looping engine sound.</desc>
</field>
<field>
<name>forwardJetEmitter</name>
<desc>Emitter to generate particles for forward jet thrust.
Forward jet thrust particles are emitted from model nodes JetNozzle0 and JetNozzle1.</desc>
</field>
<field>
<name>horizontalSurfaceForce</name>
<desc>Damping force in the opposite direction to sideways velocity.</desc>
</field>
<field>
<name>hoverHeight</name>
<desc>The vehicle's height off the ground when at rest.</desc>
</field>
<field>
<name>jetSound</name>
<desc>Looping sound to play while the vehicle is jetting.</desc>
</field>
<field>
<name>maneuveringForce</name>
<desc>Maximum X and Y (horizontal plane) maneuvering force.
The actual force applied depends on the current thrust.</desc>
</field>
<field>
<name>maxAutoSpeed</name>
<desc>Maximum speed for automatic vehicle control assistance.
Vehicles travelling at speeds above this value do not get control assitance.</desc>
</field>
<field>
<name>minTrailSpeed</name>
<desc>Minimum speed to start generating contrail particles.</desc>
</field>
<field>
<name>rollForce</name>
<desc>Damping torque against rolling maneuvers (rotation about the y-axis).
Acts to adjust roll to a stable position over time.</desc>
</field>
<field>
<name>rotationalDrag</name>
<desc>Rotational drag factor.
Slows vehicle rotation.</desc>
</field>
<field>
<name>steeringForce</name>
<desc>Maximum X and Z (sideways and vertical) steering force.
The actual force applied depends on the current steering input.</desc>
</field>
<field>
<name>steeringRollForce</name>
<desc>Roll force induced by sideways steering input value.</desc>
</field>
<field>
<name>trailEmitter</name>
<desc>Emitter to generate contrail particles from model nodes contrail0 - contrail3.</desc>
</field>
<field>
<name>verticalSurfaceForce</name>
<desc>Damping force in the opposite direction to vertical velocity.</desc>
</field>
<field>
<name>vertThrustMultiple</name>
<desc>Multiplier applied to the jetForce (defined in VehicleData) when thrusting vertically.</desc>
</field>
</class>
<class>
<name>FlyingVehicleDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForcedMaterialMeshMgr</name>
<base>RenderMeshMgr</base>
<field>
<name>Material</name>
<desc>Material used to draw all meshes in the render bin.</desc>
</field>
</class>
<class>
<name>ForcedMaterialMeshMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Forest</name>
<base>SceneObject</base>
<method>
<name>clear</name>
<args>()</args>
</method>
<method>
<name>dumpToTextFile</name>
<desc>dumpToTextFile( String fileName )</desc>
</method>
<method>
<name>isDirty</name>
<args>()</args>
</method>
<method>
<name>regenCells</name>
<args>()</args>
</method>
<method>
<name>saveDataFile</name>
<desc>saveDataFile( [path] )</desc>
</method>
<field>
<name>dataFile</name>
<desc>The source forest data file.</desc>
</field>
<field>
<name>lodReflectScalar</name>
<desc>Scalar applied to the farclip distance when Forest renders into a reflection.</desc>
</field>
</class>
<class>
<name>ForestBrush</name>
<base>SimGroup</base>
<method>
<name>containsItemData</name>
<args>( ForestItemData obj )</args>
</method>
</class>
<class>
<name>ForestBrushClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForestBrushElement</name>
<base>SimObject</base>
<field>
<name>elevationMax</name>
<desc>The max world space elevation this item will be placed.</desc>
</field>
<field>
<name>elevationMin</name>
<desc>The min world space elevation this item will be placed.</desc>
</field>
<field>
<name>ForestItemData</name>
<desc>The type of ForestItem this element holds placement parameters for.</desc>
</field>
<field>
<name>probability</name>
<desc>The probability that this element will be created during an editor brush stroke is the sum of all element probabilities in the brush divided by the probability of this element.</desc>
</field>
<field>
<name>rotationRange</name>
<desc>The max rotation in degrees that items will be placed.</desc>
</field>
<field>
<name>scaleExponent</name>
<desc>An exponent used to bias between the minimum and maximum random sizes.</desc>
</field>
<field>
<name>scaleMax</name>
<desc>The maximum random size of each item.</desc>
</field>
<field>
<name>scaleMin</name>
<desc>The minimum random size for each item.</desc>
</field>
<field>
<name>sinkMax</name>
<desc>Max variation in the sink radius.</desc>
</field>
<field>
<name>sinkMin</name>
<desc>Min variation in the sink radius.</desc>
</field>
<field>
<name>sinkRadius</name>
<desc>This is the radius used to calculate how much to sink the trunk at its base and is used to sink the tree into the ground when its on a slope.</desc>
</field>
<field>
<name>slopeMax</name>
<desc>The max surface slope in degrees this item will be placed on.</desc>
</field>
<field>
<name>slopeMin</name>
<desc>The min surface slope in degrees this item will be placed on.</desc>
</field>
</class>
<class>
<name>ForestBrushElementClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForestBrushTool</name>
<base>ForestTool</base>
<method>
<name>collectElements</name>
</method>
<field>
<name>hardness</name>
<desc>Brush Hardness</desc>
</field>
<field>
<name>mode</name>
<desc>ForestBrushMode mode</desc>
</field>
<field>
<name>pressure</name>
<desc>Brush Pressure</desc>
</field>
<field>
<name>size</name>
<desc>Brush Size</desc>
</field>
</class>
<class>
<name>ForestBrushToolClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForestClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForestEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteMeshSafe</name>
<args>( ForestItemData obj )</args>
</method>
<method>
<name>getActiveTool</name>
<args>()</args>
</method>
<method>
<name>isDirty</name>
</method>
<method>
<name>setActiveTool</name>
<args>( ForestTool tool )</args>
</method>
<method>
<name>updateActiveForest</name>
<args>()</args>
</method>
</class>
<class>
<name>ForestEditorCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForestItemData</name>
<base>SimDataBlock</base>
<field>
<name>branchAmp</name>
<desc>Amplitude of the effect on larger branches.</desc>
</field>
<field>
<name>collidable</name>
<desc>Can other objects or spacial queries hit items of this type.</desc>
</field>
<field>
<name>dampingCoefficient</name>
<desc>Coefficient used in calculating spring forces on the trunk. Causes oscillation and forces to decay faster over time.</desc>
</field>
<field>
<name>detailAmp</name>
<desc>Amplitude of the winds effect on leafs/fronds.</desc>
</field>
<field>
<name>detailFreq</name>
<desc>Frequency (speed) of the effect on leafs/fronds.</desc>
</field>
<field>
<name>mass</name>
<desc>Mass used in calculating spring forces on the trunk. Generally how springy a plant is.</desc>
</field>
<field>
<name>radius</name>
<desc>Radius used during placement to ensure items are not crowded.</desc>
</field>
<field>
<name>rigidity</name>
<desc>Rigidity used in calculating spring forces on the trunk. How much the plant resists the wind force</desc>
</field>
<field>
<name>shapeFile</name>
<desc>Shape file for this item type</desc>
</field>
<field>
<name>tightnessCoefficient</name>
<desc>Coefficient used in calculating spring forces on the trunk. How much the plant resists bending.</desc>
</field>
<field>
<name>trunkBendScale</name>
<desc>Overall bend amount of the tree trunk by wind and impacts.</desc>
</field>
<field>
<name>windScale</name>
<desc>Overall scale to the effect of wind.</desc>
</field>
</class>
<class>
<name>ForestItemDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForestSelectionTool</name>
<base>ForestTool</base>
<method>
<name>clearSelection</name>
</method>
<method>
<name>copySelection</name>
</method>
<method>
<name>cutSelection</name>
</method>
<method>
<name>deleteSelection</name>
</method>
<method>
<name>getSelectionCount</name>
</method>
<method>
<name>pasteSelection</name>
</method>
</class>
<class>
<name>ForestSelectionToolClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForestTool</name>
<base>SimObject</base>
</class>
<class>
<name>ForestToolClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ForestWindEmitter</name>
<base>SceneObject</base>
<method>
<name>attachToObject</name>
<args>( int objectID )</args>
<desc>@brief Mounts the wind emitter to another scene object

@param objectID Unique ID of the object wind emitter should attach to@tsexample
// Wind emitter previously created and named %windEmitter
// Going to attach it to the player, making him a walking wind storm
%windEmitter.attachToObject(%player);
@endtsexample</desc>
</method>
<field>
<name>gustFrequency</name>
<desc>The frequency of gusting in seconds.</desc>
</field>
<field>
<name>gustStrength</name>
<desc>The maximum strength of a gust.</desc>
</field>
<field>
<name>gustWobbleStrength</name>
<desc>The amount of random wobble added to gust and turbulence vectors.</desc>
</field>
<field>
<name>gustYawAngle</name>
<desc>The amount of degrees the wind direction can drift (both positive and negative).</desc>
</field>
<field>
<name>gustYawFrequency</name>
<desc>The frequency of wind yaw drift, in seconds.</desc>
</field>
<field>
<name>hasMount</name>
<desc>Determines if the emitter is mounted to another object.</desc>
</field>
<field>
<name>radialEmitter</name>
<desc>Determines if the emitter is a global direction or local radial emitter.</desc>
</field>
<field>
<name>radius</name>
<desc>The radius of the emitter for local radial emitters.</desc>
</field>
<field>
<name>strength</name>
<desc>The strength of the wind force.</desc>
</field>
<field>
<name>turbulenceFrequency</name>
<desc>The frequency of gust turbulence, in seconds.</desc>
</field>
<field>
<name>turbulenceStrength</name>
<desc>The strength of gust turbulence.</desc>
</field>
<field>
<name>windEnabled</name>
<desc>Determines if the emitter will be counted in wind calculations.</desc>
</field>
</class>
<class>
<name>ForestWindEmitterClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxCloth</name>
<base>GameBase</base>
<method>
<name>clearForces</name>
<desc>Clears explosion force.</desc>
</method>
<method>
<name>onExplosion</name>
<desc>Applies explosion force.</desc>
</method>
<method>
<name>setLifetime</name>
<desc>Sets lifetime in MS.</desc>
</method>
<field>
<name>ExternAccel</name>
<desc>Point3F ExternAccel</desc>
</field>
<field>
<name>height</name>
<desc>float height</desc>
</field>
<field>
<name>HW</name>
<desc>bool HW</desc>
</field>
<field>
<name>LockBottom</name>
<desc>bool LockBottom</desc>
</field>
<field>
<name>LockLeft</name>
<desc>bool LockLeft</desc>
</field>
<field>
<name>LockLowerLeft</name>
<desc>bool LockLowerLeft</desc>
</field>
<field>
<name>LockLowerRight</name>
<desc>bool LockLowerRight</desc>
</field>
<field>
<name>LockRight</name>
<desc>bool LockRight</desc>
</field>
<field>
<name>LockTop</name>
<desc>bool LockTop</desc>
</field>
<field>
<name>LockUpperLeft</name>
<desc>bool LockUpperLeft</desc>
</field>
<field>
<name>LockUpperRight</name>
<desc>bool LockUpperRight</desc>
</field>
<field>
<name>NumParticlesX</name>
<desc>int NumParticlesX</desc>
</field>
<field>
<name>NumParticlesY</name>
<desc>int NumParticlesY</desc>
</field>
<field>
<name>Tube</name>
<desc>bool Tube</desc>
</field>
<field>
<name>Width</name>
<desc>float Width</desc>
</field>
<field>
<name>WindCycle</name>
<desc>int WindCycle</desc>
</field>
</class>
<class>
<name>fxClothClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxClothData</name>
<base>GameBaseData</base>
<field>
<name>AttachmentResponseCoefficient</name>
<desc>float AttachmentResponseCoefficient</desc>
</field>
<field>
<name>BendingStiffness</name>
<desc>float BendingStiffness</desc>
</field>
<field>
<name>CollisionResponseCoefficient</name>
<desc>float CollisionResponseCoefficient</desc>
</field>
<field>
<name>dampingCoefficient</name>
<desc>float dampingCoefficient</desc>
</field>
<field>
<name>density</name>
<desc>float density</desc>
</field>
<field>
<name>ExternAccel</name>
<desc>Point3F ExternAccel</desc>
</field>
<field>
<name>FrictionCoefficient</name>
<desc>float FrictionCoefficient</desc>
</field>
<field>
<name>PressureCoefficient</name>
<desc>float PressureCoefficient</desc>
</field>
<field>
<name>SolverIterations</name>
<desc>int SolverIterations</desc>
</field>
<field>
<name>StretchingStiffness</name>
<desc>float StretchingStiffness</desc>
</field>
<field>
<name>TearFactor</name>
<desc>float TearFactor</desc>
</field>
<field>
<name>Thickness</name>
<desc>float Thickness</desc>
</field>
</class>
<class>
<name>fxClothDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxFlexBody</name>
<base>ShapeBase</base>
<method>
<name>act</name>
</method>
<method>
<name>addMattersNode</name>
<desc>addMattersNode(S32 seqnum,S32 nodenum)</desc>
</method>
<method>
<name>addPlaylistSeq</name>
<desc>addPlaylistSeq()</desc>
</method>
<method>
<name>addUltraframe</name>
<desc>addUltraframe(S32 seq, S32 frame, S32 node, S32 type, S32 target, Point3F value)</desc>
</method>
<method>
<name>addUltraframeNoInsert</name>
<desc>addUltraframeNoInsert(S32 seq, S32 frame, S32 node, S32 type, S32 target, Point3F value)</desc>
</method>
<method>
<name>addUltraframeSet</name>
<desc>addUltraframeSet(S32 seq)</desc>
</method>
<method>
<name>addUltraframeSingle</name>
<desc>addUltraframeSingle(S32 seq, S32 frame, S32 node, S32 type, Point3F value)</desc>
</method>
<method>
<name>addWeapon</name>
<desc>addWeapon(fxRigidBody weaponID,S32 mount_slot</desc>
</method>
<method>
<name>addWeapon2</name>
<desc>addWeapon2(fxRigidBody weaponID,S32 mount_slot</desc>
</method>
<method>
<name>adjustBaseNodePosPermanent</name>
<desc>adjustBaseNodePosPermanent(seq,pos)</desc>
</method>
<method>
<name>adjustBaseNodePosRegion</name>
<desc>adjustBaseNodePosRegion(seq,pos,start,stop)</desc>
</method>
<method>
<name>adjustNodeRotPermanent</name>
<desc>adjustNodeRotPermanent(U32 node,EulerF &amp;rot)</desc>
</method>
<method>
<name>adjustNodeRotRegion</name>
<desc>adjustNodeRotRegion(seq,node,rot,start,stop)</desc>
</method>
<method>
<name>attackPosition</name>
<desc>attackPosition(Point3F pos,String action)</desc>
</method>
<method>
<name>backupSequenceData</name>
<desc>backupSequenceData()</desc>
</method>
<method>
<name>bvh</name>
<args>(bool importGround,char bvhname,char bvhProfile)</args>
</method>
<method>
<name>clean</name>
<args>(char filename)</args>
</method>
<method>
<name>cleanDir</name>
<desc>cleanDir(char dir)</desc>
</method>
<method>
<name>cleanupBvh</name>
<args>(char filename)</args>
</method>
<method>
<name>clearBodypart</name>
<desc>clearBodypart(U32 i)</desc>
</method>
<method>
<name>clearChainParts</name>
<desc>clearChainParts</desc>
</method>
<method>
<name>clearKinematic</name>
</method>
<method>
<name>clearNoGravity</name>
</method>
<method>
<name>clearPlaylist</name>
<desc>dropPlaylist</desc>
</method>
<method>
<name>clearUltraframe</name>
<desc>clearUltraframe(S32 seq, S32 frame, S32 node)</desc>
</method>
<method>
<name>convertAckToKork</name>
<desc>convertAckToKork(S32 ackID,S32 seq)</desc>
</method>
<method>
<name>convertKorkDefault</name>
<desc>convertKorkDefault(S32 ackID)</desc>
</method>
<method>
<name>cropSequence</name>
<desc>cropSequence(U32 seq, F32 start, F32 stop, char name)</desc>
</method>
<method>
<name>doMatrixFix</name>
<desc>doMatrixFix(seq,eulerF,eulerF)</desc>
</method>
<method>
<name>dropAllSequences</name>
<desc>dropAllSequences();</desc>
</method>
<method>
<name>dropMattersNode</name>
<desc>dropMattersNode(S32 seqnum,S32 nodenum)</desc>
</method>
<method>
<name>dropPlaylistSeq</name>
<desc>dropPlaylistSeq()</desc>
</method>
<method>
<name>dropSeq</name>
<desc>dropSeq(char sequence)</desc>
</method>
<method>
<name>dropSeqByName</name>
<desc>dropSequence(U32 sequence)</desc>
</method>
<method>
<name>dropSeqByNum</name>
<desc>dropSequence(S32 sequence)</desc>
</method>
<method>
<name>dropUltraframe</name>
<desc>dropUltraframe(S32 seq, S32 frame, S32 node)</desc>
</method>
<method>
<name>findStop</name>
<desc>findStop(U32 slot, F32 start)</desc>
</method>
<method>
<name>finishFollowEvent</name>
<desc>finishFollowEvent();</desc>
</method>
<method>
<name>fixCfg</name>
<desc>fixCfg(cfg_filename,bvh_filename)</desc>
</method>
<method>
<name>getActionUser</name>
</method>
<method>
<name>getActorId</name>
<desc>getActorId()</desc>
</method>
<method>
<name>getActorName</name>
<desc>getActorName()</desc>
</method>
<method>
<name>getBeenHitTick</name>
<desc>getBeenHitTick</desc>
</method>
<method>
<name>getBodyPart</name>
<desc>getbodypart(const char *) - returns flexbodypart ID for bodypart</desc>
</method>
<method>
<name>getBodypartKinematic</name>
<desc>getBodypartKinematic(S32 partID)</desc>
</method>
<method>
<name>getBodypartName</name>
<desc>getBodypartName(S32 partID)</desc>
</method>
<method>
<name>getBodypartParent</name>
<desc>getBodypartParent(S32 partID)</desc>
</method>
<method>
<name>getBodypartPos</name>
<desc>getBodypartPos(S32 partID)</desc>
</method>
<method>
<name>getCurrentTick</name>
<desc>getCurrentTick</desc>
</method>
<method>
<name>getCurrSeqNum</name>
<desc>getSeqNum()</desc>
</method>
<method>
<name>getFlexBodyName</name>
</method>
<method>
<name>getKeyFrame</name>
<desc>getKeyFrame(S32 slot)</desc>
</method>
<method>
<name>getKinematic</name>
</method>
<method>
<name>getLinearVelocity</name>
<desc>getLinearVelocity</desc>
</method>
<method>
<name>getMattersNodeIndex</name>
<desc>getMattersNodeIndex(S32 seqnum,S32 nodenum)</desc>
</method>
<method>
<name>getModelName</name>
</method>
<method>
<name>getMoveThreshold</name>
<desc>getMoveThreshold()</desc>
</method>
<method>
<name>getName</name>
<desc>getName()</desc>
</method>
<method>
<name>getNodeFrameEuler</name>
<desc>getNodeFrameEuler(seq,frame,node)</desc>
</method>
<method>
<name>getNodeFrameQuat</name>
<desc>getNodeFrameQuat(seq,frame,node)</desc>
</method>
<method>
<name>getNodeMattersIndex</name>
<desc>getNodeMattersIndex(S32 seqnum,S32 nodenum)</desc>
</method>
<method>
<name>getNodeName</name>
<desc>getNodeName(U32 index)</desc>
</method>
<method>
<name>getNodeNum</name>
<desc>getNodeNum(const char *name)</desc>
</method>
<method>
<name>getNodeParent</name>
<desc>getNodeName(S32)</desc>
</method>
<method>
<name>getNumBodyparts</name>
<desc>returns bodypart count</desc>
</method>
<method>
<name>getNumMattersNodes</name>
<desc>getNumMattersNodes(S32 seqnum)</desc>
</method>
<method>
<name>getNumNodes</name>
<desc>getNumNodes()</desc>
</method>
<method>
<name>getNumPlaylistSeqs</name>
<desc>getNumPlaylistSeqs()</desc>
</method>
<method>
<name>getNumSeqs</name>
<desc>getNumSeqs()</desc>
</method>
<method>
<name>getNumUltraframes</name>
<desc>getNumUltraframes(S32 seq);</desc>
</method>
<method>
<name>getPath</name>
</method>
<method>
<name>getPersonaId</name>
<desc>getPersonaId()</desc>
</method>
<method>
<name>getPersonaName</name>
<desc>getPersonaName()</desc>
</method>
<method>
<name>getPhysActive</name>
<desc>getPhysActive()</desc>
</method>
<method>
<name>getPhysicsDamage</name>
<desc>getPhysicsDamage</desc>
</method>
<method>
<name>getPlaylistId</name>
<desc>getPlaylistId()</desc>
</method>
<method>
<name>getPlaylistName</name>
<desc>getPlaylistName()</desc>
</method>
<method>
<name>getPlaylistNum</name>
<desc>getPlaylistNum(S32 seqnum)</desc>
</method>
<method>
<name>getPlaylistRepeats</name>
<desc>getPlaylistRepeats()</desc>
</method>
<method>
<name>getPlaylistSeq</name>
<desc>getPlaylistSeq()</desc>
</method>
<method>
<name>getPlaylistSpeed</name>
<desc>getPlaylistSpeed()</desc>
</method>
<method>
<name>getSampleRate</name>
<desc>getSampleRate()</desc>
</method>
<method>
<name>getSeqBlend</name>
<desc>getSeqBlend(U32 index)</desc>
</method>
<method>
<name>getSeqCyclic</name>
<desc>getSeqCyclic(U32 index)</desc>
</method>
<method>
<name>getSeqDuration</name>
<desc>getSeqDuration(U32 index)</desc>
</method>
<method>
<name>getSeqFilename</name>
<desc>getSeqFilename(const char *name)</desc>
</method>
<method>
<name>getSeqName</name>
<desc>getSeqName(U32 index)</desc>
</method>
<method>
<name>getSeqNum</name>
<desc>getSeqNum(const char *name)</desc>
</method>
<method>
<name>getSeqNumGroundFrames</name>
<desc>getSeqNumGroundframes(U32 index)</desc>
</method>
<method>
<name>getSeqNumKeyframes</name>
<desc>getSeqNumKeyframes(U32 index)</desc>
</method>
<method>
<name>getSeqNumTriggers</name>
<desc>getSeqNumTriggers(U32 index)</desc>
</method>
<method>
<name>getSeqPos</name>
<desc>getSeqPos(S32 slot)</desc>
</method>
<method>
<name>getShapeConstructor</name>
<desc>getShapeConstructor()</desc>
</method>
<method>
<name>getShapeSize</name>
<desc>getShapeSize()</desc>
</method>
<method>
<name>getSkeletonId</name>
<desc>getSkeletonId()</desc>
</method>
<method>
<name>getSkeletonName</name>
<desc>getSkeletonName()</desc>
</method>
<method>
<name>getSleepThreshold</name>
<desc>getSleepThreshold()</desc>
</method>
<method>
<name>getSubType</name>
<desc>S32 getSubType()</desc>
</method>
<method>
<name>getTarget</name>
<desc>getTarget();</desc>
</method>
<method>
<name>getTargetPosition</name>
<desc>getTargetPosition()</desc>
</method>
<method>
<name>getThreadTimescale</name>
<desc>getThreadTimescale(S32 slot)</desc>
</method>
<method>
<name>getUltraframe</name>
<desc>getUltraframe(S32 seq, S32 frame, S32 node, S32 type)</desc>
</method>
<method>
<name>giveDetails</name>
<args>(char filename)</args>
</method>
<method>
<name>grabSeqByName</name>
<desc>grabSequence(other,char sequence,char cfg)</desc>
</method>
<method>
<name>grabSeqByNum</name>
<desc>grabSeqNum(other,U32 sequence,char cfg)</desc>
</method>
<method>
<name>groundCaptureDir</name>
<desc>groundCaptureDir(char *inDir, char *outDir)</desc>
</method>
<method>
<name>groundCaptureSeq</name>
<desc>groundCaptureSeq(U32 seq)</desc>
</method>
<method>
<name>hasRagdollBodyparts</name>
<desc>hasRagdollBodyparts</desc>
</method>
<method>
<name>hasUltraframe</name>
<desc>hasUltraframe(S32 seq, S32 frame, S32 node, S32 type)</desc>
</method>
<method>
<name>hasUltraframeSets</name>
<desc>hasUltraframeSets()</desc>
</method>
<method>
<name>hasUltraframesForNode</name>
<desc>hasUltraframesForNode(seq,node)</desc>
</method>
<method>
<name>hasUltraframesForType</name>
<desc>hasUltraframesForType(seq,type)</desc>
</method>
<method>
<name>headCheck</name>
</method>
<method>
<name>headClear</name>
</method>
<method>
<name>headUp</name>
</method>
<method>
<name>importBvh</name>
<args>(bool importGround,char bvhname,char bvhProfile)</args>
</method>
<method>
<name>importDir</name>
<desc>importDir(bool importGround,char bvhDir,char dsqDir)</desc>
</method>
<method>
<name>info</name>
<desc>info()</desc>
</method>
<method>
<name>isEcstasyFirstTime</name>
<desc>isEcstasyFirstTime()</desc>
</method>
<method>
<name>loadAction</name>
<desc>loadAction(char *name)</desc>
</method>
<method>
<name>loadBest</name>
<args>(char filename)</args>
</method>
<method>
<name>loadDsq</name>
<args>(char filename)</args>
</method>
<method>
<name>loadKeyframeSets</name>
<desc>loadKeyframeSets(S32 scene_id);</desc>
</method>
<method>
<name>loadPlaylist</name>
<desc>loadPlaylist(S32 scene_id)</desc>
</method>
<method>
<name>loadPlaylistById</name>
<desc>loadPlaylist(S32 playlist_id)</desc>
</method>
<method>
<name>loadUltraframes</name>
<desc>loadUltraframes(char *filename)</desc>
</method>
<method>
<name>makeSequence</name>
<desc>makeSequence(char seqName)</desc>
</method>
<method>
<name>motorize</name>
<desc>activates all joint motors</desc>
</method>
<method>
<name>moveToPosition</name>
<desc>moveToPosition(Point3F pos,String action)</desc>
</method>
<method>
<name>null</name>
<args>(char filename)</args>
</method>
<method>
<name>nullBvh</name>
<args>(char filename)</args>
</method>
<method>
<name>onCollision</name>
<desc>calls onCollision</desc>
</method>
<method>
<name>orientToPosition</name>
<desc>orientToPosition(Point3F pos)</desc>
</method>
<method>
<name>pauseThreads</name>
<desc>pauseThreads()</desc>
</method>
<method>
<name>play</name>
<args>(char seqname)</args>
</method>
<method>
<name>playAtPos</name>
<args>(char filename)</args>
</method>
<method>
<name>playThread</name>
<args>(int slot, string sequenceName)</args>
</method>
<method>
<name>printPos</name>
</method>
<method>
<name>reloadSequences</name>
<desc>reloadSequences();</desc>
</method>
<method>
<name>removeBodyparts</name>
<desc>removeBodyparts()</desc>
</method>
<method>
<name>renameSequence</name>
<desc>renameSequence(char *old_name, char *new_name);</desc>
</method>
<method>
<name>resetPosition</name>
<desc>reset position</desc>
</method>
<method>
<name>resetSequence</name>
<args>(S32 seq)</args>
</method>
<method>
<name>runPlaylist</name>
<desc>runPlaylist()</desc>
</method>
<method>
<name>saveAll</name>
</method>
<method>
<name>saveBest</name>
<args>(char filename)</args>
</method>
<method>
<name>saveBvh</name>
<args>(char sequence, char outputname, char outputformat)</args>
</method>
<method>
<name>saveBvhDir</name>
<desc>saveBvhDir(char *inDir, char *outDir)</desc>
</method>
<method>
<name>saveOut</name>
<args>(char filename)</args>
</method>
<method>
<name>savePlaylist</name>
<desc>savePlaylist(filename)</desc>
</method>
<method>
<name>savePlaylistSeq</name>
<desc>savePlaylistSeq()</desc>
</method>
<method>
<name>saveSequence</name>
<args>(char filename,char seqname)</args>
</method>
<method>
<name>saveShapeConstructor</name>
<desc>saveShapeConstructor(const char *filename)</desc>
</method>
<method>
<name>saveUltraframe</name>
<desc>saveUltraframe(S32 seq, S32 frame, S32 node, S32 type, Point3F value)</desc>
</method>
<method>
<name>saveUltraframes</name>
<desc>saveUltraframes(S32 seq,char *filename)</desc>
</method>
<method>
<name>setActorName</name>
<desc>setActorName(const char*)</desc>
</method>
<method>
<name>setAnimationFreeze</name>
<desc>setAnimationFreeze(bool)</desc>
</method>
<method>
<name>setBaseNodePosPermanent</name>
<desc>setBaseNodePosPermanent(seq,pos)</desc>
</method>
<method>
<name>setBaseNodePosRegion</name>
<desc>setBaseNodePosRegion(seq,pos,start,stop)</desc>
</method>
<method>
<name>setBodypart</name>
<desc>setBodypart(U32 i)</desc>
</method>
<method>
<name>setBodypartDelayForces</name>
<desc>setBodyPartDelayForces(Point3F force)</desc>
</method>
<method>
<name>setBodypartForce</name>
<args>(index i, Point3F force)</args>
</method>
<method>
<name>setBodypartForces</name>
<desc>applies explosion forces to bodyparts.</desc>
</method>
<method>
<name>setBodypartGlobalForce</name>
<desc>setBodypartGlobalForce(index i, Point3F force)</desc>
</method>
<method>
<name>setBodypartGlobalTorque</name>
<args>(index i, Point3F torque)</args>
</method>
<method>
<name>setBodypartImpulseForce</name>
<args>(index i, Point3F force)</args>
</method>
<method>
<name>setBodypartImpulseTorque</name>
<args>(index i, Point3F torque)</args>
</method>
<method>
<name>setBodypartMotorSpring</name>
<args>(index i, Point3F target,F32 force)</args>
</method>
<method>
<name>setBodypartMotorTarget</name>
<args>(index i, Point3F target)</args>
</method>
<method>
<name>setBodypartTorque</name>
<args>(index i, Point3F torque)</args>
</method>
<method>
<name>setInitialOrientation</name>
<desc>setInitialOrientation(rot)</desc>
</method>
<method>
<name>setInitialPosition</name>
<desc>setInitialPosition(pos)</desc>
</method>
<method>
<name>setIsRecording</name>
<desc>setIsRecording(bool)</desc>
</method>
<method>
<name>setIsRendering</name>
<desc>setIsRendering(bool)</desc>
</method>
<method>
<name>setIsReturnToZero</name>
<desc>setIsReturnToZero(bool)</desc>
</method>
<method>
<name>setIsStriking</name>
<args>(bool isStriking)</args>
</method>
<method>
<name>setKinematic</name>
</method>
<method>
<name>setLifetime</name>
<desc>Sets lifetime in MS</desc>
</method>
<method>
<name>setMaskBit</name>
<desc>setMaskBit)</desc>
</method>
<method>
<name>setMoveSequence</name>
<desc>setMoveSequence(String action)</desc>
</method>
<method>
<name>setMoveThreshold</name>
<desc>setMoveThreshold(F32 value)</desc>
</method>
<method>
<name>setNodeFrameEuler</name>
<desc>setNodeFrameEuler(seq,frame,node,euler)</desc>
</method>
<method>
<name>setNodeFrameQuat</name>
<desc>setNodeFrameQuat(seq,frame,node,quat)</desc>
</method>
<method>
<name>setNodeRotPermanent</name>
<desc>setNodeRotPermanent(U32 node,EulerF &amp;rot)</desc>
</method>
<method>
<name>setNodeRotRegion</name>
<desc>setNodeRotRegion(seq,node,rot,start,stop)</desc>
</method>
<method>
<name>setNoGravity</name>
</method>
<method>
<name>setPersona</name>
<desc>setPersona()</desc>
</method>
<method>
<name>setPersonaName</name>
<desc>setPersonaName()</desc>
</method>
<method>
<name>setPhysActive</name>
<desc>setPhysActive(bool)</desc>
</method>
<method>
<name>setPhysicsDamage</name>
<desc>setPhysicsDamage(F32 damage)</desc>
</method>
<method>
<name>setPlaylist</name>
<desc>setPlaylist()</desc>
</method>
<method>
<name>setPlaylistName</name>
<desc>setPlaylistName()</desc>
</method>
<method>
<name>setPosition</name>
<desc>setPosition(Point3F pos);</desc>
</method>
<method>
<name>setSampleRate</name>
<desc>setSampleRate(S32 rate)</desc>
</method>
<method>
<name>setSeqBlend</name>
<desc>setSeqBlend(U32 index, bool blend)</desc>
</method>
<method>
<name>setSeqCyclic</name>
<desc>setSeqCyclic(U32 index, bool cyclic)</desc>
</method>
<method>
<name>setSeqDuration</name>
<desc>getSeqDuration(U32 index, F32 duration)</desc>
</method>
<method>
<name>setSequenceFrames</name>
<desc>setSequenceFrames(U32 seq, U32 frames)</desc>
</method>
<method>
<name>setShapeSize</name>
<desc>setShapeSize(F32 size)</desc>
</method>
<method>
<name>setSkeletonId</name>
<desc>setSkeletonId(U32)</desc>
</method>
<method>
<name>setSkeletonName</name>
<desc>setSkeletonName(const char*)</desc>
</method>
<method>
<name>setSleepThreshold</name>
<desc>setSleepThreshold(F32)</desc>
</method>
<method>
<name>setTarget</name>
<desc>setTarget(shapebase_id);</desc>
</method>
<method>
<name>setTweakerDone</name>
<desc>setTweakerDone();</desc>
</method>
<method>
<name>setWeapon2MotorTarget</name>
<desc>setWeapon2MotorTarget(Point3F rot)</desc>
</method>
<method>
<name>setWeapon2TriggerMotorTarget</name>
<desc>setWeapon2TriggerMotorTarget(Point3F rot)</desc>
</method>
<method>
<name>setWeaponMotorTarget</name>
<desc>setWeaponMotorTarget(Point3F rot)</desc>
</method>
<method>
<name>setWeaponTriggerMotorTarget</name>
<desc>setWeaponTriggerMotorTarget(Point3F rot)</desc>
</method>
<method>
<name>setWeaponTriggerRotAdjA</name>
<desc>setWeaponTriggerRotAdjA(Point3F)</desc>
</method>
<method>
<name>setWeaponTriggerRotAdjB</name>
<desc>setWeaponTriggerRotAdjB(Point3F)</desc>
</method>
<method>
<name>showChainParts</name>
<desc>showChainParts</desc>
</method>
<method>
<name>showDefRots</name>
<desc>showDefRots()</desc>
</method>
<method>
<name>showGroundRots</name>
<desc>showGroundRots(seq)</desc>
</method>
<method>
<name>showGroundTrans</name>
<desc>showGroundTrans(seq)</desc>
</method>
<method>
<name>showKinematicNodes</name>
<desc>showKinematicNodes</desc>
</method>
<method>
<name>showNodeRots</name>
<desc>showNodeRots(seq)</desc>
</method>
<method>
<name>showNodes</name>
</method>
<method>
<name>showNodeTrans</name>
<desc>showNodeTrans(seq)</desc>
</method>
<method>
<name>showNodeTransform</name>
<desc>showNodeTransform(S32 nodeIndex)</desc>
</method>
<method>
<name>showNodeTransforms</name>
<desc>showNodeTransforms()</desc>
</method>
<method>
<name>showSeq</name>
</method>
<method>
<name>splay</name>
</method>
<method>
<name>startAnimating</name>
<args>(S32 sequence)</args>
</method>
<method>
<name>startAnimatingAtPos</name>
<args>(char sequence,F32 pos)</args>
</method>
<method>
<name>startThinking</name>
</method>
<method>
<name>stopAnimating</name>
</method>
<method>
<name>stopThinking</name>
</method>
<method>
<name>threadInfo</name>
<desc>threadInfo(S32 index</desc>
</method>
<method>
<name>toggleIsRecording</name>
<desc>toggleIsRecording(bool)</desc>
</method>
<method>
<name>write</name>
<args>(char filename)</args>
</method>
<method>
<name>zeroForces</name>
</method>
<method>
<name>zeroHeight</name>
<desc>zeroHeight</desc>
</method>
<field>
<name>ActorName</name>
<desc>string ActorName</desc>
</field>
<field>
<name>InitialVelocity</name>
<desc>Point3F InitialVelocity</desc>
</field>
<field>
<name>IsClientOnly</name>
<desc>bool IsClientOnly</desc>
</field>
<field>
<name>IsNoGravity</name>
<desc>bool IsNoGravity</desc>
</field>
<field>
<name>IsRendering</name>
<desc>bool IsRendering</desc>
</field>
<field>
<name>IsReturnToZero</name>
<desc>bool IsReturnToZero</desc>
</field>
<field>
<name>KeyframesFile</name>
<desc>filename KeyframesFile</desc>
</field>
<field>
<name>Persona</name>
<desc>string Persona</desc>
</field>
<field>
<name>PlaylistDelay</name>
<desc>int PlaylistDelay</desc>
</field>
<field>
<name>PlaylistFile</name>
<desc>filename PlaylistFile</desc>
</field>
<field>
<name>SkeletonName</name>
<desc>string SkeletonName</desc>
</field>
<field>
<name>SpawnScript</name>
<desc>string SpawnScript</desc>
</field>
</class>
<class>
<name>fxFlexBodyClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxFlexBodyData</name>
<base>ShapeBaseData</base>
<field>
<name>ActionUserData</name>
<desc>SimObject ActionUserData</desc>
</field>
<field>
<name>BodyNode</name>
<desc>string BodyNode</desc>
</field>
<field>
<name>DynamicFriction</name>
<desc>float DynamicFriction</desc>
</field>
<field>
<name>GA</name>
<desc>bool GA</desc>
</field>
<field>
<name>HeadNode</name>
<desc>string HeadNode</desc>
</field>
<field>
<name>HW</name>
<desc>bool HW</desc>
</field>
<field>
<name>LeftBackNode</name>
<desc>string LeftBackNode</desc>
</field>
<field>
<name>LeftFrontNode</name>
<desc>string LeftFrontNode</desc>
</field>
<field>
<name>Lifetime</name>
<desc>int Lifetime</desc>
</field>
<field>
<name>MeshExcludes</name>
<desc>string MeshExcludes</desc>
</field>
<field>
<name>MeshObject</name>
<desc>string MeshObject</desc>
</field>
<field>
<name>myDensity</name>
<desc>float myDensity</desc>
</field>
<field>
<name>NeckNode</name>
<desc>string NeckNode</desc>
</field>
<field>
<name>RelaxType</name>
<desc>int RelaxType</desc>
</field>
<field>
<name>Restitution</name>
<desc>float Restitution</desc>
</field>
<field>
<name>RightBackNode</name>
<desc>string RightBackNode</desc>
</field>
<field>
<name>RightFrontNode</name>
<desc>string RightFrontNode</desc>
</field>
<field>
<name>SDK</name>
<desc>bool SDK</desc>
</field>
<field>
<name>SkeletonName</name>
<desc>string SkeletonName</desc>
</field>
<field>
<name>SleepThreshold</name>
<desc>float SleepThreshold</desc>
</field>
<field>
<name>StaticFriction</name>
<desc>float StaticFriction</desc>
</field>
<field>
<name>TriggerDimensions</name>
<desc>Point3F TriggerDimensions</desc>
</field>
<field>
<name>TriggerOffset</name>
<desc>Point3F TriggerOffset</desc>
</field>
<field>
<name>TriggerOrientation</name>
<desc>Point3F TriggerOrientation</desc>
</field>
<field>
<name>TriggerShapeType</name>
<desc>physShapeType TriggerShapeType</desc>
</field>
<field>
<name>upAxis</name>
<desc>Override the &lt;up_axis&gt; element in the COLLADA (.dae) file. No effect for DTS files.
Set to one of the following values:
&lt;dl&gt;&lt;dt&gt;X_AXIS&lt;/dt&gt;&lt;dd&gt;Positive X points up. Model will be rotated into Torque's coordinate system (Z up).&lt;/dd&gt;&lt;dt&gt;Y_AXIS&lt;/dt&gt;&lt;dd&gt;Positive Y points up. Model will be rotated into Torque's coordinate system (Z up).&lt;/dd&gt;&lt;dt&gt;Z_AXIS&lt;/dt&gt;&lt;dd&gt;Positive Z points up. No rotation will be applied to the model.&lt;/dd&gt;&lt;dt&gt;DEFAULT&lt;/dt&gt;&lt;dd&gt;The default value. Use the value in the .dae file (defaults to Z_AXIS if the &lt;up_axis&gt; element is not present).&lt;/dd&gt;&lt;/dl&gt;</desc>
</field>
</class>
<class>
<name>fxFlexBodyDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxFlexBodyPart</name>
<base>GameBase</base>
<method>
<name>getSubType</name>
<desc>S32 getSubType()</desc>
</method>
<method>
<name>onCollision</name>
<desc>calls onCollision.</desc>
</method>
<method>
<name>onDelayCollision</name>
<desc>onCollision, one tick later.</desc>
</method>
<method>
<name>setForce</name>
<desc>Sets local force.</desc>
</method>
<method>
<name>setGlobalDelayForce</name>
<desc>Sets local force.</desc>
</method>
<method>
<name>setGlobalForce</name>
<desc>Sets local force.</desc>
</method>
<method>
<name>setGlobalTorque</name>
<args>(Point3F kTorque)</args>
</method>
<method>
<name>setTorque</name>
<args>(Point3F kTorque)</args>
</method>
</class>
<class>
<name>fxFlexBodyPartClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxFlexBodyPartData</name>
<base>GameBaseData</base>
<field>
<name>BaseNode</name>
<desc>string BaseNode</desc>
</field>
<field>
<name>BodypartChain</name>
<desc>physChainType BodypartChain</desc>
</field>
<field>
<name>BoundsMax</name>
<desc>Point3F BoundsMax</desc>
</field>
<field>
<name>BoundsMin</name>
<desc>Point3F BoundsMin</desc>
</field>
<field>
<name>ChildNode</name>
<desc>string ChildNode</desc>
</field>
<field>
<name>ChildVerts</name>
<desc>int ChildVerts</desc>
</field>
<field>
<name>DamageMultiplier</name>
<desc>float DamageMultiplier</desc>
</field>
<field>
<name>density</name>
<desc>float density</desc>
</field>
<field>
<name>Dimensions</name>
<desc>Point3F Dimensions</desc>
</field>
<field>
<name>DynamicFriction</name>
<desc>float DynamicFriction</desc>
</field>
<field>
<name>FarVerts</name>
<desc>int FarVerts</desc>
</field>
<field>
<name>FlexBodyData</name>
<desc>fxFlexBodyData FlexBodyData</desc>
</field>
<field>
<name>ForceMax</name>
<desc>Point3F ForceMax</desc>
</field>
<field>
<name>ForceMin</name>
<desc>Point3F ForceMin</desc>
</field>
<field>
<name>ForceMultiplier</name>
<desc>float ForceMultiplier</desc>
</field>
<field>
<name>ForwardForce</name>
<desc>float ForwardForce</desc>
</field>
<field>
<name>InflictMultiplier</name>
<desc>float InflictMultiplier</desc>
</field>
<field>
<name>IsInflictor</name>
<desc>bool IsInflictor</desc>
</field>
<field>
<name>IsKinematic</name>
<desc>bool IsKinematic</desc>
</field>
<field>
<name>JointData</name>
<desc>fxJointData JointData</desc>
</field>
<field>
<name>MeshObject</name>
<desc>string MeshObject</desc>
</field>
<field>
<name>offset</name>
<desc>Point3F offset</desc>
</field>
<field>
<name>orientation</name>
<desc>Point3F orientation</desc>
</field>
<field>
<name>ParentNode</name>
<desc>string ParentNode</desc>
</field>
<field>
<name>ParentVerts</name>
<desc>int ParentVerts</desc>
</field>
<field>
<name>PlayerData</name>
<desc>SimObject PlayerData</desc>
</field>
<field>
<name>RagdollThreshold</name>
<desc>float RagdollThreshold</desc>
</field>
<field>
<name>Restitution</name>
<desc>float Restitution</desc>
</field>
<field>
<name>ShapeType</name>
<desc>physShapeType ShapeType</desc>
</field>
<field>
<name>StaticFriction</name>
<desc>float StaticFriction</desc>
</field>
<field>
<name>TorqueMax</name>
<desc>Point3F TorqueMax</desc>
</field>
<field>
<name>TorqueMin</name>
<desc>Point3F TorqueMin</desc>
</field>
<field>
<name>TriggerActorOffset</name>
<desc>Point3F TriggerActorOffset</desc>
</field>
<field>
<name>TriggerDimensions</name>
<desc>Point3F TriggerDimensions</desc>
</field>
<field>
<name>TriggerOffset</name>
<desc>Point3F TriggerOffset</desc>
</field>
<field>
<name>TriggerOrientation</name>
<desc>Point3F TriggerOrientation</desc>
</field>
<field>
<name>TriggerShapeType</name>
<desc>physShapeType TriggerShapeType</desc>
</field>
<field>
<name>WeightThreshold</name>
<desc>float WeightThreshold</desc>
</field>
</class>
<class>
<name>fxFlexBodyPartDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxFoliageReplicator</name>
<base>SceneObject</base>
<field>
<name>AllowedTerrainSlope</name>
<desc>Maximum surface angle allowed for foliage instances.</desc>
</field>
<field>
<name>AllowOnInteriors</name>
<desc>Foliage will be placed on InteriorInstances when set.</desc>
</field>
<field>
<name>AllowOnStatics</name>
<desc>Foliage will be placed on Static shapes when set.</desc>
</field>
<field>
<name>AllowOnTerrain</name>
<desc>Foliage will be placed on terrain when set.</desc>
</field>
<field>
<name>AllowOnWater</name>
<desc>Foliage will be placed on/under water when set.</desc>
</field>
<field>
<name>AllowWaterSurface</name>
<desc>Foliage will be placed on water when set. Requires AllowOnWater.</desc>
</field>
<field>
<name>AlphaCutoff</name>
<desc>Minimum alpha value allowed on foliage instances.</desc>
</field>
<field>
<name>CullResolution</name>
<desc>Minimum size of culling bins.  Must be &gt;= 8 and &lt;= OuterRadius.</desc>
</field>
<field>
<name>DebugBoxHeight</name>
<desc>Height multiplier for drawn culling bins.</desc>
</field>
<field>
<name>FadeInRegion</name>
<desc>Region beyond ViewDistance where foliage fades in/out.</desc>
</field>
<field>
<name>FadeOutRegion</name>
<desc>Region before ViewClosest where foliage fades in/out.</desc>
</field>
<field>
<name>FixAspectRatio</name>
<desc>Maintain aspect ratio of image if true. This option ignores MaxWidth.</desc>
</field>
<field>
<name>FixSizeToMax</name>
<desc>Use only MaxWidth and MaxHeight for billboard size. Ignores MinWidth and MinHeight.</desc>
</field>
<field>
<name>FoliageCount</name>
<desc>Maximum foliage instance count.</desc>
</field>
<field>
<name>FoliageFile</name>
<desc>Image file for the foliage texture.</desc>
</field>
<field>
<name>FoliageRetries</name>
<desc>Number of times to try placing a foliage instance before giving up.</desc>
</field>
<field>
<name>GroundAlpha</name>
<desc>Alpha of the foliage at ground level. 0 = transparent, 1 = opaque.</desc>
</field>
<field>
<name>HideFoliage</name>
<desc>Foliage is hidden when set to true.</desc>
</field>
<field>
<name>InnerRadiusX</name>
<desc>Placement area inner radius on the X axis</desc>
</field>
<field>
<name>InnerRadiusY</name>
<desc>Placement area inner radius on the Y axis</desc>
</field>
<field>
<name>LightOn</name>
<desc>Foliage should be illuminated with changing lights when true.</desc>
</field>
<field>
<name>LightSync</name>
<desc>Foliage instances have the same lighting when set and LightOn is set.</desc>
</field>
<field>
<name>LightTime</name>
<desc>Time before foliage illumination cycle repeats.</desc>
</field>
<field>
<name>MaxHeight</name>
<desc>Maximum height of foliage billboards</desc>
</field>
<field>
<name>MaxLuminance</name>
<desc>Maximum luminance for foliage instances.</desc>
</field>
<field>
<name>MaxSwayTime</name>
<desc>Maximum sway cycle time in seconds.</desc>
</field>
<field>
<name>MaxWidth</name>
<desc>Maximum width of foliage billboards</desc>
</field>
<field>
<name>MinHeight</name>
<desc>Minimum height of foliage billboards</desc>
</field>
<field>
<name>MinLuminance</name>
<desc>Minimum luminance for foliage instances.</desc>
</field>
<field>
<name>MinSwayTime</name>
<desc>Minumum sway cycle time in seconds.</desc>
</field>
<field>
<name>MinWidth</name>
<desc>Minimum width of foliage billboards</desc>
</field>
<field>
<name>OffsetZ</name>
<desc>Offset billboards by this amount vertically.</desc>
</field>
<field>
<name>OuterRadiusX</name>
<desc>Placement area outer radius on the X axis</desc>
</field>
<field>
<name>OuterRadiusY</name>
<desc>Placement area outer radius on the Y axis</desc>
</field>
<field>
<name>PlacementAreaHeight</name>
<desc>Height of the placement ring in world units.</desc>
</field>
<field>
<name>PlacementColour</name>
<desc>Color of the placement ring.</desc>
</field>
<field>
<name>RandomFlip</name>
<desc>Randomly flip billboards left-to-right.</desc>
</field>
<field>
<name>seed</name>
<desc>Random seed for foliage placement.</desc>
</field>
<field>
<name>ShowPlacementArea</name>
<desc>Draw placement rings when set to true.</desc>
</field>
<field>
<name>SwayMagFront</name>
<desc>Front-to-back sway magnitude.</desc>
</field>
<field>
<name>SwayMagSide</name>
<desc>Left-to-right sway magnitude.</desc>
</field>
<field>
<name>SwayOn</name>
<desc>Foliage should sway randomly when true.</desc>
</field>
<field>
<name>SwaySync</name>
<desc>Foliage instances should sway together when true and SwayOn is enabled.</desc>
</field>
<field>
<name>UseCulling</name>
<desc>Use culling bins when enabled.</desc>
</field>
<field>
<name>UseDebugInfo</name>
<desc>Culling bins are drawn when set to true.</desc>
</field>
<field>
<name>useTrueBillboards</name>
<desc>Use camera facing billboards ( including the z axis ).</desc>
</field>
<field>
<name>ViewClosest</name>
<desc>Minimum distance from camera where foliage appears.</desc>
</field>
<field>
<name>ViewDistance</name>
<desc>Maximum distance from camera where foliage appears.</desc>
</field>
</class>
<class>
<name>fxFoliageReplicatorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxFoliageSet</name>
<base>SimSet</base>
</class>
<class>
<name>fxJoint</name>
<base>GameBase</base>
<field>
<name>AxisA</name>
<desc>Point3F AxisA</desc>
</field>
<field>
<name>AxisB</name>
<desc>Point3F AxisB</desc>
</field>
<field>
<name>BodyA</name>
<desc>int BodyA</desc>
</field>
<field>
<name>BodyB</name>
<desc>int BodyB</desc>
</field>
<field>
<name>FlexBodyPartA</name>
<desc>int FlexBodyPartA</desc>
</field>
<field>
<name>FlexBodyPartB</name>
<desc>int FlexBodyPartB</desc>
</field>
<field>
<name>GlobalAnchor</name>
<desc>Point3F GlobalAnchor</desc>
</field>
<field>
<name>GlobalAxis</name>
<desc>Point3F GlobalAxis</desc>
</field>
<field>
<name>LocalAnchor0</name>
<desc>Point3F LocalAnchor0</desc>
</field>
<field>
<name>LocalAnchor1</name>
<desc>Point3F LocalAnchor1</desc>
</field>
<field>
<name>LocalAxis0</name>
<desc>Point3F LocalAxis0</desc>
</field>
<field>
<name>LocalAxis1</name>
<desc>Point3F LocalAxis1</desc>
</field>
<field>
<name>LocalNormal0</name>
<desc>Point3F LocalNormal0</desc>
</field>
<field>
<name>LocalNormal1</name>
<desc>Point3F LocalNormal1</desc>
</field>
<field>
<name>NormalA</name>
<desc>Point3F NormalA</desc>
</field>
<field>
<name>NormalB</name>
<desc>Point3F NormalB</desc>
</field>
</class>
<class>
<name>fxJointClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxJointData</name>
<base>GameBaseData</base>
<field>
<name>AxisA</name>
<desc>Point3F AxisA</desc>
</field>
<field>
<name>AxisB</name>
<desc>Point3F AxisB</desc>
</field>
<field>
<name>BreakingForce</name>
<desc>float BreakingForce</desc>
</field>
<field>
<name>BreakingTorque</name>
<desc>float BreakingTorque</desc>
</field>
<field>
<name>CollisionEnabled</name>
<desc>bool CollisionEnabled</desc>
</field>
<field>
<name>DistanceLimit</name>
<desc>float DistanceLimit</desc>
</field>
<field>
<name>HighLimit</name>
<desc>float HighLimit</desc>
</field>
<field>
<name>HighRestitution</name>
<desc>float HighRestitution</desc>
</field>
<field>
<name>HW</name>
<desc>bool HW</desc>
</field>
<field>
<name>JointSpring</name>
<desc>float JointSpring</desc>
</field>
<field>
<name>JointType</name>
<desc>physJointType JointType</desc>
</field>
<field>
<name>LimitPlaneAnchor1</name>
<desc>Point3F LimitPlaneAnchor1</desc>
</field>
<field>
<name>LimitPlaneAnchor2</name>
<desc>Point3F LimitPlaneAnchor2</desc>
</field>
<field>
<name>LimitPlaneAnchor3</name>
<desc>Point3F LimitPlaneAnchor3</desc>
</field>
<field>
<name>LimitPlaneAnchor4</name>
<desc>Point3F LimitPlaneAnchor4</desc>
</field>
<field>
<name>LimitPlaneNormal1</name>
<desc>Point3F LimitPlaneNormal1</desc>
</field>
<field>
<name>LimitPlaneNormal2</name>
<desc>Point3F LimitPlaneNormal2</desc>
</field>
<field>
<name>LimitPlaneNormal3</name>
<desc>Point3F LimitPlaneNormal3</desc>
</field>
<field>
<name>LimitPlaneNormal4</name>
<desc>Point3F LimitPlaneNormal4</desc>
</field>
<field>
<name>LimitPoint</name>
<desc>Point3F LimitPoint</desc>
</field>
<field>
<name>LocalAnchor0</name>
<desc>Point3F LocalAnchor0</desc>
</field>
<field>
<name>LocalAnchor1</name>
<desc>Point3F LocalAnchor1</desc>
</field>
<field>
<name>LocalAxis0</name>
<desc>Point3F LocalAxis0</desc>
</field>
<field>
<name>LocalAxis1</name>
<desc>Point3F LocalAxis1</desc>
</field>
<field>
<name>LocalNormal0</name>
<desc>Point3F LocalNormal0</desc>
</field>
<field>
<name>LocalNormal1</name>
<desc>Point3F LocalNormal1</desc>
</field>
<field>
<name>LowLimit</name>
<desc>float LowLimit</desc>
</field>
<field>
<name>LowRestitution</name>
<desc>float LowRestitution</desc>
</field>
<field>
<name>MotorForce</name>
<desc>float MotorForce</desc>
</field>
<field>
<name>MotorSpeed</name>
<desc>float MotorSpeed</desc>
</field>
<field>
<name>NormalA</name>
<desc>Point3F NormalA</desc>
</field>
<field>
<name>NormalB</name>
<desc>Point3F NormalB</desc>
</field>
<field>
<name>SpringDamper</name>
<desc>float SpringDamper</desc>
</field>
<field>
<name>SpringTargetAngle</name>
<desc>float SpringTargetAngle</desc>
</field>
<field>
<name>SwingLimit</name>
<desc>float SwingLimit</desc>
</field>
<field>
<name>SwingLimit2</name>
<desc>float SwingLimit2</desc>
</field>
<field>
<name>SwingSpring</name>
<desc>float SwingSpring</desc>
</field>
<field>
<name>TwistLimit</name>
<desc>float TwistLimit</desc>
</field>
<field>
<name>TwistSpring</name>
<desc>float TwistSpring</desc>
</field>
</class>
<class>
<name>fxJointDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxPhysMaterial</name>
<base>GameBaseData</base>
<field>
<name>density</name>
<desc>float density</desc>
</field>
<field>
<name>DynamicFriction</name>
<desc>float DynamicFriction</desc>
</field>
<field>
<name>Restitution</name>
<desc>float Restitution</desc>
</field>
<field>
<name>StaticFriction</name>
<desc>float StaticFriction</desc>
</field>
<field>
<name>TextureName</name>
<desc>string TextureName</desc>
</field>
</class>
<class>
<name>fxPhysMaterialClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxReplicatorSet</name>
<base>SimSet</base>
</class>
<class>
<name>fxRigidBody</name>
<base>ShapeBase</base>
<method>
<name>clearKinematic</name>
<args>()</args>
</method>
<method>
<name>getPhysSpeed</name>
<desc>getPhysSpeed()</desc>
</method>
<method>
<name>getPhysVelocity</name>
<desc>getPhysVelocity()</desc>
</method>
<method>
<name>getWeaponPosAdj</name>
<desc>getWeaponPosAdj()</desc>
</method>
<method>
<name>remove</name>
<desc>remove()</desc>
</method>
<method>
<name>resetPosition</name>
<args>()</args>
</method>
<method>
<name>setAngularVelocity</name>
<desc>setAngularVelocity(Point3F)</desc>
</method>
<method>
<name>setForce</name>
<desc>Sets local force.</desc>
</method>
<method>
<name>setGlobalDelayForce</name>
<desc>Sets delayed global force.</desc>
</method>
<method>
<name>setGlobalForce</name>
<desc>Sets global force.</desc>
</method>
<method>
<name>setGlobalTorque</name>
<args>(Point3F kTorque)</args>
</method>
<method>
<name>setIsStriking</name>
<args>(bool isStriking)</args>
</method>
<method>
<name>setKinematic</name>
<args>()</args>
</method>
<method>
<name>setLifetime</name>
<desc>Sets lifetime in MS.</desc>
</method>
<method>
<name>setLinearVelocity</name>
<desc>setLinearVelocity(Point3F)</desc>
</method>
<method>
<name>setNoGravity</name>
<desc>Sets gravity (true/false).</desc>
</method>
<method>
<name>setTorque</name>
<args>(Point3F kTorque)</args>
</method>
<method>
<name>setWeaponPosAdj</name>
<desc>setWeaponPosAdj(Point3F)</desc>
</method>
<method>
<name>setWeaponRotAdjA</name>
<desc>setWeaponRotAdjA(Point3F)</desc>
</method>
<method>
<name>setWeaponRotAdjB</name>
<desc>setWeaponRotAdjB(Point3F)</desc>
</method>
<field>
<name>AutoClearKinematic</name>
<desc>bool AutoClearKinematic</desc>
</field>
<field>
<name>CurrentForce</name>
<desc>Point3F CurrentForce</desc>
</field>
<field>
<name>CurrentTorque</name>
<desc>Point3F CurrentTorque</desc>
</field>
<field>
<name>HadCollision</name>
<desc>bool HadCollision</desc>
</field>
<field>
<name>HasTrigger</name>
<desc>bool HasTrigger</desc>
</field>
<field>
<name>InitialVelocity</name>
<desc>Point3F InitialVelocity</desc>
</field>
<field>
<name>IsClientOnly</name>
<desc>bool IsClientOnly</desc>
</field>
<field>
<name>IsKinematic</name>
<desc>bool IsKinematic</desc>
</field>
<field>
<name>IsNoGravity</name>
<desc>bool IsNoGravity</desc>
</field>
<field>
<name>Lifetime</name>
<desc>int Lifetime</desc>
</field>
<field>
<name>ReferenceNumber</name>
<desc>int ReferenceNumber</desc>
</field>
</class>
<class>
<name>fxRigidBodyClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxRigidBodyData</name>
<base>ShapeBaseData</base>
<field>
<name>Dimensions</name>
<desc>Point3F Dimensions</desc>
</field>
<field>
<name>DynamicFriction</name>
<desc>float DynamicFriction</desc>
</field>
<field>
<name>HasSpring</name>
<desc>bool HasSpring</desc>
</field>
<field>
<name>HasTrigger</name>
<desc>bool HasTrigger</desc>
</field>
<field>
<name>HW</name>
<desc>bool HW</desc>
</field>
<field>
<name>InflictMultiplier</name>
<desc>float InflictMultiplier</desc>
</field>
<field>
<name>IsInflictor</name>
<desc>bool IsInflictor</desc>
</field>
<field>
<name>IsKinematic</name>
<desc>bool IsKinematic</desc>
</field>
<field>
<name>IsNoGravity</name>
<desc>bool IsNoGravity</desc>
</field>
<field>
<name>IsTransient</name>
<desc>bool IsTransient</desc>
</field>
<field>
<name>Lifetime</name>
<desc>int Lifetime</desc>
</field>
<field>
<name>myDensity</name>
<desc>float myDensity</desc>
</field>
<field>
<name>offset</name>
<desc>Point3F offset</desc>
</field>
<field>
<name>orientation</name>
<desc>Point3F orientation</desc>
</field>
<field>
<name>ProjectileAxis</name>
<desc>Point3F ProjectileAxis</desc>
</field>
<field>
<name>Restitution</name>
<desc>float Restitution</desc>
</field>
<field>
<name>ShapeType</name>
<desc>physShapeType ShapeType</desc>
</field>
<field>
<name>SleepThreshold</name>
<desc>float SleepThreshold</desc>
</field>
<field>
<name>StaticFriction</name>
<desc>float StaticFriction</desc>
</field>
<field>
<name>TriggerActorOffset</name>
<desc>Point3F TriggerActorOffset</desc>
</field>
<field>
<name>TriggerDimensions</name>
<desc>Point3F TriggerDimensions</desc>
</field>
<field>
<name>TriggerOffset</name>
<desc>Point3F TriggerOffset</desc>
</field>
<field>
<name>TriggerOrientation</name>
<desc>Point3F TriggerOrientation</desc>
</field>
<field>
<name>TriggerShapeType</name>
<desc>physShapeType TriggerShapeType</desc>
</field>
<field>
<name>WeaponPosAdj</name>
<desc>Point3F WeaponPosAdj</desc>
</field>
<field>
<name>WeaponRotAdjA</name>
<desc>Point3F WeaponRotAdjA</desc>
</field>
<field>
<name>WeaponRotAdjB</name>
<desc>Point3F WeaponRotAdjB</desc>
</field>
</class>
<class>
<name>fxRigidBodyDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxShapeReplicatedStatic</name>
<base>SceneObject</base>
<field>
<name>allowPlayerStep</name>
<desc>Allow a Player to walk up sloping polygons in the TSStatic (based on the collisionType).</desc>
</field>
<field>
<name>collisionType</name>
<desc>The type of mesh data to use for collision queries.</desc>
</field>
<field>
<name>decalType</name>
<desc>The type of mesh data used to clip decal polygons against.</desc>
</field>
<field>
<name>forceDetail</name>
<desc>Forces rendering to a particular detail level.</desc>
</field>
<field>
<name>meshCulling</name>
<desc>Enables detailed culling of meshes within the TSStatic. Should only be used with large complex shapes like buildings which contain many submeshes.</desc>
</field>
<field>
<name>originSort</name>
<desc>Enables translucent sorting of the TSStatic by its origin instead of the bounds.</desc>
</field>
<field>
<name>playAmbient</name>
<desc>Enables automatic playing of the animation named "ambient" (if it exists) when the TSStatic is loaded.</desc>
</field>
<field>
<name>renderNormals</name>
<desc>Debug rendering mode shows the normals for each point in the TSStatic's mesh.</desc>
</field>
<field>
<name>shapeName</name>
<desc>Path and filename of the model file (.DTS, .DAE) to use for this TSStatic.</desc>
</field>
</class>
<class>
<name>fxShapeReplicatedStaticClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxShapeReplicator</name>
<base>SceneObject</base>
<field>
<name>AlignToTerrain</name>
<desc>Align shapes to surface normal when set.</desc>
</field>
<field>
<name>AllowedTerrainSlope</name>
<desc>Maximum surface angle allowed for shape instances.</desc>
</field>
<field>
<name>AllowOnInteriors</name>
<desc>Shapes will be placed on InteriorInstances when set.</desc>
</field>
<field>
<name>AllowOnStatics</name>
<desc>Shapes will be placed on Static shapes when set.</desc>
</field>
<field>
<name>AllowOnTerrain</name>
<desc>Shapes will be placed on terrain when set.</desc>
</field>
<field>
<name>AllowOnWater</name>
<desc>Shapes will be placed on/under water when set.</desc>
</field>
<field>
<name>AllowWaterSurface</name>
<desc>Shapes will be placed on water when set. Requires AllowOnWater.</desc>
</field>
<field>
<name>HideReplications</name>
<desc>Replicated shapes are hidden when set to true.</desc>
</field>
<field>
<name>InnerRadiusX</name>
<desc>Placement area inner radius on the X axis</desc>
</field>
<field>
<name>InnerRadiusY</name>
<desc>Placement area inner radius on the Y axis</desc>
</field>
<field>
<name>Interactions</name>
<desc>Allow physics interactions with shapes.</desc>
</field>
<field>
<name>OffsetZ</name>
<desc>Offset shapes by this amount vertically.</desc>
</field>
<field>
<name>OuterRadiusX</name>
<desc>Placement area outer radius on the X axis</desc>
</field>
<field>
<name>OuterRadiusY</name>
<desc>Placement area outer radius on the Y axis</desc>
</field>
<field>
<name>PlacementAreaHeight</name>
<desc>Height of the placement ring in world units.</desc>
</field>
<field>
<name>PlacementColour</name>
<desc>Color of the placement ring.</desc>
</field>
<field>
<name>seed</name>
<desc>Random seed for shape placement.</desc>
</field>
<field>
<name>ShapeCount</name>
<desc>Maximum shape instance count.</desc>
</field>
<field>
<name>shapeFile</name>
<desc>Filename of shape to replicate.</desc>
</field>
<field>
<name>ShapeRetries</name>
<desc>Number of times to try placing a shape instance before giving up.</desc>
</field>
<field>
<name>ShapeRotateMax</name>
<desc>Maximum shape rotation angles.</desc>
</field>
<field>
<name>ShapeRotateMin</name>
<desc>Minimum shape rotation angles.</desc>
</field>
<field>
<name>ShapeScaleMax</name>
<desc>Maximum shape scale.</desc>
</field>
<field>
<name>ShapeScaleMin</name>
<desc>Minimum shape scale.</desc>
</field>
<field>
<name>ShowPlacementArea</name>
<desc>Draw placement rings when set to true.</desc>
</field>
<field>
<name>TerrainAlignment</name>
<desc>Surface normals will be multiplied by these values when AlignToTerrain is enabled.</desc>
</field>
</class>
<class>
<name>fxShapeReplicatorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxSpring</name>
<base>GameBase</base>
<field>
<name>AnchorA</name>
<desc>Point3F AnchorA</desc>
</field>
<field>
<name>AnchorB</name>
<desc>Point3F AnchorB</desc>
</field>
<field>
<name>BodyA</name>
<desc>int BodyA</desc>
</field>
<field>
<name>BodyB</name>
<desc>int BodyB</desc>
</field>
</class>
<class>
<name>fxSpringClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>fxSpringData</name>
<base>GameBaseData</base>
<field>
<name>CompressSaturate</name>
<desc>float CompressSaturate</desc>
</field>
<field>
<name>HW</name>
<desc>bool HW</desc>
</field>
<field>
<name>MaxDamper</name>
<desc>float MaxDamper</desc>
</field>
<field>
<name>MaxDamperCompress</name>
<desc>float MaxDamperCompress</desc>
</field>
<field>
<name>MaxDamperStretch</name>
<desc>float MaxDamperStretch</desc>
</field>
<field>
<name>MaxSpring</name>
<desc>float MaxSpring</desc>
</field>
<field>
<name>MaxSpringCompress</name>
<desc>float MaxSpringCompress</desc>
</field>
<field>
<name>MaxSpringStretch</name>
<desc>float MaxSpringStretch</desc>
</field>
<field>
<name>RestLengthModifier</name>
<desc>float RestLengthModifier</desc>
</field>
<field>
<name>StretchSaturate</name>
<desc>float StretchSaturate</desc>
</field>
<field>
<name>VelocityDamperCompress</name>
<desc>float VelocityDamperCompress</desc>
</field>
<field>
<name>VelocityDamperStretch</name>
<desc>float VelocityDamperStretch</desc>
</field>
</class>
<class>
<name>fxSpringDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>gaActionUser</name>
<base>GameBase</base>
</class>
<class>
<name>gaActionUserClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>gaActionUserData</name>
<base>GameBaseData</base>
<field>
<name>actionName</name>
<desc>string actionName</desc>
</field>
<field>
<name>FitnessData1</name>
<desc>gaFitnessData FitnessData1</desc>
</field>
<field>
<name>FitnessData2</name>
<desc>gaFitnessData FitnessData2</desc>
</field>
<field>
<name>FitnessData3</name>
<desc>gaFitnessData FitnessData3</desc>
</field>
<field>
<name>FitnessData4</name>
<desc>gaFitnessData FitnessData4</desc>
</field>
<field>
<name>FitnessData5</name>
<desc>gaFitnessData FitnessData5</desc>
</field>
<field>
<name>FitnessData6</name>
<desc>gaFitnessData FitnessData6</desc>
</field>
<field>
<name>MigrateChance</name>
<desc>float MigrateChance</desc>
</field>
<field>
<name>MutationAmount</name>
<desc>float MutationAmount</desc>
</field>
<field>
<name>MutationChance</name>
<desc>float MutationChance</desc>
</field>
<field>
<name>NumActionSets</name>
<desc>int NumActionSets</desc>
</field>
<field>
<name>NumPopulations</name>
<desc>int NumPopulations</desc>
</field>
<field>
<name>NumRestSteps</name>
<desc>int NumRestSteps</desc>
</field>
<field>
<name>NumSequenceReps</name>
<desc>int NumSequenceReps</desc>
</field>
<field>
<name>ObserveInterval</name>
<desc>int ObserveInterval</desc>
</field>
</class>
<class>
<name>gaActionUserDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>gaFitnessData</name>
<base>GameBaseData</base>
<field>
<name>BodypartName</name>
<desc>string BodypartName</desc>
</field>
<field>
<name>PositionGoal</name>
<desc>Point3F PositionGoal</desc>
</field>
<field>
<name>PositionGoalType</name>
<desc>Point3I PositionGoalType</desc>
</field>
<field>
<name>RotationGoal</name>
<desc>float RotationGoal</desc>
</field>
<field>
<name>RotationGoalType</name>
<desc>int RotationGoalType</desc>
</field>
</class>
<class>
<name>gaFitnessDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GameBase</name>
<base>SceneObject</base>
<method>
<name>applyImpulse</name>
<args>( Point3F pos, VectorF vel )</args>
<desc>Apply an impulse to this object.
@param pos impulse world position
@param vel impulse velocity (impulse force F = m * v)
@return true</desc>
</method>
<method>
<name>applyRadialImpulse</name>
<args>( Point3F origin, float radius, float magnitude )</args>
<desc>Applies a radial impulse to the object using the given origin and force.
@param origin Point of origin of the radial impulse.
@param radius The radius of the impulse area.
@param magnitude The strength of the impulse.</desc>
</method>
<method>
<name>getDataBlock</name>
<args>()</args>
<desc>Get the datablock used by this object.
@return the datablock this GameBase is using.</desc>
</method>
<method>
<name>setDataBlock</name>
<args>( GameBaseData data )</args>
<desc>Assign this GameBase to use the specified datablock.
@param data new datablock to use
@return true if successful, false if failed.</desc>
</method>
<field>
<name>dataBlock</name>
<desc>Script datablock used for game objects.</desc>
</field>
<field>
<name>setControl( bool controlled )</name>
<desc>Called when the client controlling the object changes.
@param controlled true if a client now controls this object, false if no client controls this object.</desc>
</field>
</class>
<class>
<name>GameBaseClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GameBaseData</name>
<base>SimDataBlock</base>
<field>
<name>category</name>
<desc>The group that this datablock will show up in under the "Scripted" tab in the World Editor Library.</desc>
</field>
<field>
<name>onAdd( GameBase obj )</name>
<desc>Called when the object is added to the scene.
@param obj the GameBase object

@tsexample
datablock GameBaseData(MyObjectData)
{
category = "Misc";
};

function MyObjectData::onAdd( %this, %obj )
{
echo( "Added " @ %obj.getName() @ " to the scene." );
}

function MyObjectData::onNewDataBlock( %this, %obj )
{
echo( "Assign " @ %this.getName() @ " datablock to " %obj.getName() );
}

function MyObjectData::onRemove( %this, %obj )
{
echo( "Removed " @ %obj.getName() @ " to the scene." );
}

function MyObjectData::onMount( %this, %obj, %mountObj, %node )
{
echo( %obj.getName() @ " mounted to " @ %mountObj.getName() );
}

function MyObjectData::onUnmount( %this, %obj, %mountObj, %node )
{
echo( %obj.getName() @ " unmounted from " @ %mountObj.getName() );
}

@endtsexample</desc>
</field>
<field>
<name>onMount( GameBase obj, SceneObject mountObj, int node )</name>
<desc>Called when the object is mounted to another object in the scene.
@param obj the GameBase object being mounted
@param mountObj the object we are mounted to
@param node the mountObj node we are mounted to

@see onAdd</desc>
</field>
<field>
<name>onNewDataBlock( GameBase obj )</name>
<desc>Called when the object has a new datablock assigned.
@param obj the GameBase object

@see onAdd</desc>
</field>
<field>
<name>onRemove( GameBase obj )</name>
<desc>Called when the object is removed to the scene.
@param obj the GameBase object

@see onAdd</desc>
</field>
<field>
<name>onUnmount( GameBase obj, SceneObject mountObj, int node )</name>
<desc>Called when the object is unmounted from another object in the scene.
@param obj the GameBase object being unmounted
@param mountObj the object we are unmounted from
@param node the mountObj node we are unmounted from

@see onAdd</desc>
</field>
</class>
<class>
<name>GameBaseDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GameConnection</name>
<base>NetConnection</base>
<method>
<name>activateGhosting</name>
<args>()</args>
<desc>@brief Called by the server during phase 2 of the mission download to start sending ghosts to the client.

Ghosts represent objects on the server that are in scope for the client.  These need to be synchronized with the client in order for the client to see and interact with them.  This is typically done during the standard mission start phase 2 when following Torque's example mission startup sequence.

@tsexample
function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
{
// Make sure to ignore calls from a previous mission load
if (%seq != $missionSequence || !$MissionRunning)
return;
if (%client.currentPhase != 1.5)
return;
%client.currentPhase = 2;

// Set the player datablock choice
%client.playerDB = %playerDB;

// Update mod paths, this needs to get there before the objects.
%client.transmitPaths();

// Start ghosting objects to the client
%client.activateGhosting();
}
@endtsexample

@see @ref ghosting_scoping for a description of the ghosting system.</desc>
</method>
<method>
<name>chaseCam</name>
<args>( int size )</args>
<desc>@brief Sets the size of the chase camera's matrix queue.

@note This sets the queue size across all GameConnections.

@note This is not currently hooked up.</desc>
</method>
<method>
<name>clearCameraObject</name>
<args>()</args>
<desc>@brief Clear the connection's camera object reference.

@see GameConnection::setCameraObject() and GameConnection::getCameraObject()</desc>
</method>
<method>
<name>delete</name>
<args>( string reason="" )</args>
<desc>@brief On the server, disconnect a client and pass along an optional reason why.

This method performs two operations: it disconnects a client connection from the server, and it deletes the connection object.  The optional reason is sent in the disconnect packet and is often displayed to the user so they know why they've been disconnected.

@param reason [optional] The reason why the user has been disconnected from the server.

@tsexample
function kick(%client)
{
messageAll( 'MsgAdminForce', '\c2The Admin has kicked %1.', %client.playerName);

if (!%client.isAIControlled())
BanList::add(%client.guid, %client.getAddress(), $Pref::Server::KickBanTime);
%client.delete("You have been kicked from this server");
}
@endtsexample</desc>
</method>
<method>
<name>getCameraObject</name>
<args>()</args>
<desc>@brief Returns the connection's camera object used when not viewing through the control object.

@see GameConnection::setCameraObject() and GameConnection::clearCameraObject()</desc>
</method>
<method>
<name>getControlCameraFov</name>
<args>()</args>
<desc>@brief Returns the field of view as used by the control object's camera.</desc>
</method>
<method>
<name>getControlObject</name>
<args>()</args>
<desc>@brief On the server, returns the object that the client is controlling.By default the control object is an instance of the Player class, but can also be an instance of Camera (when editing the mission, for example), or any other ShapeBase derived class as appropriate for the game.

@see GameConnection::setControlObject()</desc>
</method>
<method>
<name>getServerConnection</name>
<args>()</args>
<desc>@brief On the client, this static mehtod will return the connection to the server, if any.

@returns The SimObject ID of the server connection, or -1 if none is found.</desc>
</method>
<method>
<name>isAIControlled</name>
<args>()</args>
<desc>@brief Returns true if this connection is AI controlled.

@see AIConnection</desc>
</method>
<method>
<name>isControlObjectRotDampedCamera</name>
<args>()</args>
<desc>@brief Returns true if the object being controlled by the client is making use of a rotation damped camera.

@see Camera</desc>
</method>
<method>
<name>isDemoPlaying</name>
<args>()</args>
<desc>@brief Returns true if a previously recorded demo file is now playing.

@see GameConnection::playDemo()</desc>
</method>
<method>
<name>isDemoRecording</name>
<args>()</args>
<desc>@brief Returns true if a demo file is now being recorded.

@see GameConnection::startRecording(), GameConnection::stopRecording()</desc>
</method>
<method>
<name>isFirstPerson</name>
<args>()</args>
<desc>@brief Returns true if this connection is in first person mode.

@note Transition to first person occurs over time via mCameraPos, so this won't immediately return true after a set.</desc>
</method>
<method>
<name>listClassIDs</name>
<args>()</args>
<desc>@brief List all of the classes that this connection knows about, and what their IDs are. Useful for debugging network problems.

@note The list is sent to the console.</desc>
</method>
<method>
<name>play2D</name>
<args>( SFXProfile profile )</args>
<desc>@brief Used on the server to play a 2D sound that is not attached to any object.

@param profile The SFXProfile that defines the sound to play.

@tsexample
function ServerPlay2D(%profile)
{
// Play the given sound profile on every client.
// The sounds will be transmitted as an event, not attached to any object.
for(%idx = 0; %idx &lt; ClientGroup.getCount(); %idx++)
ClientGroup.getObject(%idx).play2D(%profile);
}
@endtsexample</desc>
</method>
<method>
<name>play3D</name>
<args>( SFXProfile profile, TransformF location )</args>
<desc>@brief Used on the server to play a 3D sound that is not attached to any object.

@param profile The SFXProfile that defines the sound to play.
@param location The position and orientation of the 3D sound given in the form of "x y z ax ay az aa".

@tsexample
function ServerPlay3D(%profile,%transform)
{
// Play the given sound profile at the given position on every client
// The sound will be transmitted as an event, not attached to any object.
for(%idx = 0; %idx &lt; ClientGroup.getCount(); %idx++)
ClientGroup.getObject(%idx).play3D(%profile,%transform);
}
@endtsexample</desc>
</method>
<method>
<name>playDemo</name>
<args>( string demoFileName )</args>
<desc>@brief On the client, play back a previously recorded game session.

It is often useful to play back a game session.  This could be for producing a demo of the game that will be shown at a later time, or for debugging a game.  By recording the entire network stream it is possible to later play game the game exactly as it unfolded during the actual play session.  This is because all user control and server results pass through the connection.

@returns True if the playback was successful.  False if there was an issue, such as not being able to open the demo file for playback.

@see GameConnection::startRecording(), GameConnection::stopRecording()</desc>
</method>
<method>
<name>resetGhosting</name>
<args>()</args>
<desc>@brief On the server, resets the connection to indicate that ghosting has been disabled.

Typically when a mission has ended on the server, all connected clients are informed of this change and their connections are reset back to a starting state.  This method resets a connection on the server to indicate that ghosts are no longer being transmitted.  On the client end, all ghost information will be deleted.

@tsexample
// Inform the clients
for (%clientIndex = 0; %clientIndex &lt; ClientGroup.getCount(); %clientIndex++)
{
// clear ghosts and paths from all clients
%cl = ClientGroup.getObject(%clientIndex);
%cl.endMission();
%cl.resetGhosting();
%cl.clearPaths();
}
@endtsexample

@see @ref ghosting_scoping for a description of the ghosting system.</desc>
</method>
<method>
<name>setBlackOut</name>
<args>( bool doFade, int timeMS )</args>
<desc>@brief On the server, sets the client's 3D display to fade to black.

@param doFade Set to true to fade to black, and false to fade from black.
@param timeMS Time it takes to perform the fade as measured in ms.

@note Not currently hooked up, and is not synchronized over the network.</desc>
</method>
<method>
<name>setCameraObject</name>
<args>( GameBase camera )</args>
<desc>@brief On the server, set the connection's camera object used when not viewing through the control object.

@see GameConnection::getCameraObject() and GameConnection::clearCameraObject()</desc>
</method>
<method>
<name>setConnectArgs</name>
<args>(const char* args)</args>
<desc>@brief On the client, pass along a variable set of parameters to the server.

Once the connection is established with the server, the server calls its onConnect() method with the client's passed in parameters as aruments.

@see GameConnection::onConnect()</desc>
</method>
<method>
<name>setControlCameraFov</name>
<args>( float newFOV )</args>
<desc>@brief On the server, sets the control object's camera's field of view.

@param newFOV New field of view (in degrees) to force the control object's camera to use.  This value is clamped to be within the range of 1 to 179 degrees.

@note When transmitted over the network to the client, the resolution is limited to one degree.  Any fraction is dropped.</desc>
</method>
<method>
<name>setControlObject</name>
<args>( GameBase ctrlObj )</args>
<desc>@brief On the server, sets the object that the client will control.

By default the control object is an instance of the Player class, but can also be an instance of Camera (when editing the mission, for example), or any other ShapeBase derived class as appropriate for the game.

@param ctrlObj The GameBase object on the server to control.</desc>
</method>
<method>
<name>setFirstPerson</name>
<args>( bool firstPerson )</args>
<desc>@brief On the server, sets this connection into or out of first person mode.

@param firstPerson Set to true to put the connection into first person mode.</desc>
</method>
<method>
<name>setJoinPassword</name>
<args>( string password )</args>
<desc>@brief On the client, set the password that will be passed to the server.

On the server, this password is compared with what is stored in $pref::Server::Password.  If $pref::Server::Password is empty then the client's sent password is ignored.  Otherwise, if the passed in client password and the server password do not match, the CHR_PASSWORD error string is sent back to the client and the connection is immediately terminated.

This password checking is performed quite early on in the connection request process so as to minimize the impact of multiple failed attempts -- also known as hacking.</desc>
</method>
<method>
<name>setMissionCRC</name>
<args>( int CRC )</args>
<desc>@brief On the server, transmits the mission file's CRC value to the client.

Typically, during the standard mission start phase 1, the mission file's CRC value on the server is send to the client.  This allows the client to determine if the mission has changed since the last time it downloaded this mission and act appropriately, such as rebuilt cached lightmaps.

@param CRC The mission file's CRC value on the server.

@tsexample
function serverCmdMissionStartPhase1Ack(%client, %seq)
{
// Make sure to ignore calls from a previous mission load
if (%seq != $missionSequence || !$MissionRunning)
return;
if (%client.currentPhase != 0)
return;
%client.currentPhase = 1;

// Start with the CRC
%client.setMissionCRC( $missionCRC );

// Send over the datablocks...
// OnDataBlocksDone will get called when have confirmation
// that they've all been received.
%client.transmitDataBlocks($missionSequence);
}
@endtsexample</desc>
</method>
<method>
<name>startRecording</name>
<args>( string fileName )</args>
<desc>@brief On the client, starts recording the network connection's traffic to a demo file.

It is often useful to play back a game session.  This could be for producing a demo of the game that will be shown at a later time, or for debugging a game.  By recording the entire network stream it is possible to later play game the game exactly as it unfolded during the actual play session.  This is because all user control and server results pass through the connection.

@param fileName The file name to use for the demo recording.

@see GameConnection::stopRecording(), GameConnection::playDemo()</desc>
</method>
<method>
<name>stopRecording</name>
<args>()</args>
<desc>@brief On the client, stops the recording of a connection's network traffic to a file.

@see GameConnection::startRecording(), GameConnection::playDemo()</desc>
</method>
<method>
<name>transmitDataBlocks</name>
<args>( int sequence )</args>
<desc>@brief Sent by the server during phase 1 of the mission download to send the datablocks to the client.

SimDataBlocks, also known as just datablocks, need to be transmitted to the client prior to the client entering the game world.  These represent the static data that most objects in the world reference.  This is typically done during the standard mission start phase 1 when following Torque's example mission startup sequence.

When the datablocks have all been transmitted, onDataBlocksDone() is called to move the mission start process to the next phase.@param sequence The sequence is common between the server and client and ensures that the client is acting on the most recent mission start process.  If an errant network packet (one that was lost but has now been found) is received by the client with an incorrect sequence, it is just ignored.  This sequence number is updated on the server every time a mission is loaded.

@tsexample
function serverCmdMissionStartPhase1Ack(%client, %seq)
{
// Make sure to ignore calls from a previous mission load
if (%seq != $missionSequence || !$MissionRunning)
return;
if (%client.currentPhase != 0)
return;
%client.currentPhase = 1;

// Start with the CRC
%client.setMissionCRC( $missionCRC );

// Send over the datablocks...
// OnDataBlocksDone will get called when have confirmation
// that they've all been received.
%client.transmitDataBlocks($missionSequence);
}
@endtsexample

@see GameConnection::onDataBlocksDone()</desc>
</method>
<field>
<name>initialControlSet()</name>
<desc>@brief Called on the client when the first control object has been set by the server and we are now ready to go.

A common action to perform when this callback is called is to switch the GUI canvas from the loading screen and over to the 3D game GUI.</desc>
</field>
<field>
<name>onConnectionAccepted()</name>
<desc>@brief Called on the client when the connection to the server has been established.</desc>
</field>
<field>
<name>onConnectionDropped( string reason )</name>
<desc>@brief Called on the client when the connection to the server has been dropped.

@param reason The reason why the connection was dropped.</desc>
</field>
<field>
<name>onConnectionError( string errorString )</name>
<desc>@brief Called on the client when there is an error with the connection to the server.

@param errorString The connection error text.</desc>
</field>
<field>
<name>onConnectionTimedOut()</name>
<desc>@brief Called on the client when the connection to the server times out.</desc>
</field>
<field>
<name>onConnectRequestRejected( string reason )</name>
<desc>@brief Called on the client when the connection to the server has been rejected.

@param reason The reason why the connection request was rejected.</desc>
</field>
<field>
<name>onConnectRequestTimedOut()</name>
<desc>@brief Called when connection attempts have timed out.</desc>
</field>
<field>
<name>onDataBlocksDone( int sequence )</name>
<desc>@brief Called on the server when all datablocks has been sent to the client.

During phase 1 of the mission download, all datablocks are sent from the server to the client.  Once all datablocks have been sent, this callback is called and the mission download procedure may move on to the next phase.

@param sequence The sequence is common between the server and client and ensures that the client is acting on the most recent mission start process.  If an errant network packet (one that was lost but has now been found) is received by the client with an incorrect sequence, it is just ignored.  This sequence number is updated on the server every time a mission is loaded.

@see GameConnection::transmitDataBlocks()</desc>
</field>
<field>
<name>onDrop( string disconnectReason )</name>
<desc>@brief Called on the server when the client's connection has been dropped.

@param disconnectReason The reason why the connection was dropped.</desc>
</field>
<field>
<name>setLagIcon( bool state )</name>
<desc>@brief Called on the client to display the lag icon.

When the connection with the server is lagging, this callback is called to allow the game GUI to display some indicator to the player.

@param state Set to true if the lag icon should be displayed.</desc>
</field>
</class>
<class>
<name>GameConnectionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GameTSCtrl</name>
<base>GuiTSCtrl</base>
</class>
<class>
<name>GameTSCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GFXCardProfilerAPI</name>
<method>
<name>getCard</name>
<args>()</args>
<desc>Returns the card name.</desc>
</method>
<method>
<name>getRenderer</name>
<args>()</args>
<desc>Returns the renderer name.  For example D3D9 or OpenGL.</desc>
</method>
<method>
<name>getVendor</name>
<args>()</args>
<desc>Returns the card vendor name.</desc>
</method>
<method>
<name>getVersion</name>
<args>()</args>
<desc>Returns the driver version string.</desc>
</method>
<method>
<name>getVideoMemoryMB</name>
<args>()</args>
<desc>Returns the amount of video memory in megabytes.</desc>
</method>
<method>
<name>queryProfile</name>
<args>( string name, int defaultValue )</args>
<desc>Used to query the value of a specific card capability.
@param name The name of the capability being queried.
@param defaultValue The value to return if the capability is not defined.</desc>
</method>
<method>
<name>setCapability</name>
<args>( string name, int value )</args>
<desc>Used to set the value for a specific card capability.
@param name The name of the capability being set.
@param value The value to set for that capability.</desc>
</method>
</class>
<class>
<name>GFXInit</name>
<method>
<name>createNullDevice</name>
<args>()</args>
<desc>Create the NULL graphics device used for testing or headless operation.</desc>
</method>
<method>
<name>getAdapterCount</name>
<args>()</args>
<desc>Return the number of graphics adapters available. @ingroup GFX</desc>
</method>
<method>
<name>getAdapterMode</name>
<args>( int index, int modeIndex )</args>
<desc>Gets the details of the specified adapter mode.

@param index Index of the adapter to query.
@param modeIndex Index of the mode to get data from.
@return A video mode string in the format 'width height fullscreen bitDepth refreshRate aaLevel'.
@see GuiCanvas::getVideoMode()</desc>
</method>
<method>
<name>getAdapterModeCount</name>
<args>( int index )</args>
<desc>Gets the number of modes available on the specified adapter.

@param index Index of the adapter to get modes from.
@return The number of video modes supported by the adapter or -1 if the given adapter was not found.</desc>
</method>
<method>
<name>getAdapterName</name>
<args>( int index )</args>
<desc>Returns the name of the graphics adapter.
@param index The index of the adapter.</desc>
</method>
<method>
<name>getAdapterShaderModel</name>
<args>( int index )</args>
<desc>Returns the supported shader model of the graphics adapter or -1 if the index is bad.
@param index The index of the adapter.</desc>
</method>
<method>
<name>getAdapterType</name>
<args>( int index )</args>
<desc>Returns the type (D3D9, D3D8, GL, Null) of a graphics adapter.
@param index The index of the adapter.</desc>
</method>
<method>
<name>getDefaultAdapterIndex</name>
<args>()</args>
<desc>Returns the index of the default graphics adapter.  This is the graphics device which will be used to initialize the engine.</desc>
</method>
</class>
<class>
<name>GFXSamplerStateData</name>
<base>SimObject</base>
<field>
<name>addressModeU</name>
<desc>The texture address mode for the u coordinate.  The default is GFXAddressWrap.</desc>
</field>
<field>
<name>addressModeV</name>
<desc>The texture address mode for the v coordinate.  The default is GFXAddressWrap.</desc>
</field>
<field>
<name>addressModeW</name>
<desc>The texture address mode for the w coordinate.  The default is GFXAddressWrap.</desc>
</field>
<field>
<name>alphaArg1</name>
<desc>The first alpha argument for the texture stage.  The default value is GFXTATexture.</desc>
</field>
<field>
<name>alphaArg2</name>
<desc>The second alpha argument for the texture stage.  The default value is GFXTADiffuse.</desc>
</field>
<field>
<name>alphaArg3</name>
<desc>The third alpha channel selector operand for triadic operations (multiply, add, and linearly interpolate).  The default value is GFXTACurrent.</desc>
</field>
<field>
<name>alphaOp</name>
<desc>The texture alpha blending operation.  The default value is GFXTOPModulate.</desc>
</field>
<field>
<name>colorArg1</name>
<desc>The first color argument for the texture stage.  The default value is GFXTACurrent.</desc>
</field>
<field>
<name>colorArg2</name>
<desc>The second color argument for the texture stage.  The default value is GFXTATexture.</desc>
</field>
<field>
<name>colorArg3</name>
<desc>The third color argument for triadic operations (multiply, add, and linearly interpolate).  The default value is GFXTACurrent.</desc>
</field>
<field>
<name>magFilter</name>
<desc>The texture magnification filter.  The default is GFXTextureFilterLinear.</desc>
</field>
<field>
<name>maxAnisotropy</name>
<desc>The maximum texture anisotropy.  The default value is 1.</desc>
</field>
<field>
<name>minFilter</name>
<desc>The texture minification filter.  The default is GFXTextureFilterLinear.</desc>
</field>
<field>
<name>mipFilter</name>
<desc>The texture mipmap filter used during minification.  The default is GFXTextureFilterLinear.</desc>
</field>
<field>
<name>mipLODBias</name>
<desc>The mipmap level of detail bias.  The default value is zero.</desc>
</field>
<field>
<name>resultArg</name>
<desc>The selection of the destination register for the result of this stage.  The default is GFXTACurrent.</desc>
</field>
<field>
<name>textureColorOp</name>
<desc>The texture color blending operation.  The default value is GFXTOPDisable which disables the sampler.</desc>
</field>
<field>
<name>textureTransform</name>
<desc>Sets the texture transform state.  The default is GFXTTFFDisable.</desc>
</field>
</class>
<class>
<name>GFXSamplerStateDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GFXStateBlockData</name>
<base>SimObject</base>
<field>
<name>alphaDefined</name>
<desc>Set to true if the alpha test state is not all defaults.</desc>
</field>
<field>
<name>alphaTestEnable</name>
<desc>Enables per-pixel alpha testing.  The default is false.</desc>
</field>
<field>
<name>alphaTestFunc</name>
<desc>The test function used to accept or reject a pixel based on its alpha value.  The default is GFXCmpGreaterEqual.</desc>
</field>
<field>
<name>alphaTestRef</name>
<desc>The reference alpha value against which pixels are tested.  The default is zero.</desc>
</field>
<field>
<name>blendDefined</name>
<desc>Set to true if the alpha blend state is not all defaults.</desc>
</field>
<field>
<name>blendDest</name>
<desc>The destination blend state.  The default is GFXBlendZero.</desc>
</field>
<field>
<name>blendEnable</name>
<desc>Enables alpha blending.  The default is false.</desc>
</field>
<field>
<name>blendOp</name>
<desc>The arithmetic operation applied to alpha blending.  The default is GFXBlendOpAdd.</desc>
</field>
<field>
<name>blendSrc</name>
<desc>The source blend state.  The default is GFXBlendOne.</desc>
</field>
<field>
<name>colorWriteAlpha</name>
<desc>Enables alpha channel writes.  The default is true.</desc>
</field>
<field>
<name>colorWriteBlue</name>
<desc>Enables blue channel writes.  The default is true.</desc>
</field>
<field>
<name>colorWriteDefined</name>
<desc>Set to true if the color write state is not all defaults.</desc>
</field>
<field>
<name>colorWriteGreen</name>
<desc>Enables green channel writes.  The default is true.</desc>
</field>
<field>
<name>colorWriteRed</name>
<desc>Enables red channel writes.  The default is true.</desc>
</field>
<field>
<name>cullDefined</name>
<desc>Set to true if the culling state is not all defaults.</desc>
</field>
<field>
<name>cullMode</name>
<desc>Defines how back facing triangles are culled if at all.  The default is GFXCullCCW.</desc>
</field>
<field>
<name>ffLighting</name>
<desc>Enables fixed function lighting when rendering without a shader on geometry with vertex normals.  The default is false.</desc>
</field>
<field>
<name>samplersDefined</name>
<desc>Set to true if the sampler states are not all defaults.</desc>
</field>
<field>
<name>samplerStates</name>
<desc>The array of texture sampler states.
@note Not all graphics devices support 16 samplers.  In general all systems support 4 samplers with most modern cards doing 8.</desc>
</field>
<field>
<name>separateAlphaBlendDefined</name>
<desc>Set to true if the seperate alpha blend state is not all defaults.</desc>
</field>
<field>
<name>separateAlphaBlendDest</name>
<desc>The destination blend state.  The default is GFXBlendZero.</desc>
</field>
<field>
<name>separateAlphaBlendEnable</name>
<desc>Enables the separate blend mode for the alpha channel.  The default is false.</desc>
</field>
<field>
<name>separateAlphaBlendOp</name>
<desc>The arithmetic operation applied to separate alpha blending.  The default is GFXBlendOpAdd.</desc>
</field>
<field>
<name>separateAlphaBlendSrc</name>
<desc>The source blend state.  The default is GFXBlendOne.</desc>
</field>
<field>
<name>stencilDefined</name>
<desc>Set to true if the stencil state is not all defaults.</desc>
</field>
<field>
<name>stencilEnable</name>
<desc>Enables stenciling.  The default is false.</desc>
</field>
<field>
<name>stencilFailOp</name>
<desc>The stencil operation to perform if the stencil test fails.  The default is GFXStencilOpKeep.</desc>
</field>
<field>
<name>stencilFunc</name>
<desc>The comparison function to test the reference value to a stencil buffer entry.  The default is GFXCmpNever.</desc>
</field>
<field>
<name>stencilMask</name>
<desc>The mask applied to the reference value and each stencil buffer entry to determine the significant bits for the stencil test. The default is 0xFFFFFFFF.</desc>
</field>
<field>
<name>stencilPassOp</name>
<desc>The stencil operation to perform if both the stencil and the depth tests pass.  The default is GFXStencilOpKeep.</desc>
</field>
<field>
<name>stencilRef</name>
<desc>The reference value for the stencil test.  The default is zero.</desc>
</field>
<field>
<name>stencilWriteMask</name>
<desc>The write mask applied to values written into the stencil buffer. The default is 0xFFFFFFFF.</desc>
</field>
<field>
<name>stencilZFailOp</name>
<desc>The stencil operation to perform if the stencil test passes and the depth test fails.  The default is GFXStencilOpKeep.</desc>
</field>
<field>
<name>textureFactor</name>
<desc>The color used for multiple-texture blending with the GFXTATFactor texture-blending argument or the GFXTOPBlendFactorAlpha texture-blending operation.  The default is opaque white (255, 255, 255, 255).</desc>
</field>
<field>
<name>vertexColorEnable</name>
<desc>Enables fixed function vertex coloring when rendering without a shader.  The default is false.</desc>
</field>
<field>
<name>zBias</name>
<desc>A floating-point bias used when comparing depth values.  The default is zero.</desc>
</field>
<field>
<name>zDefined</name>
<desc>Set to true if the depth state is not all defaults.</desc>
</field>
<field>
<name>zEnable</name>
<desc>Enables z-buffer reads.  The default is true.</desc>
</field>
<field>
<name>zFunc</name>
<desc>The depth comparision function which a pixel must pass to be written to the z-buffer.  The default is GFXCmpLessEqual.</desc>
</field>
<field>
<name>zSlopeBias</name>
<desc>An additional floating-point bias based on the maximum depth slop of the triangle being rendered.  The default is zero.</desc>
</field>
<field>
<name>zWriteEnable</name>
<desc>Enables z-buffer writes.  The default is true.</desc>
</field>
</class>
<class>
<name>GFXStateBlockDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GhostAlwaysObjectEvent</name>
</class>
<class>
<name>GhostAlwaysObjectEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GhostAlwaysSet</name>
<base>SimSet</base>
</class>
<class>
<name>Gizmo</name>
<base>SimObject</base>
</class>
<class>
<name>GizmoClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GizmoProfile</name>
<base>SimObject</base>
<field>
<name>alignment</name>
<desc>GizmoAlignment alignment</desc>
</field>
<field>
<name>allowSnapRotations</name>
<desc>bool allowSnapRotations</desc>
</field>
<field>
<name>allowSnapScale</name>
<desc>bool allowSnapScale</desc>
</field>
<field>
<name>flags</name>
<desc>int flags</desc>
</field>
<field>
<name>gridColor</name>
<desc>ColorI gridColor</desc>
</field>
<field>
<name>gridSize</name>
<desc>Point3F gridSize</desc>
</field>
<field>
<name>mode</name>
<desc>GizmoMode mode</desc>
</field>
<field>
<name>planeDim</name>
<desc>float planeDim</desc>
</field>
<field>
<name>renderInfoText</name>
<desc>bool renderInfoText</desc>
</field>
<field>
<name>renderPlane</name>
<desc>bool renderPlane</desc>
</field>
<field>
<name>renderPlaneHashes</name>
<desc>bool renderPlaneHashes</desc>
</field>
<field>
<name>renderSolid</name>
<desc>bool renderSolid</desc>
</field>
<field>
<name>renderWhenUsed</name>
<desc>bool renderWhenUsed</desc>
</field>
<field>
<name>rotateScalar</name>
<desc>float rotateScalar</desc>
</field>
<field>
<name>rotationSnap</name>
<desc>float rotationSnap</desc>
</field>
<field>
<name>scaleScalar</name>
<desc>float scaleScalar</desc>
</field>
<field>
<name>scaleSnap</name>
<desc>float scaleSnap</desc>
</field>
<field>
<name>screenLength</name>
<desc>int screenLength</desc>
</field>
<field>
<name>snapToGrid</name>
<desc>bool snapToGrid</desc>
</field>
</class>
<class>
<name>GizmoProfileClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GlobalActionMap</name>
<base>ActionMap</base>
</class>
<class>
<name>GroundCover</name>
<base>SceneObject</base>
<field>
<name>billboardUVs</name>
<desc>Subset material UV coordinates for this cover billboard.</desc>
</field>
<field>
<name>clumpExponent</name>
<desc>An exponent used to bias between the minimum and maximum clump counts for a particular clump.</desc>
</field>
<field>
<name>clumpRadius</name>
<desc>The maximum clump radius.</desc>
</field>
<field>
<name>dissolveRadius</name>
<desc>This is less than or equal to radius and defines when fading of cover elements begins.</desc>
</field>
<field>
<name>gridSize</name>
<desc>The number of cells per axis in the grid.</desc>
</field>
<field>
<name>invertLayer</name>
<desc>Indicates that the terrain material index given in 'layer' is an exclusion mask.</desc>
</field>
<field>
<name>layer</name>
<desc>Terrain material name to limit coverage to, or blank to not limit.</desc>
</field>
<field>
<name>lockFrustum</name>
<desc>Debug parameter for locking the culling frustum which will freeze the cover generation.</desc>
</field>
<field>
<name>Material</name>
<desc>Material used by all GroundCover segments.</desc>
</field>
<field>
<name>maxBillboardTiltAngle</name>
<desc>The maximum amout of degrees the billboard will tilt down to match the camera.</desc>
</field>
<field>
<name>maxClumpCount</name>
<desc>The maximum amount of elements in a clump.</desc>
</field>
<field>
<name>maxElements</name>
<desc>The maximum amount of cover elements to include in the grid at any one time.</desc>
</field>
<field>
<name>maxElevation</name>
<desc>The maximum world space elevation for placement.</desc>
</field>
<field>
<name>maxSlope</name>
<desc>The maximum slope angle in degrees for placement.</desc>
</field>
<field>
<name>minClumpCount</name>
<desc>The minimum amount of elements in a clump.</desc>
</field>
<field>
<name>minElevation</name>
<desc>The minimum world space elevation for placement.</desc>
</field>
<field>
<name>noBillboards</name>
<desc>Debug parameter for turning off billboard rendering.</desc>
</field>
<field>
<name>noShapes</name>
<desc>Debug parameter for turning off shape rendering.</desc>
</field>
<field>
<name>probability</name>
<desc>The probability of one cover type verses another (relative to all cover types).</desc>
</field>
<field>
<name>radius</name>
<desc>Outer generation radius from the current camera position.</desc>
</field>
<field>
<name>reflectScale</name>
<desc>Scales the various culling radii when rendering a reflection. Typically for water.</desc>
</field>
<field>
<name>renderCells</name>
<desc>Debug parameter for displaying the grid cells.</desc>
</field>
<field>
<name>seed</name>
<desc>This RNG seed is saved and sent to clients for generating the same cover.</desc>
</field>
<field>
<name>shapeCullRadius</name>
<desc>This is the distance at which DTS elements are  completely culled out.</desc>
</field>
<field>
<name>shapeFilename</name>
<desc>The cover shape filename. [Optional]</desc>
</field>
<field>
<name>sizeExponent</name>
<desc>An exponent used to bias between the minimum and maximum random sizes.</desc>
</field>
<field>
<name>sizeMax</name>
<desc>The maximum random size of this cover type.</desc>
</field>
<field>
<name>sizeMin</name>
<desc>The minimum random size for each cover type.</desc>
</field>
<field>
<name>windDirection</name>
<desc>The direction of the wind.</desc>
</field>
<field>
<name>windGustFrequency</name>
<desc>Controls how often the wind gust peaks per second.</desc>
</field>
<field>
<name>windGustLength</name>
<desc>The length in meters between peaks in the wind gust.</desc>
</field>
<field>
<name>windGustStrength</name>
<desc>The maximum distance in meters that the peak wind  gust will displace an element.</desc>
</field>
<field>
<name>windScale</name>
<desc>The wind effect scale.</desc>
</field>
<field>
<name>windTurbulenceFrequency</name>
<desc>Controls the overall rapidity of the wind turbulence.</desc>
</field>
<field>
<name>windTurbulenceStrength</name>
<desc>The maximum distance in meters that the turbulence can displace a ground cover element.</desc>
</field>
<field>
<name>zOffset</name>
<desc>Offset along the Z axis to render the ground cover.</desc>
</field>
</class>
<class>
<name>GroundCoverClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GroundPlane</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
<args>()</args>
<desc>Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply. This will transmit material and other fields to client objects.</desc>
</method>
<field>
<name>Material</name>
<desc>Name of Material used to render %GroundPlane's surface.</desc>
</field>
<field>
<name>scaleU</name>
<desc>Scale of texture repeat in the U direction.</desc>
</field>
<field>
<name>scaleV</name>
<desc>Scale of texture repeat in the V direction.</desc>
</field>
<field>
<name>squareSize</name>
<desc>Square size in meters to which %GroundPlane subdivides its geometry.</desc>
</field>
</class>
<class>
<name>GroundPlaneClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiArrayCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiArrayCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiAutoScrollCtrl</name>
<base>GuiTickCtrl</base>
<method>
<name>reset</name>
<args>()</args>
<desc>Reset scrolling.</desc>
</method>
<field>
<name>childBorder</name>
<desc>Padding to put around child control (in pixels).</desc>
</field>
<field>
<name>isLooping</name>
<desc>If true, the scrolling will reset to the beginning once completing a cycle.</desc>
</field>
<field>
<name>onComplete()</name>
<desc>Called when the child control has been scrolled in entirety.</desc>
</field>
<field>
<name>onReset()</name>
<desc>Called when the child control is reset to its initial position and the cycle starts again.</desc>
</field>
<field>
<name>onStart()</name>
<desc>Called when the control starts to scroll.</desc>
</field>
<field>
<name>onTick()</name>
<desc>Called every 32ms on the control.</desc>
</field>
<field>
<name>resetDelay</name>
<desc>Seconds to wait after scrolling completes before resetting and starting over.

@note Only takes effect if #isLooping is true.</desc>
</field>
<field>
<name>scrollDirection</name>
<desc>Direction in which the child control is moved.</desc>
</field>
<field>
<name>scrollOutOfSight</name>
<desc>If true, the child control will be completely scrolled out of sight; otherwise it will only scroll until the other end becomes visible.</desc>
</field>
<field>
<name>scrollSpeed</name>
<desc>Scrolling speed in pixels per second.</desc>
</field>
<field>
<name>startDelay</name>
<desc>Seconds to wait before starting to scroll.</desc>
</field>
</class>
<class>
<name>GuiAutoScrollCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiBackgroundCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiBackgroundCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiBitmapBorderCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiBitmapBorderCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiBitmapButtonCtrl</name>
<base>GuiButtonCtrl</base>
<method>
<name>setBitmap</name>
<args>( string path )</args>
<desc>Set the bitmap to show on the button.
@param path Path to the texture file in any of the supported formats.</desc>
</method>
<field>
<name>autoFitExtents</name>
<desc>If true, the control's extents will be set to match the bitmap's extents when setting the bitmap.
The bitmap extents will always be taken from the default/normal bitmap (in case the extents of the various bitmaps do not match up.)</desc>
</field>
<field>
<name>bitmap</name>
<desc>Texture file to display on this button.
If useStates is false, this will be the file that renders on the control.  Otherwise, this will specify the default texture name to which the various state and modifier suffixes are appended to find the per-state and per-modifier (if enabled) textures.</desc>
</field>
<field>
<name>bitmapMode</name>
<desc>Behavior for fitting the bitmap to the control extents.
If set to 'Stretched', the bitmap will be stretched both verticall and horizontally to fit inside the control's extents.

If set to 'Centered', the bitmap will stay at its original resolution centered in the control's rectangle (getting clipped if the control is smaller than the texture).</desc>
</field>
<field>
<name>onAltClick()</name>
<desc>Called when per-modifier functionality is enabled and the user clicks on the button with the ALT key pressed.
@ref guibitmapbutton_modifiers</desc>
</field>
<field>
<name>onCtrlClick()</name>
<desc>Called when per-modifier functionality is enabled and the user clicks on the button with the CTRL key pressed.
@ref guibitmapbutton_modifiers</desc>
</field>
<field>
<name>onDefaultClick()</name>
<desc>Called when per-modifier functionality is enabled and the user clicks on the button without any modifier pressed.
@ref guibitmapbutton_modifiers</desc>
</field>
<field>
<name>onShiftClick()</name>
<desc>Called when per-modifier functionality is enabled and the user clicks on the button with the SHIFT key pressed.
@ref guibitmapbutton_modifiers</desc>
</field>
<field>
<name>useModifiers</name>
<desc>If true, per-modifier button functionality is enabled.
@ref guibitmapbutton_modifiers</desc>
</field>
<field>
<name>useStates</name>
<desc>If true, per-mouse state button functionality is enabled.
Defaults to true.

If you do not use per-state images on this button set this to false to speed up the loading process by inhibiting searches for the individual images.</desc>
</field>
</class>
<class>
<name>GuiBitmapButtonCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiBitmapButtonTextCtrl</name>
<base>GuiBitmapButtonCtrl</base>
</class>
<class>
<name>GuiBitmapButtonTextCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiBitmapCtrl</name>
<base>GuiControl</base>
<method>
<name>setBitmap</name>
<args>( String filename | String filename, bool resize )</args>
<desc>Assign an image to the control.

@hide</desc>
</method>
<method>
<name>setValue</name>
<args>( int x, int y )</args>
<desc>Set the offset of the bitmap within the control.
@param x The x-axis offset of the image.
@param y The y-axis offset of the image.</desc>
</method>
<field>
<name>bitmap</name>
<desc>The bitmap file to display in the control.</desc>
</field>
<field>
<name>wrap</name>
<desc>If true, the bitmap is tiled inside the control rather than stretched to fit.</desc>
</field>
</class>
<class>
<name>GuiBitmapCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiBorderButtonCtrl</name>
<base>GuiButtonBaseCtrl</base>
</class>
<class>
<name>GuiBorderButtonCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiBubbleTextCtrl</name>
<base>GuiTextCtrl</base>
</class>
<class>
<name>GuiBubbleTextCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiButtonBaseCtrl</name>
<base>GuiControl</base>
<method>
<name>getText</name>
<args>()</args>
<desc>Get the text display on the button's label (if any).

@return The button's label.</desc>
</method>
<method>
<name>performClick</name>
<args>()</args>
<desc>Simulate a click on the button.
This method will trigger the button's action just as if the button had been pressed by the user.</desc>
</method>
<method>
<name>resetState</name>
<args>()</args>
<desc>Reset the mousing state of the button.

This method should not generally be called.</desc>
</method>
<method>
<name>setStateOn</name>
<args>( bool isOn=true )</args>
<desc>For toggle or radio buttons, set whether the button is currently activated or not.  For radio buttons, toggling a button on will toggle all other radio buttons in its group to off.

@param isOn If true, the button will be toggled on (if not already); if false, it will be toggled off.

@note Toggling the state of a button with this method will &lt;em&gt;not&lt;/em&gt; not trigger the action associated with the button.  To do that, use performClick().</desc>
</method>
<method>
<name>setText</name>
<args>( string text )</args>
<desc>Set the text displayed on the button's label.
@param The text to display as the button's text label.
@note Not all buttons render text labels.

@see getText
@see setTextID</desc>
</method>
<method>
<name>setTextID</name>
<args>( string id )</args>
<desc>Set the text displayed on the button's label using a string from the string table assigned to the control.

@param id Name of the variable that contains the integer string ID.  Used to look up string in table.

@note Not all buttons render text labels.

@see setText
@see getText
@see GuiControl::langTableMod
@see LangTable

@ref Gui_i18n</desc>
</method>
<field>
<name>buttonType</name>
<desc>Button behavior type.</desc>
</field>
<field>
<name>groupNum</name>
<desc>Radio button toggle group number.  All radio buttons that are assigned the same #groupNum and that are parented to the same control will synchronize their toggle state, i.e. if one radio button is toggled on all other radio buttons in its group will be toggled off.

The default group is -1.</desc>
</field>
<field>
<name>onClick()</name>
<desc>Called when the primary action of the button is triggered (e.g. by a left mouse click).</desc>
</field>
<field>
<name>onDoubleClick()</name>
<desc>Called when the left mouse button is double-clicked on the button.</desc>
</field>
<field>
<name>onMouseDown()</name>
<desc>If #useMouseEvents is true, this is called when the left mouse button is pressed on an (active) button.</desc>
</field>
<field>
<name>onMouseDragged()</name>
<desc>If #useMouseEvents is true, this is called when a left mouse button drag is detected, i.e. when the user pressed the left mouse button on the control and then moves the mouse over a certain distance threshold with the mouse button still pressed.</desc>
</field>
<field>
<name>onMouseEnter()</name>
<desc>If #useMouseEvents is true, this is called when the mouse cursor moves over the button (only if the button is the front-most visible control, though).</desc>
</field>
<field>
<name>onMouseLeave()</name>
<desc>If #useMouseEvents is true, this is called when the mouse cursor moves off the button (only if the button had previously received an onMouseEvent() event).</desc>
</field>
<field>
<name>onMouseUp()</name>
<desc>If #useMouseEvents is true, this is called when the left mouse button is release over an (active) button.

@note To trigger actions, better use onClick() since onMouseUp() will also be called when the mouse was not originally pressed on the button.</desc>
</field>
<field>
<name>onRightClick()</name>
<desc>Called when the right mouse button is clicked on the button.</desc>
</field>
<field>
<name>text</name>
<desc>Text label to display on button (if button class supports text labels).</desc>
</field>
<field>
<name>textID</name>
<desc>ID of string in string table to use for text label on button.

@see setTextID
@see GuiControl::langTableMod
@see LangTable</desc>
</field>
<field>
<name>useMouseEvents</name>
<desc>If true, mouse events will be passed on to script.  Default is false.</desc>
</field>
</class>
<class>
<name>GuiButtonBaseCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiButtonCtrl</name>
<base>GuiButtonBaseCtrl</base>
</class>
<class>
<name>GuiButtonCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiCanvas</name>
<base>GuiControl</base>
<method>
<name>clientToScreen</name>
<args>( Point2I coordinate )</args>
<desc>Translate a coordinate from canvas window-space to screen-space.
@param coordinate The coordinate in window-space.
@return The given coordinate translated to screen-space.</desc>
</method>
<method>
<name>cursorOff</name>
<args>()</args>
<desc>@brief Turns on the mouse off.

@tsexample
Canvas.cursorOff();
@endtsexample</desc>
</method>
<method>
<name>cursorOn</name>
<args>()</args>
<desc>@brief Turns on the mouse cursor.

@tsexample
Canvas.cursorOn();
@endtsexample</desc>
</method>
<method>
<name>getContent</name>
<args>()</args>
<desc>@brief Get the GuiControl which is being used as the content.

@tsexample
Canvas.getContent();
@endtsexample

@return ID of current content control</desc>
</method>
<method>
<name>getCursorPos</name>
<args>()</args>
<desc>@brief Get the current position of the cursor.

@param param Description

@tsexample
%cursorPos = Canvas.getCursorPos();
@endtsexample

@return Screen coordinates of mouse cursor, in format "X Y"</desc>
</method>
<method>
<name>getExtent</name>
<args>()</args>
<desc>@brief Returns the dimensions of the canvas

@tsexample
%extent = Canvas.getExtent();
@endtsexample

@return Width and height of canvas. Formatted as numerical values in a single string "# #"</desc>
</method>
<method>
<name>getMode</name>
<args>( int modeId )</args>
<desc>@brief Gets information on the specified mode of this device.

@param modeId Index of the mode to get data from.
@return A video mode string given an adapter and mode index.

@see GuiCanvas::getVideoMode()</desc>
</method>
<method>
<name>getModeCount</name>
<args>()</args>
<desc>@brief Gets the number of modes available on this device.

@param param Description

@tsexample
%modeCount = Canvas.getModeCount()
@endtsexample

@return The number of video modes supported by the device</desc>
</method>
<method>
<name>getMouseControl</name>
<args>()</args>
<desc>@brief Gets the gui control under the mouse.

@tsexample
%underMouse = Canvas.getMouseControl();
@endtsexample

@return ID of the gui control, if one was found. NULL otherwise</desc>
</method>
<method>
<name>getVideoMode</name>
<args>()</args>
<desc>@brief Gets the current screen mode as a string.

The return string will contain 5 values (width, height, fullscreen, bitdepth, refreshRate). You will need to parse out each one for individual use.

@tsexample
%screenWidth = getWord(Canvas.getVideoMode(), 0);
%screenHeight = getWord(Canvas.getVideoMode(), 1);
%isFullscreen = getWord(Canvas.getVideoMode(), 2);
%bitdepth = getWord(Canvas.getVideoMode(), 3);
%refreshRate = getWord(Canvas.getVideoMode(), 4);
@endtsexample

@return String formatted with screen width, screen height, screen mode, bit depth, and refresh rate.</desc>
</method>
<method>
<name>getWindowPosition</name>
<args>()</args>
<desc>Get the current position of the platform window associated with the canvas.
@return The window position of the canvas in screen-space.</desc>
</method>
<method>
<name>hideCursor</name>
<args>()</args>
<desc>@brief Disable rendering of the cursor.

@tsexample
Canvas.hideCursor();
@endtsexample</desc>
</method>
<method>
<name>isCursorOn</name>
<args>()</args>
<desc>@brief Determines if mouse cursor is enabled.

@tsexample
// Is cursor on?
if(Canvas.isCursorOn())
^echo("Canvas cursor is on");
@endtsexample

@return Returns true if the cursor is on.</desc>
</method>
<method>
<name>isCursorShown</name>
<args>()</args>
<desc>@brief Determines if mouse cursor is rendering.

@tsexample
// Is cursor rendering?
if(Canvas.isCursorShown())
^echo("Canvas cursor is rendering");
@endtsexample

@return Returns true if the cursor is rendering.</desc>
</method>
<method>
<name>isFullscreen</name>
<args>()</args>
<desc>Is this canvas currently fullscreen?</desc>
</method>
<method>
<name>isMaximized</name>
<args>()</args>
</method>
<method>
<name>isMinimized</name>
<args>()</args>
</method>
<method>
<name>maximizeWindow</name>
<args>()</args>
<desc>maximize this canvas' window.</desc>
</method>
<method>
<name>minimizeWindow</name>
<args>()</args>
<desc>minimize this canvas' window.</desc>
</method>
<method>
<name>popDialog</name>
<args>(GuiControl ctrl=NULL)</args>
<desc>@hide</desc>
</method>
<method>
<name>popLayer</name>
<args>(int layer)</args>
<desc>@hide</desc>
</method>
<method>
<name>pushDialog</name>
<args>(GuiControl ctrl, int layer=0, bool center=false)</args>
<desc>@hide</desc>
</method>
<method>
<name>renderFront</name>
<args>( bool enable )</args>
<desc>@brief This turns on/off front-buffer rendering.

@param enable True if all rendering should be done to the front buffer

@tsexample
Canvas.renderFront(false);
@endtsexample</desc>
</method>
<method>
<name>repaint</name>
<args>()</args>
<desc>@brief Force canvas to redraw.

@tsexample
Canvas.repaint();
@endtsexample</desc>
</method>
<method>
<name>reset</name>
<args>()</args>
<desc>@brief Reset the update regions for the canvas.

@tsexample
Canvas.reset();
@endtsexample</desc>
</method>
<method>
<name>restoreWindow</name>
<args>()</args>
<desc>restore this canvas' window.</desc>
</method>
<method>
<name>screenToClient</name>
<args>( Point2I coordinate )</args>
<desc>Translate a coordinate from screen-space to canvas window-space.
@param coordinate The coordinate in screen-space.
@return The given coordinate translated to window-space.</desc>
</method>
<method>
<name>setContent</name>
<args>( GuiControl ctrl )</args>
<desc>@brief Set the content of the canvas to a specified control.

@param ctrl ID or name of GuiControl to set content to

@tsexample
Canvas.setContent(PlayGui);
@endtsexample</desc>
</method>
<method>
<name>setCursor</name>
<args>( GuiCursor cursor )</args>
<desc>@brief Sets the cursor for the canvas.

@param cursor Name of the GuiCursor to use

@tsexample
Canvas.setCursor("DefaultCursor");
@endtsexample</desc>
</method>
<method>
<name>setCursorPos</name>
<args>(Point2I pos)</args>
<desc>@hide</desc>
</method>
<method>
<name>setFocus</name>
<args>()</args>
<desc>Claim OS input focus for this canvas' window.</desc>
</method>
<method>
<name>setVideoMode</name>
<args>(int width, int height, bool fullscreen, [int bitDepth], [int refreshRate])</args>
<desc>Change the video mode of this canvas. This method has the side effect of setting the $pref::Video::mode to the new values.

\param width The screen width to set.
\param height The screen height to set.
\param fullscreen Specify true to run fullscreen or false to run in a window
\param bitDepth [optional] The desired bit-depth. Defaults to the current setting. This parameter is ignored if you are running in a window.
\param refreshRate [optional] The desired refresh rate. Defaults to the current setting. This parameter is ignored if you are running in a window\param antialiasLevel [optional] The level of anti-aliasing to apply 0 = none</desc>
</method>
<method>
<name>setWindowPosition</name>
<args>( Point2I position )</args>
<desc>Set the position of the platform window associated with the canvas.
@param position The new position of the window in screen-space.</desc>
</method>
<method>
<name>setWindowTitle</name>
<args>( string newTitle )</args>
<desc>@brief Change the title of the OS window.

@param newTitle String containing the new name

@tsexample
Canvas.setWindowTitle("Documentation Rocks!");
@endtsexample</desc>
</method>
<method>
<name>showCursor</name>
<args>()</args>
<desc>@brief Enable rendering of the cursor.

@tsexample
Canvas.showCursor();
@endtsexample</desc>
</method>
<method>
<name>toggleFullscreen</name>
<args>()</args>
<desc>@brief toggle canvas from fullscreen to windowed mode or back.

@tsexample
// If we are in windowed mode, the following will put is in fullscreen
Canvas.toggleFullscreen();@endtsexample</desc>
</method>
<field>
<name>numFences</name>
<desc>The number of GFX fences to use.</desc>
</field>
</class>
<class>
<name>GuiCanvasClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiCheckBoxCtrl</name>
<base>GuiButtonBaseCtrl</base>
<method>
<name>isStateOn</name>
<args>()</args>
<desc>Test whether the checkbox is currently checked.
@return True if the checkbox is currently ticked, false otherwise.</desc>
</method>
<method>
<name>setStateOn</name>
<args>( bool newState )</args>
<desc>Set whether the checkbox is ticked or not.
@param newState If true the box will be checked, if false, it will be unchecked.

@note This method will @b not trigger the command associated with the control.  To toggle the checkbox state as if the user had clicked the control, use performClick().</desc>
</method>
</class>
<class>
<name>GuiCheckBoxCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiChunkedBitmapCtrl</name>
<base>GuiControl</base>
<method>
<name>setBitmap</name>
<args>( string filename )</args>
<desc>@brief Set the image rendered in this control.

@param filename The image name you want to set
@tsexample
ChunkedBitmap.setBitmap("images/background.png");@endtsexample</desc>
</method>
<field>
<name>bitmap</name>
<desc>This is the bitmap to render to the control.</desc>
</field>
<field>
<name>tile</name>
<desc>This is no longer in use</desc>
</field>
<field>
<name>useVariable</name>
<desc>This decides whether to use the "bitmap" file or a bitmap stored in "variable"</desc>
</field>
</class>
<class>
<name>GuiChunkedBitmapCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiClockHud</name>
<base>GuiControl</base>
<method>
<name>getTime</name>
<args>()</args>
<desc>Returns the current time, in seconds.
@return timeInseconds Current time, in seconds
@tsexample
// Get the current time from the GuiClockHud control
%timeInSeconds = %guiClockHud.getTime();
@endtsexample</desc>
</method>
<method>
<name>setTime</name>
<args>( float timeInSeconds=60 )</args>
<desc>Sets the current base time for the clock.
@param timeInSeconds Time to set the clock, in seconds (IE: 00:02 would be 120)
@tsexample
// Define the time, in seconds
%timeInSeconds = 120;

// Change the time on the GuiClockHud control
%guiClockHud.setTime(%timeInSeconds);
@endtsexample</desc>
</method>
<field>
<name>fillColor</name>
<desc>Standard color for the background of the control.</desc>
</field>
<field>
<name>frameColor</name>
<desc>Color for the control's frame.</desc>
</field>
<field>
<name>showFill</name>
<desc>If true, draws a background color behind the control.</desc>
</field>
<field>
<name>showFrame</name>
<desc>If true, draws a frame around the control.</desc>
</field>
<field>
<name>textColor</name>
<desc>Color for the text on this control.</desc>
</field>
</class>
<class>
<name>GuiClockHudClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiColorPickerCtrl</name>
<base>GuiControl</base>
<method>
<name>getSelectorPos</name>
<desc>Gets the current position of the selector</desc>
</method>
<method>
<name>setSelectorPos</name>
<desc>Sets the current position of the selector</desc>
</method>
<method>
<name>updateColor</name>
<desc>Forces update of pick color</desc>
</method>
<field>
<name>actionOnMove</name>
<desc>bool actionOnMove</desc>
</field>
<field>
<name>baseColor</name>
<desc>ColorF baseColor</desc>
</field>
<field>
<name>displayMode</name>
<desc>GuiColorPickMode displayMode</desc>
</field>
<field>
<name>pickColor</name>
<desc>ColorF pickColor</desc>
</field>
<field>
<name>selectorGap</name>
<desc>int selectorGap</desc>
</field>
<field>
<name>showReticle</name>
<desc>bool showReticle</desc>
</field>
</class>
<class>
<name>GuiColorPickerCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiConsole</name>
<base>GuiArrayCtrl</base>
</class>
<class>
<name>GuiConsoleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiConsoleEditCtrl</name>
<base>GuiTextEditCtrl</base>
<field>
<name>useSiblingScroller</name>
<desc>bool useSiblingScroller</desc>
</field>
</class>
<class>
<name>GuiConsoleEditCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiConsoleTextCtrl</name>
<base>GuiControl</base>
<field>
<name>expression</name>
<desc>string expression</desc>
</field>
</class>
<class>
<name>GuiConsoleTextCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiContainer</name>
<base>GuiControl</base>
<field>
<name>anchorBottom</name>
<desc>bool anchorBottom</desc>
</field>
<field>
<name>anchorLeft</name>
<desc>bool anchorLeft</desc>
</field>
<field>
<name>anchorRight</name>
<desc>bool anchorRight</desc>
</field>
<field>
<name>anchorTop</name>
<desc>bool anchorTop</desc>
</field>
<field>
<name>docking</name>
<desc>GuiDockingType docking</desc>
</field>
<field>
<name>margin</name>
<desc>RectSpacingI margin</desc>
</field>
<field>
<name>padding</name>
<desc>RectSpacingI padding</desc>
</field>
</class>
<class>
<name>GuiContainerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiControl</name>
<base>SimGroup</base>
<method>
<name>addGuiControl</name>
<args>( GuiControl control )</args>
<desc>Add the given control as a child to this control.
This is synonymous to calling SimGroup::addObject.
@param control The control to add as a child.
@note The control will retain its current position and size.
@see SimGroup::addObject
@ref GuiControl_Hierarchy</desc>
</method>
<method>
<name>clearFirstResponder</name>
<args>( bool ignored=false )</args>
<desc>Clear this control from being the first responder in its hierarchy chain.
@param ignored Ignored.  Supported for backwards-compatibility.</desc>
</method>
<method>
<name>controlIsChild</name>
<args>( GuiControl control )</args>
<desc>Test whether the given control is a direct or indirect child to this control.
@param control The potential child control.
@return True if the given control is a direct or indirect child to this control.</desc>
</method>
<method>
<name>findHitControl</name>
<args>( int x, int y )</args>
<desc>Find the topmost child control located at the given coordinates.
@note Only children that are both visible and have the 'modal' flag set in their profile will be considered in the search.@param x The X coordinate in the control's own coordinate space.
@param y The Y coordinate in the control's own coordinate space.
@return The topmost child control at the given coordintes or the control on which the method was called if no matching child could be found.
@see GuiControlProfile::modal
@see findHitControls</desc>
</method>
<method>
<name>findHitControls</name>
<args>( int x, int y, int width, int height )</args>
<desc>Find all visible child controls that intersect with the given rectangle.
@note Invisible child controls will not be included in the search.
@param x The X coordinate of the rectangle's upper left corner in the control's own coordinate space.
@param y The Y coordinate of the rectangle's upper left corner in the control's own coordinate space.
@param width The width of the search rectangle in pixels.
@param height The height of the search rectangle in pixels.
@return A space-separated list of the IDs of all visible control objects intersecting the given rectangle.

@tsexample
// Lock all controls in the rectangle at x=10 and y=10 and the extent width=100 and height=100.
foreach$( %ctrl in %this.findHitControls( 10, 10, 100, 100 ) )
%ctrl.setLocked( true );
@endtsexample
@see findHitControl</desc>
</method>
<method>
<name>getAspect</name>
<args>()</args>
<desc>Get the aspect ratio of the control's extents.
@return The width of the control divided by its height.
@see getExtent</desc>
</method>
<method>
<name>getCenter</name>
<args>()</args>
<desc>Get the coordinate of the control's center point relative to its parent.
@return The coordinate of the control's center point in parent-relative coordinates.</desc>
</method>
<method>
<name>getExtent</name>
<args>()</args>
<desc>Get the width and height of the control.
@return A point structure containing the width of the control in x and the height in y.</desc>
</method>
<method>
<name>getFirstResponder</name>
<args>()</args>
<desc>Get the first responder set on this GuiControl tree.
@return The first responder set on the control's subtree.
@see isFirstResponder
@see makeFirstResponder
@see setFirstResponder
@ref GuiControl_FirstResponders</desc>
</method>
<method>
<name>getGlobalCenter</name>
<args>()</args>
<desc>Get the coordinate of the control's center point in coordinates relative to the root control in its control hierarchy.
@Return the center coordinate of the control in root-relative coordinates.</desc>
</method>
<method>
<name>getGlobalPosition</name>
<args>()</args>
<desc>Get the position of the control relative to the root of the GuiControl hierarchy it is contained in.
@return The control's current position in root-relative coordinates.</desc>
</method>
<method>
<name>getMinExtent</name>
<args>()</args>
<desc>Get the minimum allowed size of the control.
@return The minimum size to which the control can be shrunk.
@see minExtent</desc>
</method>
<method>
<name>getParent</name>
<args>()</args>
<desc>Get the immediate parent control of the control.
@return The immediate parent GuiControl or 0 if the control is not parented to a GuiControl.</desc>
</method>
<method>
<name>getPosition</name>
<args>()</args>
<desc>Get the control's current position relative to its parent.
@return The coordinate of the control in its parent's coordinate space.</desc>
</method>
<method>
<name>getRoot</name>
<args>()</args>
<desc>Get the canvas on which the control is placed.
@return The canvas on which the control's hierarchy is currently placed or 0 if the control is not currently placed on a GuiCanvas.
@see GuiControl_Hierarchy</desc>
</method>
<method>
<name>getValue</name>
</method>
<method>
<name>isActive</name>
</method>
<method>
<name>isAwake</name>
<args>()</args>
<desc>Test whether the control is currently awake.
If a control is awake it means that it is part of the GuiControl hierarchy of a GuiCanvas.
@return True if the control is awake.@ref GuiControl_Waking</desc>
</method>
<method>
<name>isFirstResponder</name>
<args>()</args>
<desc>Test whether the control is the current first responder.
@return True if the control is the current first responder.
@see makeFirstResponder
@see setFirstResponder
@ref GuiControl_FirstResponders</desc>
</method>
<method>
<name>isVisible</name>
<args>()</args>
<desc>Test whether the control is currently set to be visible.
@return True if the control is currently set to be visible.@note This method does not tell anything about whether the control is actually visible to the user at the moment.

@ref GuiControl_VisibleActive</desc>
</method>
<method>
<name>makeFirstResponder</name>
<args>(bool isFirst)</args>
</method>
<method>
<name>pointInControl</name>
<args>( int x, int y )</args>
<desc>Test whether the given point lies within the rectangle of the control.
@param x X coordinate of the point in parent-relative coordinates.
@param y Y coordinate of the point in parent-relative coordinates.
@return True if the point is within the control, false if not.
@see getExtent
@see getPosition</desc>
</method>
<method>
<name>resize</name>
<args>( int x, int y, int width, int height )</args>
<desc>Resize and reposition the control using the give coordinates and dimensions.  Child controls will resize according to their layout behaviors.
@param x The new X coordinate of the control in its parent's coordinate space.
@param y The new Y coordinate of the control in its parent's coordinate space.
@param width The new width to which the control should be resized.
@param height The new height to which the control should be resized.</desc>
</method>
<method>
<name>setActive</name>
<args>( bool state=true )</args>
</method>
<method>
<name>setCenter</name>
<args>( int x, int y )</args>
<desc>Set the control's position by its center point.
@param x The X coordinate of the new center point of the control relative to the control's parent.
@param y The Y coordinate of the new center point of the control relative to the control's parent.</desc>
</method>
<method>
<name>setExtent</name>
<args>( Point2I p | int x, int y )</args>
<desc>Set the width and height of the control.

@hide</desc>
</method>
<method>
<name>setFirstResponder</name>
<args>()</args>
<desc>Make this control the current first responder.
@note Only controls with a profile that has canKeyFocus enabled are able to become first responders.
@see GuiControlProfile::canKeyFocus
@see isFirstResponder
@ref GuiControl_FirstResponders</desc>
</method>
<method>
<name>setPosition</name>
<args>( int x, int y )</args>
<desc>Position the control in the local space of the parent control.
@param x The new X coordinate of the control relative to its parent's upper left corner.
@param y The new Y coordinate of the control relative to its parent's upper left corner.</desc>
</method>
<method>
<name>setPositionGlobal</name>
<args>( int x, int y )</args>
<desc>Set position of the control relative to the root of the GuiControl hierarchy it is contained in.
@param x The new X coordinate of the control relative to the root's upper left corner.
@param y The new Y coordinate of the control relative to the root's upper left corner.</desc>
</method>
<method>
<name>setProfile</name>
<args>( GuiControlProfile profile )</args>
<desc>Set the control profile for the control to use.
The profile used by a control determines a great part of its behavior and appearance.
@param profile The new profile the control should use.
@ref GuiControl_Profiles</desc>
</method>
<method>
<name>setValue</name>
<args>( string value )</args>
<desc>Set the value associated with the control.
@param value The new value for the control.</desc>
</method>
<method>
<name>setVisible</name>
<args>( bool state=true )</args>
<desc>Set whether the control is visible or not.
@param state The new visiblity flag state for the control.
@ref GuiControl_VisibleActive</desc>
</method>
<field>
<name>accelerator</name>
<desc>Key combination that triggers the control's primary action when the control is on the canvas.</desc>
</field>
<field>
<name>active</name>
<desc>Whether the control is enabled for user interaction.</desc>
</field>
<field>
<name>altCommand</name>
<desc>Command to execute on the secondary action of the control.

@note Within this script snippet, the control on which the #altCommand is being executed is bound to the global variable $ThisControl.</desc>
</field>
<field>
<name>command</name>
<desc>Command to execute on the primary action of the control.

@note Within this script snippet, the control on which the #command is being executed is bound to the global variable $ThisControl.</desc>
</field>
<field>
<name>extent</name>
<desc>The width and height of the control.</desc>
</field>
<field>
<name>horizSizing</name>
<desc>The horizontal resizing behavior.</desc>
</field>
<field>
<name>hovertime</name>
<desc>Time for mouse to hover over control until tooltip is shown (in milliseconds).</desc>
</field>
<field>
<name>isContainer</name>
<desc>If true, the control may contain child controls.</desc>
</field>
<field>
<name>langTableMod</name>
<desc>Name of string table to use for lookup of internationalized text.</desc>
</field>
<field>
<name>minExtent</name>
<desc>The minimum width and height of the control. The control will not be resized smaller than this.</desc>
</field>
<field>
<name>modal</name>
<desc>@deprecated This member is deprecated, which means that its value is always undefined.</desc>
</field>
<field>
<name>onAction()</name>
<desc>Called when the control's associated action is triggered and no 'command' is defined for the control.
@ref GuiControl_Actions</desc>
</field>
<field>
<name>onActive( bool state )</name>
<desc>Called when the control changes its activeness state, i.e. when going from active to inactive or vice versa.
@param stat The new activeness state.
@see isActive
@see setActive
@ref GuiControl_VisibleActive</desc>
</field>
<field>
<name>onAdd()</name>
<desc>Called when the control object is registered with the system after the control has been created.</desc>
</field>
<field>
<name>onControlDragEnter( GuiControl control, Point2I dropPoint )</name>
<desc>Called when a drag&amp;drop operation through GuiDragAndDropControl has entered the control.  This is only called for topmost visible controls as the GuiDragAndDropControl moves over them.

@param control The payload of the drag operation.
@param dropPoint The point at which the payload would be dropped if it were released now.  Relative to the canvas.</desc>
</field>
<field>
<name>onControlDragExit( GuiControl control, Point2I dropPoint )</name>
<desc>Called when a drag&amp;drop operation through GuiDragAndDropControl has exited the control and moved over a different control.  This is only called for topmost visible controls as the GuiDragAndDropControl moves off of them.

@param control The payload of the drag operation.
@param dropPoint The point at which the payload would be dropped if it were released now.  Relative to the canvas.</desc>
</field>
<field>
<name>onControlDragged( GuiControl control, Point2I dropPoint )</name>
<desc>Called when a drag&amp;drop operation through GuiDragAndDropControl is moving across the control after it has entered it.  This is only called for topmost visible controls as the GuiDragAndDropControl moves across them.

@param control The payload of the drag operation.
@param dropPoint The point at which the payload would be dropped if it were released now.  Relative to the canvas.</desc>
</field>
<field>
<name>onControlDropped( GuiControl control, Point2I dropPoint )</name>
<desc>Called when a drag&amp;drop operation through GuiDragAndDropControl has completed and is dropping its payload onto the control.  This is only called for topmost visible controls as the GuiDragAndDropControl drops its payload on them.

@param control The control that is being dropped onto this control.
@param dropPoint The point at which the control is being dropped.  Relative to the canvas.</desc>
</field>
<field>
<name>onDialogPop()</name>
<desc>Called when the control is removed as a dialog from the canvas.
@see GuiCanvas::popDialog</desc>
</field>
<field>
<name>onDialogPush()</name>
<desc>Called when the control is pushed as a dialog onto the canvas.
@see GuiCanvas::pushDialog</desc>
</field>
<field>
<name>onGainFirstResponder()</name>
<desc>Called when the control gains first responder status on the GuiCanvas.
@see setFirstResponder
@see makeFirstResponder
@see isFirstResponder
@ref GuiControl_FirstResponders</desc>
</field>
<field>
<name>onLoseFirstResponder()</name>
<desc>Called when the control loses first responder status on the GuiCanvas.
@see setFirstResponder
@see makeFirstResponder
@see isFirstResponder
@ref GuiControl_FirstResponders</desc>
</field>
<field>
<name>onRemove()</name>
<desc>Called when the control object is removed from the system before it is deleted.</desc>
</field>
<field>
<name>onSleep()</name>
<desc>Called when the control is put to sleep.
@ref GuiControl_Waking</desc>
</field>
<field>
<name>onVisible( bool state )</name>
<desc>Called when the control changes its visibility state, i.e. when going from visible to invisible or vice versa.
@param state The new visibility state.
@see isVisible
@see setVisible
@ref GuiControl_VisibleActive</desc>
</field>
<field>
<name>onWake()</name>
<desc>Called when the control is woken up.
@ref GuiControl_Waking</desc>
</field>
<field>
<name>position</name>
<desc>The position relative to the parent control.</desc>
</field>
<field>
<name>profile</name>
<desc>The control profile that determines fill styles, font settings, etc.</desc>
</field>
<field>
<name>setFirstResponder</name>
<desc>@deprecated This member is deprecated, which means that its value is always undefined.</desc>
</field>
<field>
<name>tooltip</name>
<desc>String to show in tooltip for this control.</desc>
</field>
<field>
<name>tooltipProfile</name>
<desc>Control profile to use when rendering tooltips for this control.</desc>
</field>
<field>
<name>variable</name>
<desc>Name of the variable to which the value of this control will be synchronized.</desc>
</field>
<field>
<name>vertSizing</name>
<desc>The vertical resizing behavior.</desc>
</field>
<field>
<name>visible</name>
<desc>Whether the control is visible or hidden.</desc>
</field>
</class>
<class>
<name>GuiControlArrayControl</name>
<base>GuiControl</base>
<field>
<name>colCount</name>
<desc>Number of colums in the array.</desc>
</field>
<field>
<name>colSizes</name>
<desc>Size of each individual column.</desc>
</field>
<field>
<name>colSpacing</name>
<desc>Padding to put between columns.</desc>
</field>
<field>
<name>rowSize</name>
<desc>Heigth of a row in the array.</desc>
</field>
<field>
<name>rowSpacing</name>
<desc>Padding to put between rows.</desc>
</field>
</class>
<class>
<name>GuiControlArrayControlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiControlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiControlProfile</name>
<base>SimObject</base>
<method>
<name>getStringWidth</name>
<args>( pString )</args>
</method>
<field>
<name>autoSizeHeight</name>
<desc>Automatically adjust height of control to fit contents.</desc>
</field>
<field>
<name>autoSizeWidth</name>
<desc>Automatically adjust width of control to fit contents.</desc>
</field>
<field>
<name>bevelColorHL</name>
<desc>ColorI bevelColorHL</desc>
</field>
<field>
<name>bevelColorLL</name>
<desc>ColorI bevelColorLL</desc>
</field>
<field>
<name>bitmap</name>
<desc>Texture to use for rendering control.</desc>
</field>
<field>
<name>border</name>
<desc>Border type (0=no border).</desc>
</field>
<field>
<name>borderColor</name>
<desc>Color to draw border with.</desc>
</field>
<field>
<name>borderColorHL</name>
<desc>ColorI borderColorHL</desc>
</field>
<field>
<name>borderColorNA</name>
<desc>ColorI borderColorNA</desc>
</field>
<field>
<name>borderThickness</name>
<desc>Thickness of border in pixels.</desc>
</field>
<field>
<name>canKeyFocus</name>
<desc>Whether the control can have the keyboard focus.</desc>
</field>
<field>
<name>category</name>
<desc>Category under which the profile will appear in the editor.</desc>
</field>
<field>
<name>cursorColor</name>
<desc>Color to use for the text cursor.</desc>
</field>
<field>
<name>fillColor</name>
<desc>ColorI fillColor</desc>
</field>
<field>
<name>fillColorHL</name>
<desc>ColorI fillColorHL</desc>
</field>
<field>
<name>fillColorNA</name>
<desc>ColorI fillColorNA</desc>
</field>
<field>
<name>fillColorSEL</name>
<desc>ColorI fillColorSEL</desc>
</field>
<field>
<name>fontCharset</name>
<desc>GuiFontCharset fontCharset</desc>
</field>
<field>
<name>fontColor</name>
<desc>Font color for normal text (same as fontColors[0]).</desc>
</field>
<field>
<name>fontColorHL</name>
<desc>Font color for highlighted text (same as fontColors[1]).</desc>
</field>
<field>
<name>fontColorLink</name>
<desc>Font color for links in text (same as fontColors[4]).</desc>
</field>
<field>
<name>fontColorLinkHL</name>
<desc>Font color for highlighted links in text (same as fontColors[5]).</desc>
</field>
<field>
<name>fontColorNA</name>
<desc>Font color when control is not active/disabled (same as fontColors[2]).</desc>
</field>
<field>
<name>fontColors</name>
<desc>Font colors to use for different text types/states.</desc>
</field>
<field>
<name>fontColorSEL</name>
<desc>Font color for selected text (same as fontColors[3]).</desc>
</field>
<field>
<name>fontSize</name>
<desc>Font size in points.</desc>
</field>
<field>
<name>fontType</name>
<desc>Name of font family and typeface (e.g. "Arial Bold").</desc>
</field>
<field>
<name>hasBitmapArray</name>
<desc>If true, 'bitmap' is an array of images.</desc>
</field>
<field>
<name>justify</name>
<desc>Horizontal alignment for text.</desc>
</field>
<field>
<name>modal</name>
<desc>bool modal</desc>
</field>
<field>
<name>mouseOverSelected</name>
<desc>bool mouseOverSelected</desc>
</field>
<field>
<name>numbersOnly</name>
<desc>Whether control should only accept numerical data (GuiTextEditCtrl).</desc>
</field>
<field>
<name>opaque</name>
<desc>bool opaque</desc>
</field>
<field>
<name>profileForChildren</name>
<desc>string profileForChildren</desc>
</field>
<field>
<name>returnTab</name>
<desc>Whether to add automatic tab event when return is pressed so focus moves on to next control (GuiTextEditCtrl).</desc>
</field>
<field>
<name>soundButtonDown</name>
<desc>Sound to play when mouse has been pressed on control.</desc>
</field>
<field>
<name>soundButtonOver</name>
<desc>Sound to play when mouse is hovering over control.</desc>
</field>
<field>
<name>tab</name>
<desc>bool tab</desc>
</field>
<field>
<name>textOffset</name>
<desc>Point2I textOffset</desc>
</field>
<field>
<name>yPositionOffset</name>
<desc>int yPositionOffset</desc>
</field>
</class>
<class>
<name>GuiControlProfileClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiConvexEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>dropSelectionAtScreenCenter</name>
</method>
<method>
<name>handleDelete</name>
</method>
<method>
<name>handleDeselect</name>
</method>
<method>
<name>hasSelection</name>
</method>
<method>
<name>hollowSelection</name>
</method>
<method>
<name>recenterSelection</name>
</method>
<method>
<name>selectConvex</name>
<args>( ConvexShape )</args>
</method>
<method>
<name>splitSelectedFace</name>
</method>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>materialName</name>
<desc>string materialName</desc>
</field>
</class>
<class>
<name>GuiConvexEditorCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiCrossHairHud</name>
<base>GuiBitmapCtrl</base>
<field>
<name>damageFillColor</name>
<desc>As the health bar depletes, this color will represent the health loss amount.</desc>
</field>
<field>
<name>damageFrameColor</name>
<desc>Color for the health bar's frame.</desc>
</field>
<field>
<name>damageOffset</name>
<desc>Offset for drawing the damage portion of the health control.</desc>
</field>
<field>
<name>damageRect</name>
<desc>Size for the health bar portion of the control.</desc>
</field>
</class>
<class>
<name>GuiCrossHairHudClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiCursor</name>
<base>SimObject</base>
<field>
<name>bitmapName</name>
<desc>File name of the bitmap for the cursor.</desc>
</field>
<field>
<name>hotSpot</name>
<desc>The location of the cursor's hot spot (which pixel carries the click).</desc>
</field>
<field>
<name>renderOffset</name>
<desc>Offset of the bitmap, where 0 signifies left edge of the bitmap, 1, the right. Similarly for the Y-component.</desc>
</field>
</class>
<class>
<name>GuiCursorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiDataGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>GuiDecalEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteDecalDatablock</name>
<desc>deleteSelectedDecalDatablock( String datablock )</desc>
</method>
<method>
<name>deleteSelectedDecal</name>
<desc>deleteSelectedDecal()</desc>
</method>
<method>
<name>editDecalDetails</name>
<desc>editDecalDetails( S32 )()</desc>
</method>
<method>
<name>getDecalCount</name>
<desc>getDecalCount()</desc>
</method>
<method>
<name>getDecalLookupName</name>
<desc>getDecalLookupName( S32 )()</desc>
</method>
<method>
<name>getDecalTransform</name>
<desc>getDecalTransform()</desc>
</method>
<method>
<name>getMode</name>
<desc>getMode()</desc>
</method>
<method>
<name>getSelectionCount</name>
</method>
<method>
<name>retargetDecalDatablock</name>
</method>
<method>
<name>selectDecal</name>
<desc>selectDecal( S32 )()</desc>
</method>
<method>
<name>setMode</name>
<desc>setMode( String mode )()</desc>
</method>
<field>
<name>currentDecalData</name>
<desc>DecalData currentDecalData</desc>
</field>
</class>
<class>
<name>GuiDecalEditorCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiDecoyCtrl</name>
<base>GuiControl</base>
<field>
<name>isDecoy</name>
<desc>Sets this control to decoy mode</desc>
</field>
</class>
<class>
<name>GuiDecoyCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiDirectoryFileListCtrl</name>
<base>GuiListBoxCtrl</base>
<method>
<name>getSelectedFile</name>
<args>()</args>
<desc>Get the currently selected filename.

@return The filename of the currently selected file</desc>
</method>
<method>
<name>getSelectedFiles</name>
<args>()</args>
<desc>Get the list of selected files.

@return A space separated list of selected files</desc>
</method>
<method>
<name>reload</name>
<args>()</args>
<desc>Update the file list.</desc>
</method>
<method>
<name>setFilter</name>
<args>( string filter )</args>
<desc>Set the file filter.

@param filter Tab-delimited list of file name patterns. Only matched files will be displayed.</desc>
</method>
<method>
<name>setPath</name>
<args>( string path, string filter )</args>
<desc>Set the search path and file filter.

@param path   Path in game directory from which to list files.
@param filter Tab-delimited list of file name patterns. Only matched files will be displayed.</desc>
</method>
<field>
<name>fileFilter</name>
<desc>Tab-delimited list of file name patterns. Only matched files will be displayed.</desc>
</field>
<field>
<name>filePath</name>
<desc>Path in game directory from which to list files.</desc>
</field>
</class>
<class>
<name>GuiDirectoryFileListCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiDragAndDropControl</name>
<base>GuiControl</base>
<method>
<name>startDragging</name>
<args>( int x=0, int y=0 )</args>
<desc>Start the drag operation.

@param offset The offset from the mouse pointer with which the drag control should position itself.</desc>
</method>
<field>
<name>deleteOnMouseUp</name>
<desc>If true, the control deletes itself when the left mouse button is released.

If at this point, the drag&amp;drop control still contains its payload, it will be deleted along with the control.</desc>
</field>
</class>
<class>
<name>GuiDragAndDropControlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiDynamicCtrlArrayControl</name>
<base>GuiControl</base>
<method>
<name>refresh</name>
<args>()</args>
<desc>Recalculates the position and size of this control and all its children.</desc>
</method>
<field>
<name>autoCellSize</name>
<desc>When true, the cell size is set to the widest/tallest child control.</desc>
</field>
<field>
<name>colCount</name>
<desc>Number of columns the child controls have been arranged into. This value is calculated automatically when children are added, removed or resized; writing it directly has no effect.</desc>
</field>
<field>
<name>colSize</name>
<desc>Width of each column. If &lt;i&gt;autoCellSize&lt;/i&gt; is set, this will be calculated automatically from the widest child control</desc>
</field>
<field>
<name>colSpacing</name>
<desc>Spacing between columns</desc>
</field>
<field>
<name>dynamicSize</name>
<desc>If true, the width or height of this control will be automatically calculated based on the number of child controls (width if &lt;i&gt;fillRowFirst&lt;/i&gt; is false, height if &lt;i&gt;fillRowFirst&lt;/i&gt; is true).</desc>
</field>
<field>
<name>fillRowFirst</name>
<desc>Controls whether rows or columns are filled first.

If true, controls are added to the grid left-to-right (to fill a row); then rows are added top-to-bottom as shown below:
&lt;pre&gt;1 2 3 4
5 6 7 8&lt;/pre&gt;
If false, controls are added to the grid top-to-bottom (to fill a column); then columns are added left-to-right as shown below:
&lt;pre&gt;1 3 5 7
2 4 6 8&lt;/pre&gt;</desc>
</field>
<field>
<name>frozen</name>
<desc>When true, the array will not update when new children are added or in response to child resize events. This is useful to prevent unnecessary resizing when adding, removing or resizing a number of child controls.</desc>
</field>
<field>
<name>padding</name>
<desc>Padding around the top, bottom, left, and right of this control. This reduces the area available for child controls.</desc>
</field>
<field>
<name>rowCount</name>
<desc>Number of rows the child controls have been arranged into. This value is calculated automatically when children are added, removed or resized; writing it directly has no effect.</desc>
</field>
<field>
<name>rowSize</name>
<desc>Height of each row. If &lt;i&gt;autoCellSize&lt;/i&gt; is set, this will be calculated automatically from the tallest child control</desc>
</field>
<field>
<name>rowSpacing</name>
<desc>Spacing between rows</desc>
</field>
</class>
<class>
<name>GuiDynamicCtrlArrayControlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiEaseViewCtrl</name>
<base>GuiControl</base>
<field>
<name>axisColor</name>
<desc>ColorF axisColor</desc>
</field>
<field>
<name>ease</name>
<desc>EaseF ease</desc>
</field>
<field>
<name>easeColor</name>
<desc>ColorF easeColor</desc>
</field>
<field>
<name>easeWidth</name>
<desc>float easeWidth</desc>
</field>
</class>
<class>
<name>GuiEaseViewCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiEditCtrl</name>
<base>GuiControl</base>
<method>
<name>addNewCtrl</name>
<args>(GuiControl ctrl)</args>
</method>
<method>
<name>addSelection</name>
<desc>selects a control.</desc>
</method>
<method>
<name>bringToFront</name>
</method>
<method>
<name>clearGuides</name>
<args>( [ int axis ] )</args>
<desc>Clear all currently set guide lines.</desc>
</method>
<method>
<name>clearSelection</name>
<desc>Clear selected controls list.</desc>
</method>
<method>
<name>deleteSelection</name>
<args>()</args>
<desc>Delete the selected controls.</desc>
</method>
<method>
<name>fitIntoParents</name>
<args>( bool width=true, bool height=true )</args>
<desc>Fit selected controls into their parents.</desc>
</method>
<method>
<name>getContentControl</name>
<args>()</args>
<desc>Return the toplevel control edited inside the GUI editor.</desc>
</method>
<method>
<name>getCurrentAddSet</name>
<desc>Returns the set to which new controls will be added</desc>
</method>
<method>
<name>getMouseMode</name>
<args>()</args>
<desc>Return the current mouse mode.</desc>
</method>
<method>
<name>getNumSelected</name>
<args>()</args>
<desc>Return the number of controls currently selected.</desc>
</method>
<method>
<name>getSelection</name>
<args>()</args>
<desc>Gets the set of GUI controls currently selected in the editor.</desc>
</method>
<method>
<name>getSelectionGlobalBounds</name>
<args>()</args>
<desc>Returns global bounds of current selection as vector 'x y width height'.</desc>
</method>
<method>
<name>getTrash</name>
<args>()</args>
<desc>Gets the GUI controls(s) that are currently in the trash.</desc>
</method>
<method>
<name>justify</name>
<args>(int mode)</args>
</method>
<method>
<name>loadSelection</name>
<args>( string fileName=null )</args>
<desc>Load selection from file or clipboard.</desc>
</method>
<method>
<name>moveSelection</name>
<args>(int dx, int dy)</args>
<desc>Move all controls in the selection by (dx,dy) pixels.</desc>
</method>
<method>
<name>pushToBack</name>
</method>
<method>
<name>readGuides</name>
<args>( GuiControl ctrl [, int axis ] )</args>
<desc>Read the guides from the given control.</desc>
</method>
<method>
<name>removeSelection</name>
<desc>deselects a control.</desc>
</method>
<method>
<name>saveSelection</name>
<args>( string fileName=null )</args>
<desc>Save selection to file or clipboard.</desc>
</method>
<method>
<name>select</name>
<args>(GuiControl ctrl)</args>
</method>
<method>
<name>selectAll</name>
<args>()</args>
</method>
<method>
<name>selectChildren</name>
<args>( bool addToSelection=false )</args>
<desc>Select children of currently selected controls.</desc>
</method>
<method>
<name>selectParents</name>
<args>( bool addToSelection=false )</args>
<desc>Select parents of currently selected controls.</desc>
</method>
<method>
<name>setContentControl</name>
<args>( GuiControl ctrl )</args>
<desc>Set the toplevel control to edit in the GUI editor.</desc>
</method>
<method>
<name>setCurrentAddSet</name>
<args>(GuiControl ctrl)</args>
</method>
<method>
<name>setSnapToGrid</name>
<desc>GuiEditCtrl.setSnapToGrid(gridsize)</desc>
</method>
<method>
<name>toggle</name>
<desc>Toggle activation.</desc>
</method>
<method>
<name>writeGuides</name>
<args>( GuiControl ctrl [, int axis ] )</args>
<desc>Write the guides to the given control.</desc>
</method>
<field>
<name>drawBorderLines</name>
<desc>If true, lines will be drawn extending along the edges of selected objects.</desc>
</field>
<field>
<name>drawGuides</name>
<desc>If true, guides will be included in rendering.</desc>
</field>
<field>
<name>fullBoxSelection</name>
<desc>If true, rectangle selection will only select controls fully inside the drag rectangle.</desc>
</field>
<field>
<name>onAddNewCtrl( GuiControl control )</name>
<desc>void onAddNewCtrl( GuiControl control )</desc>
</field>
<field>
<name>onAddNewCtrlSet( SimSet set )</name>
<desc>void onAddNewCtrlSet( SimSet set )</desc>
</field>
<field>
<name>onAddSelected( GuiControl control )</name>
<desc>void onAddSelected( GuiControl control )</desc>
</field>
<field>
<name>onClearSelected()</name>
<desc>void onClearSelected()</desc>
</field>
<field>
<name>onControlInspectPostApply( GuiControl control )</name>
<desc>void onControlInspectPostApply( GuiControl control )</desc>
</field>
<field>
<name>onControlInspectPreApply( GuiControl control )</name>
<desc>void onControlInspectPreApply( GuiControl control )</desc>
</field>
<field>
<name>onDelete()</name>
<desc>void onDelete()</desc>
</field>
<field>
<name>onFitIntoParent( bool width, bool height )</name>
<desc>void onFitIntoParent( bool width, bool height )</desc>
</field>
<field>
<name>onHierarchyChanged()</name>
<desc>void onHierarchyChanged()</desc>
</field>
<field>
<name>onMouseModeChange()</name>
<desc>void onMouseModeChange()</desc>
</field>
<field>
<name>onPostEdit( SimSet selection )</name>
<desc>void onPostEdit( SimSet selection )</desc>
</field>
<field>
<name>onPostSelectionNudged( SimSet selection )</name>
<desc>void onPostSelectionNudged( SimSet selection )</desc>
</field>
<field>
<name>onPreEdit( SimSet selection )</name>
<desc>void onPreEdit( SimSet selection )</desc>
</field>
<field>
<name>onPreSelectionNudged( SimSet selection )</name>
<desc>void onPreSelectionNudged( SimSet selection )</desc>
</field>
<field>
<name>onRemoveSelected( GuiControl control )</name>
<desc>void onRemoveSelected( GuiControl control )</desc>
</field>
<field>
<name>onSelect( GuiControl control )</name>
<desc>void onSelect( GuiControl control )</desc>
</field>
<field>
<name>onSelectionCloned( SimSet selection )</name>
<desc>void onSelectionCloned( SimSet selection )</desc>
</field>
<field>
<name>onSelectionMoved( GuiControl control )</name>
<desc>void onSelectionMoved( GuiControl control )</desc>
</field>
<field>
<name>onSelectionResized( GuiControl control )</name>
<desc>void onSelectionResized( GuiControl control )</desc>
</field>
<field>
<name>onTrashSelection( SimSet selection )</name>
<desc>void onTrashSelection( SimSet selection )</desc>
</field>
<field>
<name>snapSensitivity</name>
<desc>Distance in pixels that edge and center snapping will work across.</desc>
</field>
<field>
<name>snapToCanvas</name>
<desc>If true, edge and center snapping will work against canvas (toplevel control).</desc>
</field>
<field>
<name>snapToCenters</name>
<desc>If true, selection centers will snap into alignment when moved or resized.</desc>
</field>
<field>
<name>snapToControls</name>
<desc>If true, edge and center snapping will work against controls.</desc>
</field>
<field>
<name>snapToEdges</name>
<desc>If true, selection edges will snap into alignment when moved or resized.</desc>
</field>
<field>
<name>snapToGuides</name>
<desc>If true, edge and center snapping will work against guides.</desc>
</field>
</class>
<class>
<name>GuiEditCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiEditorRuler</name>
<base>GuiControl</base>
<field>
<name>editCtrl</name>
<desc>string editCtrl</desc>
</field>
<field>
<name>refCtrl</name>
<desc>string refCtrl</desc>
</field>
</class>
<class>
<name>GuiEditorRulerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiFadeinBitmapCtrl</name>
<base>GuiBitmapCtrl</base>
<field>
<name>click()</name>
<desc>@brief Informs the script level that this object received a Click event from the cursor or keyboard.

@tsexample
GuiFadeInBitmapCtrl::click(%this)
^{
^^// Code to run when click occurs
^}
@endtsexample

@see GuiCore</desc>
</field>
<field>
<name>done</name>
<desc>Whether the fade cycle has finished running.</desc>
</field>
<field>
<name>fadeColor</name>
<desc>Color to fade in from and fade out to.</desc>
</field>
<field>
<name>fadeInEase</name>
<desc>Easing curve for fade-in.</desc>
</field>
<field>
<name>fadeInTime</name>
<desc>Milliseconds for the bitmap to fade in.</desc>
</field>
<field>
<name>fadeOutEase</name>
<desc>Easing curve for fade-out.</desc>
</field>
<field>
<name>fadeOutTime</name>
<desc>Milliseconds for the bitmap to fade out.</desc>
</field>
<field>
<name>onDone()</name>
<desc>@brief Informs the script level that this object has completed is fade cycle.

@tsexample
GuiFadeInBitmapCtrl::onDone(%this)
^{
^^// Code to run when the fade cycle completes
^}
@endtsexample

@see GuiCore</desc>
</field>
<field>
<name>waitTime</name>
<desc>Milliseconds to wait after fading in before fading out the bitmap.</desc>
</field>
</class>
<class>
<name>GuiFadeinBitmapCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiFileTreeCtrl</name>
<base>GuiTreeViewCtrl</base>
<method>
<name>getSelectedPath</name>
<desc>getSelectedPath() - returns the currently selected path in the tree</desc>
</method>
<method>
<name>reload</name>
<args>()</args>
<desc>Reread the directory tree hierarchy.</desc>
</method>
<method>
<name>setSelectedPath</name>
<desc>setSelectedPath(path) - expands the tree to the specified path</desc>
</method>
<field>
<name>fileFilter</name>
<desc>Vector of file patterns.  If not empty, only files matching the pattern will be shown in the control.</desc>
</field>
<field>
<name>rootPath</name>
<desc>Path in game directory that should be displayed in the control.</desc>
</field>
</class>
<class>
<name>GuiFileTreeCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiFilterCtrl</name>
<base>GuiControl</base>
<method>
<name>getValue</name>
<desc>Return a tuple containing all the values in the filter.@internal</desc>
</method>
<method>
<name>identity</name>
<desc>Reset the filtering.@internal</desc>
</method>
<method>
<name>setValue</name>
<args>(f1, f2, ...)</args>
<desc>Reset the filter to use the specified points, spread equidistantly across the domain.@internal</desc>
</method>
<field>
<name>controlPoints</name>
<desc>Total number of control points in the spline curve.</desc>
</field>
<field>
<name>filter</name>
<desc>Vector of control points.</desc>
</field>
<field>
<name>identity</name>
<desc>@internal</desc>
</field>
<field>
<name>showIdentity</name>
<desc>@internal</desc>
</field>
</class>
<class>
<name>GuiFilterCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiFormCtrl</name>
<base>GuiPanel</base>
<method>
<name>getMenuID</name>
<args>()</args>
<desc>Get the ID of this form's menu.

@return The ID of the form menu</desc>
</method>
<method>
<name>setCaption</name>
<args>( string caption )</args>
<desc>Sets the title of the form.

@param caption Form caption</desc>
</method>
<field>
<name>caption</name>
<desc>string caption</desc>
</field>
<field>
<name>content</name>
<desc>string content</desc>
</field>
<field>
<name>contentLibrary</name>
<desc>string contentLibrary</desc>
</field>
<field>
<name>hasMenu</name>
<desc>bool hasMenu</desc>
</field>
<field>
<name>movable</name>
<desc>bool movable</desc>
</field>
<field>
<name>onResize()</name>
<desc>Called when the control is resized.</desc>
</field>
</class>
<class>
<name>GuiFormCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiFrameSetCtrl</name>
<base>GuiContainer</base>
<method>
<name>addColumn</name>
<args>()</args>
<desc>Add a new column.</desc>
</method>
<method>
<name>addRow</name>
<args>()</args>
<desc>Add a new row.</desc>
</method>
<method>
<name>frameBorder</name>
<args>( int index, string state="dynamic" )</args>
<desc>Override the &lt;i&gt;borderEnable&lt;/i&gt; setting for this frame.

@param index  Index of the frame to modify
@param state  New borderEnable state: "on", "off" or "dynamic"</desc>
</method>
<method>
<name>frameMinExtent</name>
<args>( int index, int width, int height )</args>
<desc>Set the minimum width and height for the frame. It will not be possible for the user to resize the frame smaller than this.

@param index  Index of the frame to modify
@param width  Minimum width in pixels
@param height Minimum height in pixels</desc>
</method>
<method>
<name>frameMovable</name>
<args>( int index, string state="dynamic" )</args>
<desc>Override the &lt;i&gt;borderMovable&lt;/i&gt; setting for this frame.

@param index  Index of the frame to modify
@param state  New borderEnable state: "on", "off" or "dynamic"</desc>
</method>
<method>
<name>framePadding</name>
<args>( int index, RectSpacingI padding )</args>
<desc>Set the padding for this frame. Padding introduces blank space on the inside edge of the frame.

@param index     Index of the frame to modify
@param padding   Frame top, bottom, left, and right padding</desc>
</method>
<method>
<name>getColumnCount</name>
<args>()</args>
<desc>Get the number of columns.

@return The number of columns</desc>
</method>
<method>
<name>getColumnOffset</name>
<args>( int index )</args>
<desc>Get the horizontal offset of a column.

@param index Index of the column to query
@return Column offset in pixels</desc>
</method>
<method>
<name>getFramePadding</name>
<args>( int index )</args>
<desc>Get the padding for this frame.

@param index     Index of the frame to query</desc>
</method>
<method>
<name>getRowCount</name>
<args>()</args>
<desc>Get the number of rows.

@return The number of rows</desc>
</method>
<method>
<name>getRowOffset</name>
<args>( int index )</args>
<desc>Get the vertical offset of a row.

@param index Index of the row to query
@return Row offset in pixels</desc>
</method>
<method>
<name>removeColumn</name>
<args>()</args>
<desc>Remove the last (rightmost) column.</desc>
</method>
<method>
<name>removeRow</name>
<args>()</args>
<desc>Remove the last (bottom) row.</desc>
</method>
<method>
<name>setColumnOffset</name>
<args>( int index, int offset )</args>
<desc>Set the horizontal offset of a column.

Note that column offsets must always be in increasing order, and therefore this offset must be between the offsets of the colunns either side.
@param index  Index of the column to modify
@param offset New column offset</desc>
</method>
<method>
<name>setRowOffset</name>
<args>( int index, int offset )</args>
<desc>Set the vertical offset of a row.

Note that row offsets must always be in increasing order, and therefore this offset must be between the offsets of the rows either side.
@param index  Index of the row to modify
@param offset New row offset</desc>
</method>
<method>
<name>updateSizes</name>
<args>()</args>
<desc>Recalculates child control sizes.</desc>
</method>
<field>
<name>autoBalance</name>
<desc>If true, row and column offsets are automatically scaled to match the new extents when the control is resized.</desc>
</field>
<field>
<name>borderColor</name>
<desc>Color of interior borders between cells.</desc>
</field>
<field>
<name>borderEnable</name>
<desc>Controls whether frame borders are enabled.

Frames use this value unless overridden for that frame using &lt;i&gt;%ctrl.frameBorder(index)&lt;/i&gt;</desc>
</field>
<field>
<name>borderMovable</name>
<desc>Controls whether borders can be dynamically repositioned with the mouse by the user.

Frames use this value unless overridden for that frame using &lt;i&gt;%ctrl.frameMovable(index)&lt;/i&gt;</desc>
</field>
<field>
<name>borderWidth</name>
<desc>Width of interior borders between cells in pixels.</desc>
</field>
<field>
<name>columns</name>
<desc>A vector of column offsets (determines the width of each column).</desc>
</field>
<field>
<name>fudgeFactor</name>
<desc>Offset for row and column dividers in pixels</desc>
</field>
<field>
<name>rows</name>
<desc>A vector of row offsets (determines the height of each row).</desc>
</field>
</class>
<class>
<name>GuiFrameSetCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiGameListMenuCtrl</name>
<base>GuiControl</base>
<method>
<name>activateRow</name>
<args>()</args>
<desc>Activates the current row. The script callback of  the current row will be called (if it has one).</desc>
</method>
<method>
<name>addRow</name>
<args>( string label, string callback, int icon=-1, int yPad=0, bool useHighlightIcon=true, bool enabled=true )</args>
<desc>Add a row to the list control.

@param label The text to display on the row as a label.
@param callback Name of a script function to use as a callback when this row is activated.
@param icon [optional] Index of the icon to use as a marker.
@param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
@param useHighlightIcon [optional] Does this row use the highlight icon?.
@param enabled [optional] If this row is initially enabled.</desc>
</method>
<method>
<name>getRowCount</name>
<args>()</args>
<desc>Gets the number of rows on the control.

@return (int) The number of rows on the control.</desc>
</method>
<method>
<name>getRowLabel</name>
<args>( int row )</args>
<desc>Gets the label displayed on the specified row.

@param row Index of the row to get the label of.
@return The label for the row.</desc>
</method>
<method>
<name>getSelectedRow</name>
<args>()</args>
<desc>Gets the index of the currently selected row.

@return Index of the selected row.</desc>
</method>
<method>
<name>isRowEnabled</name>
<args>( int row )</args>
<desc>Determines if the specified row is enabled or disabled.

@param row The row to set the enabled status of.
@return True if the specified row is enabled. False if the row is not enabled or the given index was not valid.</desc>
</method>
<method>
<name>setRowEnabled</name>
<args>( int row, bool enabled )</args>
<desc>Sets a row's enabled status according to the given parameters.

@param row The index to check for validity.
@param enabled Indicate true to enable the row or false to disable it.</desc>
</method>
<method>
<name>setRowLabel</name>
<args>( int row, string label )</args>
<desc>Sets the label on the given row.

@param row Index of the row to set the label on.
@param label Text to set as the label of the row.</desc>
</method>
<method>
<name>setSelected</name>
<args>( int row )</args>
<desc>Sets the selected row. Only rows that are enabled can be selected.

@param row Index of the row to set as selected.</desc>
</method>
<field>
<name>callbackOnA</name>
<desc>Script callback when the 'A' button is pressed. 'A' inputs are Keyboard: A, Return, Space; Gamepad: A, Start</desc>
</field>
<field>
<name>callbackOnB</name>
<desc>Script callback when the 'B' button is pressed. 'B' inputs are Keyboard: B, Esc, Backspace, Delete; Gamepad: B, Back</desc>
</field>
<field>
<name>callbackOnX</name>
<desc>Script callback when the 'X' button is pressed. 'X' inputs are Keyboard: X; Gamepad: X</desc>
</field>
<field>
<name>callbackOnY</name>
<desc>Script callback when the 'Y' button is pressed. 'Y' inputs are Keyboard: Y; Gamepad: Y</desc>
</field>
<field>
<name>debugRender</name>
<desc>Enable debug rendering</desc>
</field>
<field>
<name>onChange()</name>
<desc>Called when the selected row changes.</desc>
</field>
</class>
<class>
<name>GuiGameListMenuCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiGameListMenuProfile</name>
<base>GuiControlProfile</base>
<field>
<name>hitAreaLowerRight</name>
<desc>Position of the lower right corner of the row hit area (relative to row's top left corner)</desc>
</field>
<field>
<name>hitAreaUpperLeft</name>
<desc>Position of the upper left corner of the row hit area (relative to row's top left corner)</desc>
</field>
<field>
<name>iconOffset</name>
<desc>Offset from the row's top left corner at which to render the row icon</desc>
</field>
<field>
<name>rowSize</name>
<desc>The base size ("width height") of a row</desc>
</field>
</class>
<class>
<name>GuiGameListMenuProfileClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiGameListOptionsCtrl</name>
<base>GuiGameListMenuCtrl</base>
<method>
<name>addRow</name>
<args>( string label, string options, bool wrapOptions, string callback, int icon=-1, int yPad=0, bool enabled=true )</args>
<desc>Add a row to the list control.

@param label The text to display on the row as a label.
@param options A tab separated list of options.
@param wrapOptions Specify true to allow options to wrap at each end or false to prevent wrapping.
@param callback Name of a script function to use as a callback when this row is activated.
@param icon [optional] Index of the icon to use as a marker.
@param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
@param enabled [optional] If this row is initially enabled.</desc>
</method>
<method>
<name>getCurrentOption</name>
<args>( int row )</args>
<desc>Gets the text for the currently selected option of the given row.

@param row Index of the row to get the option from.
@return A string representing the text currently displayed as the selected option on the given row. If there is no such displayed text then the empty string is returned.</desc>
</method>
<method>
<name>selectOption</name>
<args>( int row, string option )</args>
<desc>Set the row's current option to the one specified

@param row Index of the row to set an option on.
@param option The option to be made active.
@return True if the row contained the option and was set, false otherwise.</desc>
</method>
<method>
<name>setOptions</name>
<args>( int row, string optionsList )</args>
<desc>Sets the list of options on the given row.

@param row Index of the row to set options on.@param optionsList A tab separated list of options for the control.</desc>
</method>
</class>
<class>
<name>GuiGameListOptionsCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiGameListOptionsProfile</name>
<base>GuiGameListMenuProfile</base>
<field>
<name>columnSplit</name>
<desc>Padding between the leftmost edge of the control, and the row's left arrow.</desc>
</field>
<field>
<name>rightPad</name>
<desc>Padding between the rightmost edge of the control and the row's right arrow.</desc>
</field>
</class>
<class>
<name>GuiGameListOptionsProfileClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiGradientCtrl</name>
<base>GuiControl</base>
<method>
<name>getColor</name>
<desc>Get color value</desc>
</method>
<method>
<name>getColorCount</name>
<desc>Get color count</desc>
</method>
<field>
<name>actionOnMove</name>
<desc>bool actionOnMove</desc>
</field>
<field>
<name>baseColor</name>
<desc>ColorF baseColor</desc>
</field>
<field>
<name>displayMode</name>
<desc>GuiGradientPickMode displayMode</desc>
</field>
<field>
<name>pickColor</name>
<desc>ColorF pickColor</desc>
</field>
<field>
<name>showReticle</name>
<desc>bool showReticle</desc>
</field>
<field>
<name>swatchFactor</name>
<desc>int swatchFactor</desc>
</field>
</class>
<class>
<name>GuiGradientCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiGradientSwatchCtrl</name>
<base>GuiSwatchButtonCtrl</base>
</class>
<class>
<name>GuiGradientSwatchCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiGraphCtrl</name>
<base>GuiControl</base>
<method>
<name>addAutoPlot</name>
<args>( int plotId, string variable, int updateFrequency )</args>
<desc>Sets up the given plotting curve to automatically plot the value of the @a variable with a frequency of @a updateFrequency.
@param plotId Index of the plotting curve.  Must be 0&lt;=plotId&lt;6.
@param variable Name of the global variable.
@param updateFrequency Frequency with which to add new data points to the plotting curve (in milliseconds).
@tsexample
// Plot FPS counter at 1 second intervals.
%graph.addAutoPlot( 0, "fps::real", 1000 );
@endtsexample</desc>
</method>
<method>
<name>addDatum</name>
<args>( int plotId, float value )</args>
<desc>Add a data point to the plot's curve.

@param plotId Index of the plotting curve to which to add the data point.  Must be 0&lt;=plotId&lt;6.
@param value Value of the data point to add to the curve.

@note Data values are added to the @b left end of the plotting curve.

@note A maximum number of 200 data points can be added to any single plotting curve at any one time.  If this limit is exceeded, data points on the right end of the curve are culled.</desc>
</method>
<method>
<name>getDatum</name>
<args>( int plotId, int index )</args>
<desc>Get a data point on the given plotting curve.

@param plotId Index of the plotting curve from which to fetch the data point.  Must be 0&lt;=plotId&lt;6.
@param index Index of the data point on the curve.
@return The value of the data point or -1 if @a plotId or @a index are out of range.</desc>
</method>
<method>
<name>matchScale</name>
<args>( int plotID1, int plotID1, ... )</args>
<desc>Set the scale of all specified plots to the maximum scale among them.

@param plotID1 Index of plotting curve.
@param plotID2 Index of plotting curve.</desc>
</method>
<method>
<name>removeAutoPlot</name>
<args>( int plotId )</args>
<desc>Stop automatic variable plotting for the given curve.
@param plotId Index of the plotting curve.  Must be 0&lt;=plotId&lt;6.</desc>
</method>
<method>
<name>setGraphType</name>
<args>( int plotId, GuiGraphType graphType )</args>
<desc>Change the charting type of the given plotting curve.
@param plotId Index of the plotting curve.  Must be 0&lt;=plotId&lt;6.
@param graphType Charting type to use for the curve.
@note Instead of calling this method, you can directly assign to #plotType.</desc>
</method>
<field>
<name>centerY</name>
<desc>Ratio of where to place the center coordinate of the graph on the Y axis. 0.5=middle height of control.

This allows to account for graphs that have only positive or only negative data points, for example.</desc>
</field>
<field>
<name>plotColor</name>
<desc>Color to use for the plotting curves in the graph.</desc>
</field>
<field>
<name>plotInterval</name>
<desc>Interval between auto-plots of #plotVariable for the respective curve (in milliseconds).</desc>
</field>
<field>
<name>plotType</name>
<desc>Charting type of the plotting curves.</desc>
</field>
<field>
<name>plotVariable</name>
<desc>Name of the variable to automatically plot on the curves.  If empty, auto-plotting is disabled for the respective curve.</desc>
</field>
</class>
<class>
<name>GuiGraphCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>GuiHealthBarHud</name>
<base>GuiControl</base>
<field>
<name>damageFillColor</name>
<desc>As the health bar depletes, this color will represent the health loss amount.</desc>
</field>
<field>
<name>displayEnergy</name>
<desc>If true, display the energy value rather than the damage value.</desc>
</field>
<field>
<name>fillColor</name>
<desc>Standard color for the background of the control.</desc>
</field>
<field>
<name>frameColor</name>
<desc>Color for the control's frame.</desc>
</field>
<field>
<name>pulseRate</name>
<desc>Speed at which the control will pulse.</desc>
</field>
<field>
<name>pulseThreshold</name>
<desc>Health level the control must be under before the control will pulse.</desc>
</field>
<field>
<name>showFill</name>
<desc>If true, we draw the background color of the control.</desc>
</field>
<field>
<name>showFrame</name>
<desc>If true, we draw the frame of the control.</desc>
</field>
</class>
<class>
<name>GuiHealthBarHudClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiIconButtonCtrl</name>
<base>GuiButtonCtrl</base>
<method>
<name>setBitmap</name>
<args>( string buttonFilename )</args>
<desc>@brief Set the bitmap to use for the button portion of this control.

@param param1 Parameter 1 description
@tsexample
// Define the button filename
%buttonFilename = "pearlButton";

// Inform the GuiIconButtonCtrl control to update its main button graphic to the defined bitmap
%thisGuiIconButtonCtrl.setBitmap(%buttonFilename);
@endtsexample

@see GuiControl
@see GuiButtonCtrl</desc>
</method>
<field>
<name>autoSize</name>
<desc>If true, the text and icon will be automatically sized to the size of the control.</desc>
</field>
<field>
<name>buttonMargin</name>
<desc>Margin area around the button.</desc>
</field>
<field>
<name>iconBitmap</name>
<desc>Bitmap file for the icon to display on the button.</desc>
</field>
<field>
<name>iconLocation</name>
<desc>Where to place the icon on the control. Options are 0 (None), 1 (Left), 2 (Right), 3 (Center).</desc>
</field>
<field>
<name>makeIconSquare</name>
<desc>If true, will make sure the icon is square.</desc>
</field>
<field>
<name>sizeIconToButton</name>
<desc>If true, the icon will be scaled to be the same size as the button.</desc>
</field>
<field>
<name>textLocation</name>
<desc>Where to place the text on the control.
Options are 0 (None), 1 (Bottom), 2 (Right), 3 (Top), 4 (Left), 5 (Center).</desc>
</field>
<field>
<name>textMargin</name>
<desc>Margin between the icon and the text.</desc>
</field>
</class>
<class>
<name>GuiIconButtonCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiIdleCamFadeBitmapCtrl</name>
<base>GuiBitmapCtrl</base>
<method>
<name>fadeIn</name>
<args>()</args>
<desc>@internal</desc>
</method>
<method>
<name>fadeOut</name>
<args>()</args>
<desc>@internal</desc>
</method>
<field>
<name>done</name>
<desc>bool done</desc>
</field>
<field>
<name>fadeInTime</name>
<desc>int fadeInTime</desc>
</field>
<field>
<name>fadeOutTime</name>
<desc>int fadeOutTime</desc>
</field>
</class>
<class>
<name>GuiIdleCamFadeBitmapCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiImageList</name>
<base>SimObject</base>
<method>
<name>clear</name>
<args>()</args>
<desc>@brief Clears the imagelist

@tsexample
// Inform the GuiImageList control to clear itself.
%isFinished = %thisGuiImageList.clear();
@endtsexample

@return Returns true when finished.

@see SimObject</desc>
</method>
<method>
<name>count</name>
<args>()</args>
<desc>@brief Gets the number of images in the list.

@tsexample
// Request the number of images from the GuiImageList control.
%imageCount = %thisGuiImageList.count();
@endtsexample

@return Number of images in the control.

@see SimObject</desc>
</method>
<method>
<name>getImage</name>
<args>( int index )</args>
<desc>@brief Get a path to the texture at the specified index.

@param index Index of the image in the list.
@tsexample
// Define the image index/n%index = "5";

// Request the image path location from the control.
%imagePath = %thisGuiImageList.getImage(%index);
@endtsexample

@return File path to the image map for the specified index.

@see SimObject</desc>
</method>
<method>
<name>getIndex</name>
<args>( string imagePath )</args>
<desc>@brief Retrieves the imageindex of a specified texture in the list.

@param imagePath Imagemap including filepath of image to search for
@tsexample
// Define the imagemap to search for
%imagePath = "./game/client/data/images/thisImage";

// Request the index entry for the defined imagemap
%imageIndex = %thisGuiImageList.getIndex(%imagePath);
@endtsexample

@return Index of the imagemap matching the defined image path.

@see SimObject</desc>
</method>
<method>
<name>insert</name>
<args>( string imagePath )</args>
<desc>@brief Insert an image into imagelist- returns the image index or -1 for failure.

@param imagePath Imagemap, with path, to add to the list.
@tsexample
// Define the imagemap to add to the list
%imagePath = "./game/client/data/images/thisImage";

// Request the GuiImageList control to add the defined image to its list.
%imageIndex = %thisGuiImageList.insert(%imagePath);
@endtsexample

@return The index of the newly inserted imagemap, or -1 if the insertion failed.

@see SimObject</desc>
</method>
<method>
<name>remove</name>
<args>( int index )</args>
<desc>@brief Removes an image from the list by index.

@param index Image index to remove.
@tsexample
// Define the image index.
%imageIndex = "4";

// Inform the GuiImageList control to remove the image at the defined index.
%wasSuccessful = %thisGuiImageList.remove(%imageIndex);
@endtsexample

@return True if the operation was successful, false if it was not.

@see SimObject</desc>
</method>
</class>
<class>
<name>GuiImageListClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInputCtrl</name>
<base>GuiMouseEventCtrl</base>
<field>
<name>onInputEvent( string device, string action, bool state )</name>
<desc>@brief Callback that occurs when an input is triggered on this control

@param device The device type triggering the input, such as keyboard, mouse, etc
@param action The actual event occuring, such as a key or button
@param state True if the action is being pressed, false if it is being release</desc>
</field>
</class>
<class>
<name>GuiInputCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspector</name>
<base>GuiStackControl</base>
<method>
<name>addInspect</name>
<args>( id object, (bool autoSync = true) )</args>
<desc>Add the object to the list of objects being inspected.</desc>
</method>
<method>
<name>apply</name>
<desc>apply() - Force application of inspected object's attributes</desc>
</method>
<method>
<name>findByObject</name>
<desc>findByObject( SimObject ) - returns the id of an awake inspector that is inspecting the passed object if one exists.</desc>
</method>
<method>
<name>getInspectObject</name>
<desc>getInspectObject( int index=0 ) - Returns currently inspected object</desc>
</method>
<method>
<name>getNumInspectObjects</name>
<args>()</args>
<desc>Return the number of objects currently being inspected.</desc>
</method>
<method>
<name>inspect</name>
<desc>Inspect(Object)</desc>
</method>
<method>
<name>refresh</name>
<desc>Reinspect the currently selected object.</desc>
</method>
<method>
<name>removeInspect</name>
<args>( id object )</args>
<desc>Remove the object from the list of objects being inspected.</desc>
</method>
<method>
<name>setName</name>
<desc>setName(NewObjectName)</desc>
</method>
<method>
<name>setObjectField</name>
<desc>setObjectField( fieldname, data ) - Set a named fields value on the inspected object if it exists. This triggers all the usual callbacks that would occur if the field had been changed through the gui.</desc>
</method>
<field>
<name>dividerMargin</name>
<desc>int dividerMargin</desc>
</field>
<field>
<name>groupFilters</name>
<desc>Specify groups that should be shown or not. Specifying 'shown' implicitly does 'not show' all other groups. Example string: +name -otherName</desc>
</field>
<field>
<name>showCustomFields</name>
<desc>If false the custom fields Name, Id, and Source Class will not be shown.</desc>
</field>
</class>
<class>
<name>GuiInspectorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorCustomField</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorCustomFieldClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorDatablockField</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorDatablockFieldClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorDynamicField</name>
<base>GuiInspectorField</base>
<method>
<name>renameField</name>
<desc>field.renameField(newDynamicFieldName);</desc>
</method>
</class>
<class>
<name>GuiInspectorDynamicFieldClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorDynamicGroup</name>
<base>GuiInspectorGroup</base>
<method>
<name>addDynamicField</name>
<desc>obj.addDynamicField();</desc>
</method>
<method>
<name>inspectGroup</name>
<desc>Refreshes the dynamic fields in the inspector.</desc>
</method>
<method>
<name>removeDynamicField</name>
</method>
</class>
<class>
<name>GuiInspectorDynamicGroupClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorField</name>
<base>GuiControl</base>
<method>
<name>apply</name>
<args>( string newValue, bool callbacks=true )</args>
<desc>Set the field's value. Suppress callbacks for undo if callbacks=false.</desc>
</method>
<method>
<name>applyWithoutUndo</name>
<args>()</args>
<desc>Set field value without recording undo (same as 'apply( value, false )').</desc>
</method>
<method>
<name>getData</name>
<args>()</args>
<desc>Return the value currently displayed on the field.</desc>
</method>
<method>
<name>getInspectedFieldName</name>
<args>()</args>
<desc>Return the name of the field edited by this inspector field.</desc>
</method>
<method>
<name>getInspectedFieldType</name>
<args>()</args>
<desc>Return the type of the field edited by this inspector field.</desc>
</method>
<method>
<name>getInspector</name>
<args>()</args>
<desc>Return the GuiInspector to which this field belongs.</desc>
</method>
<method>
<name>reset</name>
<args>()</args>
<desc>Reset to default value.</desc>
</method>
</class>
<class>
<name>GuiInspectorFieldClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorGroup</name>
<base>GuiRolloutCtrl</base>
</class>
<class>
<name>GuiInspectorGroupClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeBitMask32</name>
<base>GuiInspectorField</base>
<method>
<name>applyBit</name>
<desc>apply();</desc>
</method>
</class>
<class>
<name>GuiInspectorTypeBitMask32Class</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeBitMask32Helper</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeBitMask32HelperClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeCheckBox</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeCheckBoxClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeColor</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeColorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeColorF</name>
<base>GuiInspectorTypeColor</base>
</class>
<class>
<name>GuiInspectorTypeColorFClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeColorI</name>
<base>GuiInspectorTypeColor</base>
</class>
<class>
<name>GuiInspectorTypeColorIClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeCommand</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeCommandClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeCubemapName</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeCubemapNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeEaseF</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeEaseFClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeEnum</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeEnumClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeFileName</name>
<base>GuiInspectorField</base>
<method>
<name>apply</name>
<desc>apply(newValue);</desc>
</method>
</class>
<class>
<name>GuiInspectorTypeFileNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeGuiProfile</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeGuiProfileClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeImageFileName</name>
<base>GuiInspectorTypeFileName</base>
</class>
<class>
<name>GuiInspectorTypeImageFileNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeMaterialName</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeMaterialNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeMenuBase</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeMenuBaseClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeName</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypePrefabFilename</name>
<base>GuiInspectorTypeFileName</base>
</class>
<class>
<name>GuiInspectorTypePrefabFilenameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeRectUV</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeRectUVClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeS32</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeS32Class</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeSFXAmbienceName</name>
<base>GuiInspectorDatablockField</base>
</class>
<class>
<name>GuiInspectorTypeSFXAmbienceNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeSFXDescriptionName</name>
<base>GuiInspectorDatablockField</base>
</class>
<class>
<name>GuiInspectorTypeSFXDescriptionNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeSFXEnvironmentName</name>
<base>GuiInspectorDatablockField</base>
</class>
<class>
<name>GuiInspectorTypeSFXEnvironmentNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeSFXParameterName</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeSFXParameterNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeSFXSourceName</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeSFXSourceNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeSFXStateName</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeSFXStateNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeSFXTrackName</name>
<base>GuiInspectorDatablockField</base>
</class>
<class>
<name>GuiInspectorTypeSFXTrackNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeTerrainMaterialIndex</name>
<base>GuiInspectorTypeMaterialName</base>
</class>
<class>
<name>GuiInspectorTypeTerrainMaterialIndexClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorTypeTerrainMaterialName</name>
<base>GuiInspectorTypeMaterialName</base>
</class>
<class>
<name>GuiInspectorTypeTerrainMaterialNameClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorVariableField</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorVariableFieldClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiInspectorVariableGroup</name>
<base>GuiInspectorGroup</base>
</class>
<class>
<name>GuiInspectorVariableGroupClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiListBoxCtrl</name>
<base>GuiControl</base>
<method>
<name>addFilteredItem</name>
<args>( string newItem )</args>
<desc>@brief Checks if there is an item with the exact text of what is passed in, and if so
the item is removed from the list and adds that item's data to the filtered list.

@param itemName Name of the item that we wish to add to the filtered item list of the GuiListBoxCtrl.
@tsexample
// Define the itemName that we wish to add to the filtered item list.
%itemName = "This Item Name";

// Add the item name to the filtered item list.
%thisGuiListBoxCtrl.addFilteredItem(%filteredItemName);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>addItem</name>
<args>( string newItem, string color="" )</args>
<desc>@brief Adds an item to the end of the list with an optional color.

@param newItem New item to add to the list.
@param color Optional color parameter to add to the new item.
@tsexample
// Define the item to add to the list.
%newItem = "Gideon's Blue Coat";

// Define the optional color for the new list item.
%color = "0.0 0.0 1.0";

// Inform the GuiListBoxCtrl object to add the item to the end of the list with the defined color.
%thisGuiListBoxCtrl.addItem(%newItem,%color);
@endtsexample

@return If not void, return value and description

@see GuiControl
@hide</desc>
</method>
<method>
<name>clearItemColor</name>
<args>( int index )</args>
<desc>@brief Removes any custom coloring from an item at the defined index id in the list.

@param index Index id for the item to clear any custom color from.
@tsexample
// Define the index id
%index = "4";

// Request the GuiListBoxCtrl object to remove any custom coloring from the defined index entry
%thisGuiListBoxCtrl.clearItemColor(%index);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>clearItems</name>
<args>()</args>
<desc>@brief Clears all the items in the listbox.

@tsexample
// Inform the GuiListBoxCtrl object to clear all items from its list.
%thisGuiListBoxCtrl.clearItems();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>clearSelection</name>
<args>()</args>
<desc>@brief Sets all currently selected items to unselected.

Detailed description

@tsexample
// Inform the GuiListBoxCtrl object to set all of its items to unselected./n%thisGuiListBoxCtrl.clearSelection();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>deleteItem</name>
<args>( int itemIndex )</args>
<desc>@brief Removes the list entry at the requested index id from the control and clears the memory associated with it.

@param itemIndex Index id location to remove the item from.
@tsexample
// Define the index id we want to remove from the list
%itemIndex = "8";

// Inform the GuiListBoxCtrl object to remove the item at the defined index id.
%thisGuiListBoxCtrl.deleteItem(%itemIndex);
@endtsexample

@see References</desc>
</method>
<method>
<name>doMirror</name>
<args>()</args>
<desc>@brief Informs the GuiListBoxCtrl object to mirror the contents of the GuiListBoxCtrl stored in the mirrorSet field.

@tsexample
\ Inform the object to mirror the object located at %thisGuiListBox.mirrorSet
%thisGuiListBox.doMirror();
@endtsexample

@see GuiCore</desc>
</method>
<method>
<name>findItemText</name>
<args>( string findText, bool bCaseSensitive=false )</args>
<desc>@brief Returns index of item with matching text or -1 if none found.

@param findText Text in the list to find.
@param isCaseSensitive If true, the search will be case sensitive.
@tsexample
// Define the text we wish to find in the list.
%findText = "Hickory Smoked Gideon"/n/n// Define if this is a case sensitive search or not.
%isCaseSensitive = "false";

// Ask the GuiListBoxCtrl object what item id in the list matches the requested text.
%matchingId = %thisGuiListBoxCtrl.findItemText(%findText,%isCaseSensitive);
@endtsexample

@return Index id of item with matching text or -1 if none found.

@see GuiControl</desc>
</method>
<method>
<name>getItemCount</name>
<args>()</args>
<desc>@brief Returns the number of items in the list.

@tsexample
// Request the number of items in the list of the GuiListBoxCtrl object.
%listItemCount = %thisGuiListBoxCtrl.getItemCount();
@endtsexample

@return The number of items in the list.

@see GuiControl</desc>
</method>
<method>
<name>getItemObject</name>
<args>( int index )</args>
<desc>@brief Returns the object associated with an item. This only makes sense if you are mirroring a simset.

@param index Index id to request the associated item from.
@tsexample
// Define the index id
%index = "12";

// Request the item from the GuiListBoxCtrl object
%object = %thisGuiListBoxCtrl.getItemObject(%index);
@endtsexample

@return The object associated with the item in the list.

@see References</desc>
</method>
<method>
<name>getItemText</name>
<args>( int index )</args>
<desc>@brief Returns the text of the item at the specified index.

@param index Index id to return the item text from.
@tsexample
// Define the index id entry to request the text from
%index = "12";

// Request the item id text from the GuiListBoxCtrl object.
%text = %thisGuiListBoxCtrl.getItemText(%index);
@endtsexample

@return The text of the requested index id.

@see GuiControl</desc>
</method>
<method>
<name>getLastClickItem</name>
<args>()</args>
<desc>@brief Request the item index for the item that was last clicked.

@tsexample
// Request the item index for the last clicked item in the list
%lastClickedIndex = %thisGuiListBoxCtrl.getLastClickItem();
@endtsexample

@return Index id for the last clicked item in the list.

@see GuiControl</desc>
</method>
<method>
<name>getSelCount</name>
<args>()</args>
<desc>@brief Returns the number of items currently selected.

@tsexample
// Request the number of currently selected items
%selectedItemCount = %thisGuiListBoxCtrl.getSelCount();
@endtsexample

@return Number of currently selected items.

@see GuiControl</desc>
</method>
<method>
<name>getSelectedItem</name>
<args>()</args>
<desc>@brief Returns the selected items index or -1 if none selected. If multiple selections exist it returns the first selected item.

@tsexample
// Request the index id of the currently selected item
%selectedItemId = %thisGuiListBoxCtrl.getSelectedItem();
@endtsexample

@return The selected items index or -1 if none selected.

@see GuiControl</desc>
</method>
<method>
<name>getSelectedItems</name>
<args>()</args>
<desc>@brief Returns a space delimited list of the selected items indexes in the list.

@tsexample
// Request a space delimited list of the items in the GuiListBoxCtrl object.
%selectionList = %thisGuiListBoxCtrl.getSelectedItems();
@endtsexample

@return Space delimited list of the selected items indexes in the list

@see GuiControl</desc>
</method>
<method>
<name>insertItem</name>
<args>( string text, int index )</args>
<desc>@brief Inserts an item into the list at the specified index and returns the index assigned or -1 on error.

@param text Text item to add.
@param index Index id to insert the list item text at.
@tsexample
// Define the text to insert
%text = "Secret Agent Gideon";

// Define the index entry to insert the text at
%index = "14";

// In form the GuiListBoxCtrl object to insert the text at the defined index.
%assignedId = %thisGuiListBoxCtrl.insertItem(%text,%index);
@endtsexample

@return If successful will return the index id assigned. If unsuccessful, will return -1.

@see GuiControl</desc>
</method>
<method>
<name>removeFilteredItem</name>
<args>( string itemName )</args>
<desc>@brief Removes an item of the entered name from the filtered items list.

@param itemName Name of the item to remove from the filtered list.
@tsexample
// Define the itemName that you wish to remove.
%itemName = "This Item Name";

// Remove the itemName from the GuiListBoxCtrl
%thisGuiListBoxCtrl.removeFilteredItem(%itemName);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setCurSel</name>
<args>( int indexId )</args>
<desc>@brief Sets the currently selected item at the specified index.

@param indexId Index Id to set selected.
@tsexample
// Define the index id that we wish to select.
%selectId = "4";

// Inform the GuiListBoxCtrl object to set the requested index as selected.
%thisGuiListBoxCtrl.setCurSel(%selectId);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setCurSelRange</name>
<args>( int indexStart, int indexStop=999999 )</args>
<desc>@brief Sets the current selection range from index start to stop. If no stop is specified it sets from start index to the end of the list

@param indexStart Index Id to start selection.
@param indexStop Index Id to end selection.
@tsexample
// Set start id
%indexStart = "3";

// Set end id
%indexEnd = "6";

// Request the GuiListBoxCtrl object to select the defined range.
%thisGuiListBoxCtrl.setCurSelRange(%indexStart,%indexEnd);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setItemColor</name>
<args>( int index, ColorF color )</args>
<desc>@brief Sets the color of a single list entry at the specified index id.

@param index Index id to modify the color of in the list.
@param color Color value to set the list entry to.
@tsexample
// Define the index id value
%index = "5";

// Define the color value
%color = "1.0 0.0 0.0";

// Inform the GuiListBoxCtrl object to change the color of the requested index
%thisGuiListBoxCtrl.setItemColor(%index,%color);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setItemText</name>
<args>( int index, string newtext )</args>
<desc>@brief Sets the items text at the specified index.

@param index Index id to set the item text at.
@param newtext Text to change the list item at index id to.
@tsexample
// Define the index id/n%index = "12";

// Define the text to set the list item to
%newtext = "Gideon's Fancy Goggles";

// Inform the GuiListBoxCtrl object to change the text at the requested index
%thisGuiListBoxCtrl.setItemText(%index,%newText);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setItemTooltip</name>
<args>( int index, string text )</args>
<desc>@brief Set the tooltip text to display for the given list item.

@param index Index id to change the tooltip text
@param text Text for the tooltip.
@tsexample
// Define the index id
%index = "12";

// Define the tooltip text
%tooltip = "Gideon's goggles can see through space and time."

// Inform the GuiListBoxCtrl object to set the tooltop for the item at the defined index id
%thisGuiListBoxCtrl.setItemToolTip(%index,%tooltip);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setMultipleSelection</name>
<args>( bool allowMultSelections )</args>
<desc>@brief Enable or disable multiple selections for this GuiListBoxCtrl object.

@param allowMultSelections Boolean variable to set the use of multiple selections or not.
@tsexample
// Define the multiple selection use state.
%allowMultSelections = "true";

// Set the allow  multiple selection state on the GuiListBoxCtrl object.
%thisGuiListBoxCtrl.setMultipleSelection(%allowMultSelections);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setSelected</name>
<args>( int index, bool setSelected=true )</args>
<desc>@brief Sets the item at the index specified to selected or not.

Detailed description

@param index Item index to set selected or unselected.
@param setSelected Boolean selection state to set the requested item index.
@tsexample
// Define the index
%index = "5";

// Define the selection state
%selected = "true"

// Inform the GuiListBoxCtrl object of the new selection state for the requested index entry.
%thisGuiListBoxCtrl.setSelected(%index,%selected);
@endtsexample

@see GuiControl</desc>
</method>
<field>
<name>allowMultipleSelections</name>
<desc>If true, will allow the selection of multiple items in the listbox.</desc>
</field>
<field>
<name>colorBullet</name>
<desc>If true, colored items will render a colored rectangular bullet next to the item text.</desc>
</field>
<field>
<name>fitParentWidth</name>
<desc>If true, the width of the listbox will match the width of its parent control.</desc>
</field>
<field>
<name>isObjectMirrored( string indexIdString )</name>
<desc>@brief Checks if a list item at a defined index id is mirrored, and returns the result.

@param indexIdString Index id of the list to check.
@tsexample
// Engine has requested of the script level to determine if a list entry is mirrored or not.
GuiListBoxCtrl::isObjectMirrored(%this, %indexIdString)
^{
^^// Perform code required to check and see if the list item at the index id is mirrored or not.
^^return %isMirrored;
^}
@endtsexample

@return A boolean value on if the list item is mirrored or not.

@see GuiControl</desc>
</field>
<field>
<name>makeNameCallback</name>
<desc>A script snippet to control what is displayed in the list for a SimObject. Within this snippet, $ThisControl is bound to the guiListBoxCtrl and $ThisObject to the contained object in question.</desc>
</field>
<field>
<name>mirrorSet</name>
<desc>If populated with the name of another GuiListBoxCtrl, then this list box will mirror the contents of the mirrorSet listbox.</desc>
</field>
<field>
<name>onClearSelection()</name>
<desc>@brief Called whenever a selected item in the list is cleared.

@tsexample
// A selected item is cleared, causing the callback to occur.
GuiListBoxCtrl::onClearSelection(%this)
^{
^^// Code to run whenever a selected item is cleared
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onDeleteKey()</name>
<desc>@brief Called whenever the Delete key on the keyboard has been pressed while in this control.

@tsexample
// The delete key on the keyboard has been pressed while this control is in focus, causing the callback to occur.
GuiListBoxCtrl::onDeleteKey(%this)
^{
^^// Code to call whenever the delete key is pressed
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onDoubleClick()</name>
<desc>@brief Called whenever an item in the list has been double clicked.

@tsexample
// An item in the list is double clicked, causing the callback to occur.
GuiListBoxCtrl::onDoubleClick(%this)
^{
^^// Code to run whenever an item in the control has been double clicked
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onMouseDragged()</name>
<desc>@brief Called whenever the mouse is dragged across the control.

@tsexample
// Mouse is dragged across the control, causing the callback to occur.
GuiListBoxCtrl::onMouseDragged(%this)
^{
^^// Code to run whenever the mouse is dragged across the control
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onMouseUp( string itemHit, string mouseClickCount )</name>
<desc>@brief Called whenever the mouse has previously been clicked down (onMouseDown) and has now been raised on the control.
If an item in the list was hit during the click cycle, then the index id of the clicked object along with how many clicks occured are passed
into the callback.

Detailed description

@param itemHit Index id for the list item that was hit
@param mouseClickCount How many mouse clicks occured on this list item

@tsexample
// Mouse was previously clicked down, and now has been released, causing the callback to occur.
GuiListBoxCtrl::onMouseUp(%this, %itemHit, %mouseClickCount)
^{
^^// Code to call whenever the mouse has been clicked and released on the control
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onSelect( string index, string itemText )</name>
<desc>@brief Called whenever an item in the list is selected.

@param index Index id for the item in the list that was selected.
@param itemText Text for the list item at the index that was selected.

@tsexample
// An item in the list is selected, causing the callback to occur
GuiListBoxCtrl::onSelect(%this, %index, %itemText)
^{
^^// Code to run whenever an item in the list is selected
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onUnSelect( string index, string itemText )</name>
<desc>@brief Called whenever a selected item in the list has been unselected.

@param index Index id of the item that was unselected
@param itemText Text for the list entry at the index id that was unselected

@tsexample
// A selected item is unselected, causing the callback to occur
GuiListBoxCtrl::onUnSelect(%this, %indexId, %itemText)
^{
^^// Code to run whenever a selected list item is unselected
^}
@endtsexample

@see GuiControl</desc>
</field>
</class>
<class>
<name>GuiListBoxCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiMaterialCtrl</name>
<base>GuiContainer</base>
<method>
<name>setMaterial</name>
<args>( string materialName )</args>
<desc>Set the material to be displayed in the control.</desc>
</method>
<field>
<name>materialName</name>
<desc>filename materialName</desc>
</field>
</class>
<class>
<name>GuiMaterialCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiMaterialPreview</name>
<base>GuiTSCtrl</base>
<method>
<name>deleteModel</name>
<args>()</args>
<desc>Deletes the preview model.</desc>
</method>
<method>
<name>reset</name>
<args>()</args>
<desc>Resets the viewport to default zoom, pan, rotate and lighting.</desc>
</method>
<method>
<name>setAmbientLightColor</name>
<args>( ColorF color )</args>
<desc>Sets the color of the ambient light in the scene.</desc>
</method>
<method>
<name>setLightColor</name>
<args>( ColorF color )</args>
<desc>Sets the color of the light in the scene.</desc>
</method>
<method>
<name>setModel</name>
<args>( string shapeName )</args>
<desc>Sets the model to be displayed in this control

@param shapeName Name of the model to display.</desc>
</method>
<method>
<name>setOrbitDistance</name>
<args>( float distance )</args>
<desc>Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.

@param distance The distance to set the orbit to (will be clamped).</desc>
</method>
</class>
<class>
<name>GuiMaterialPreviewClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiMenuBar</name>
<base>GuiTickCtrl</base>
<method>
<name>addMenu</name>
<args>( string menuText, int menuId )</args>
<desc>@brief Adds a new menu to the menu bar.

@param menuText Text to display for the new menu item.
@param menuId ID for the new menu item.
@tsexample
// Define the menu text
%menuText = "New Menu";

// Define the menu ID.
%menuId = "2";

// Inform the GuiMenuBar control to add the new menu
%thisGuiMenuBar.addMenu(%menuText,%menuId);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>addMenuItem</name>
<args>( string targetMenu="", string menuItemText="", int menuItemId=0, string accelerator=NULL, int checkGroup=-1 )</args>
<desc>@brief Adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.

@param menu Menu name or menu Id to add the new item to.
@param menuItemText Text for the new menu item.
@param menuItemId Id for the new menu item.
@param accelerator Accelerator key for the new menu item.
@param checkGroup Check group to include this menu item in.
@tsexample
// Define the menu we wish to add the item to
%targetMenu = "New Menu";  or  %menu = "4";

// Define the text for the new menu item
%menuItemText = "Menu Item";

// Define the id for the new menu item
%menuItemId = "3";

// Set the accelerator key to toggle this menu item with
%accelerator = "n";

// Define the Check Group that this menu item will be in, if we want it to be in a check group. -1 sets it in no check group.
%checkGroup = "4";

// Inform the GuiMenuBar control to add the new menu item with the defined fields
%thisGuiMenuBar.addMenuItem(%menu,%menuItemText,%menuItemId,%accelerator,%checkGroup);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>addSubmenuItem</name>
<args>( string menuTarget, string menuItem, string submenuItemText, int submenuItemId, string accelerator, int checkGroup )</args>
<desc>@brief Adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.

@param menuTarget Menu to affect a submenu in
@param menuItem Menu item to affect
@param submenuItemText Text to show for the new submenu
@param submenuItemId Id for the new submenu
@param accelerator Accelerator key for the new submenu
@param checkGroup Which check group the new submenu should be in, or -1 for none.
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or  %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Define the text for the new submenu
%submenuItemText = "New Submenu Item";

// Define the id for the new submenu
%submenuItemId = "4";

// Define the accelerator key for the new submenu
%accelerator = "n";

// Define the checkgroup for the new submenu
%checkgroup = "7";

// Request the GuiMenuBar control to add the new submenu with the defined information
%thisGuiMenuBar.addSubmenuItem(%menuTarget,%menuItem,%submenuItemText,%submenuItemId,%accelerator,%checkgroup);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>clearMenuItems</name>
<args>( string menuTarget )</args>
<desc>@brief Removes all the menu items from the specified menu.

@param menuTarget Menu to remove all items from
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Inform the GuiMenuBar control to clear all menu items from the defined menu
%thisGuiMenuBar.clearMenuItems(%menuTarget);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>clearMenus</name>
<args>( int param1, int param2 )</args>
<desc>@brief Clears all the menus from the menu bar.

@tsexample
// Inform the GuiMenuBar control to clear all menus from itself.
%thisGuiMenuBar.clearMenus();
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>clearSubmenuItems</name>
<args>( string menuTarget, string menuItem )</args>
<desc>@brief Removes all the menu items from the specified submenu.

@param menuTarget Menu to affect a submenu in
@param menuItem Menu item to affect
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Inform the GuiMenuBar to remove all submenu items from the defined menu item
%thisGuiMenuBar.clearSubmenuItems(%menuTarget,%menuItem);

@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>removeMenu</name>
<args>( string menuTarget )</args>
<desc>@brief Removes the specified menu from the menu bar.

@param menuTarget Menu to remove from the menu bar
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Inform the GuiMenuBar to remove the defined menu from the menu bar
%thisGuiMenuBar.removeMenu(%menuTarget);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>removeMenuItem</name>
<args>( string menuTarget, string menuItemTarget )</args>
<desc>@brief Removes the specified menu item from the menu.

@param menuTarget Menu to affect the menu item in
@param menuItem Menu item to affect
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Request the GuiMenuBar control to remove the define menu item
%thisGuiMenuBar.removeMenuItem(%menuTarget,%menuItem);

@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setCheckmarkBitmapIndex</name>
<args>( int bitmapindex )</args>
<desc>@brief Sets the menu bitmap index for the check mark image.

@param bitmapIndex Bitmap index for the check mark image.
@tsexample
// Define the bitmap index
%bitmapIndex = "2";

// Inform the GuiMenuBar control of the proper bitmap index for the check mark image
%thisGuiMenuBar.setCheckmarkBitmapIndex(%bitmapIndex);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuBitmapIndex</name>
<args>( string menuTarget, int bitmapindex, bool bitmaponly, bool drawborder )</args>
<desc>@brief Sets the bitmap index for the menu and toggles rendering only the bitmap.

@param menuTarget Menu to affect
@param bitmapindex Bitmap index to set for the menu
@param bitmaponly If true, only the bitmap will be rendered
@param drawborder If true, a border will be drawn around the menu.
@tsexample
// Define the menuTarget to affect
%menuTarget = "New Menu";  or %menuTarget = "3";

// Set the bitmap index
%bitmapIndex = "5";

// Set if we are only to render the bitmap or not
%bitmaponly = "true";

// Set if we are rendering a border or not
%drawborder = "true";

// Inform the GuiMenuBar of the bitmap and rendering changes
%thisGuiMenuBar.setMenuBitmapIndex(%menuTarget,%bitmapIndex,%bitmapOnly,%drawBorder);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuItemBitmap</name>
<args>( string menuTarget, string menuItemTarget, int bitmapIndex )</args>
<desc>@brief Sets the specified menu item bitmap index in the bitmap array.  Setting the item's index to -1 will remove any bitmap.

@param menuTarget Menu to affect the menuItem in
@param menuItem Menu item to affect
@param bitmapIndex Bitmap index to set the menu item to
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or  %menuTarget = "3";

// Define the menuItem"
%menuItem = "New Menu Item";  or %menuItem = "2";

// Define the bitmapIndex
%bitmapIndex = "6";

// Inform the GuiMenuBar control to set the menu item to the defined bitmap
%thisGuiMenuBar.setMenuItemBitmap(%menuTarget,%menuItem,%bitmapIndex);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuItemChecked</name>
<args>( string menuTarget, string menuItemTarget, bool checked )</args>
<desc>@brief Sets the menu item bitmap to a check mark, which by default is the first element in
the bitmap array (although this may be changed with setCheckmarkBitmapIndex()).
Any other menu items in the menu with the same check group become unchecked if they are checked.

@param menuTarget Menu to work in
@param menuItem Menu item to affect
@param checked Whether we are setting it to checked or not
@tsexample
@endtsexample

@return If not void, return value and description

@see References</desc>
</method>
<method>
<name>setMenuItemEnable</name>
<args>( string menuTarget, string menuItemTarget, bool enabled )</args>
<desc>@brief sets the menu item to enabled or disabled based on the enable parameter.
The specified menu and menu item can either be text or ids.

Detailed description

@param menuTarget Menu to work in
@param menuItemTarget The menu item inside of the menu to enable or disable
@param enabled Boolean enable / disable value.
@tsexample
// Define the menu
%menu = "New Menu";  or  %menu = "4";

// Define the menu item
%menuItem = "New Menu Item";  or %menuItem = "2";

// Define the enabled state
%enabled = "true";

// Inform the GuiMenuBar control to set the enabled state of the requested menu item
%thisGuiMenuBar.setMenuItemEnable(%menu,%menuItme,%enabled);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuItemSubmenuState</name>
<args>( string menuTarget, string menuItem, bool isSubmenu )</args>
<desc>@brief Sets the given menu item to be a submenu.

@param menuTarget Menu to affect a submenu in
@param menuItem Menu item to affect
@param isSubmenu Whether or not the menuItem will become a subMenu or not
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Define whether or not the Menu Item is a sub menu or not
%isSubmenu = "true";

// Inform the GuiMenuBar control to set the defined menu item to be a submenu or not.
%thisGuiMenuBar.setMenuItemSubmenuState(%menuTarget,%menuItem,%isSubmenu);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuItemText</name>
<args>( string menuTarget, string menuItemTarget, string newMenuItemText )</args>
<desc>@brief Sets the text of the specified menu item to the new string.

@param menuTarget Menu to affect
@param menuItem Menu item in the menu to change the text at
@param newMenuItemText New menu text
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or  %menuTarget = "4";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "2";

// Define the new text for the menu item
%newMenuItemText = "Very New Menu Item";

// Inform the GuiMenuBar control to change the defined menu item with the new text
%thisGuiMenuBar.setMenuItemText(%menuTarget,%menuItem,%newMenuItemText);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuItemVisible</name>
<args>( string menuTarget, string menuItemTarget, bool isVisible )</args>
<desc>@brief Brief Description.

Detailed description

@param menuTarget Menu to affect the menu item in
@param menuItem Menu item to affect
@param isVisible Visible state to set the menu item to.
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or  %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "2";

// Define the visibility state
%isVisible = "true";

// Inform the GuiMenuBarControl of the visibility state of the defined menu item
%thisGuiMenuBar.setMenuItemVisible(%menuTarget,%menuItem,%isVisible);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuMargins</name>
<args>( int horizontalMargin, int verticalMargin, int bitmapToTextSpacing )</args>
<desc>@brief Sets the menu rendering margins: horizontal, vertical, bitmap spacing.

Detailed description

@param horizontalMargin Number of pixels on the left and right side of a menu's text.
@param verticalMargin Number of pixels on the top and bottom of a menu's text.
@param bitmapToTextSpacing Number of pixels between a menu's bitmap and text.
@tsexample
// Define the horizontalMargin
%horizontalMargin = "5";

// Define the verticalMargin
%verticalMargin = "5";

// Define the bitmapToTextSpacing
%bitmapToTextSpacing = "12";

// Inform the GuiMenuBar control to set its margins based on the defined values.
%thisGuiMenuBar.setMenuMargins(%horizontalMargin,%verticalMargin,%bitmapToTextSpacing);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuText</name>
<args>( string menuTarget, string newMenuText )</args>
<desc>@brief Sets the text of the specified menu to the new string.

@param menuTarget Menu to affect
@param newMenuText New menu text
@tsexample
// Define the menu to affect%menu = "New Menu";  or %menu = "3";

// Define the text to change the menu to
%newMenuText = "Still a New Menu";

// Inform the GuiMenuBar control to change the defined menu to the defined text
%thisGuiMenuBar.setMenuText(%menu,%newMenuText);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setMenuVisible</name>
<args>( string menuTarget, bool visible )</args>
<desc>@brief Sets the whether or not to display the specified menu.

@param menuTarget Menu item to affect
@param visible Whether the menu item will be visible or not
@tsexample
// Define the menu to work with
%menuTarget = "New Menu";  or  %menuTarget = "4";

// Define if the menu should be visible or not
%visible = "true";

// Inform the GuiMenuBar control of the new visibility state for the defined menu
%thisGuiMenuBar.setMenuVisible(%menuTarget,%visible);
@endtsexample

@see GuiTickCtrl</desc>
</method>
<method>
<name>setSubmenuItemChecked</name>
<args>( string menuTarget, string menuItemTarget, string submenuItemText, bool checked )</args>
<desc>@brief Sets the menu item bitmap to a check mark, which by default is the first element in the
bitmap array (although this may be changed with setCheckmarkBitmapIndex()).
Any other menu items in the menu with the same check group become unchecked if they are checked.

@param menuTarget Menu to affect a submenu in
@param menuItem Menu item to affect
@param submenuItemText Text to show for submenu
@param checked Whether or not this submenu item will be checked.
@tsexample
// Define the menuTarget
%menuTarget = "New Menu";  or %menuTarget = "3";

// Define the menuItem
%menuItem = "New Menu Item";  or  %menuItem = "5";

// Define the text for the new submenu
%submenuItemText = "Submenu Item";

// Define if this submenu item should be checked or not
%checked = "true";

// Inform the GuiMenuBar control to set the checked state of the defined submenu item
%thisGuiMenuBar.setSubmenuItemChecked(%menuTarget,%menuItem,%submenuItemText,%checked);
@endtsexample

@return If not void, return value and description

@see References</desc>
</method>
<field>
<name>onMenuItemSelect( string menuId, string menuText, string menuItemId, string menuItemText )</name>
<desc>@brief Called whenever an item in a menu is selected.

@param menuId Index id of the menu which contains the selected menu item
@param menuText Text of the menu which contains the selected menu item

@param menuItemId Index id of the selected menu item
@param menuItemText Text of the selected menu item

@tsexample
// A menu item has been selected, causing the callback to occur.
GuiMenuBar::onMenuItemSelect(%this,%menuId,%menuText,%menuItemId,%menuItemText)
{
^// Code to run when the callback occurs
}
@endtsexample

@see GuiTickCtrl</desc>
</field>
<field>
<name>onMenuSelect( string menuId, string menuText )</name>
<desc>@brief Called whenever a menu is selected.

@param menuId Index id of the clicked menu
@param menuText Text of the clicked menu

@tsexample
// A menu has been selected, causing the callback to occur.
GuiMenuBar::onMenuSelect(%this,%menuId,%menuText)
{
^// Code to run when the callback occurs
}
@endtsexample

@see GuiTickCtrl</desc>
</field>
<field>
<name>onMouseInMenu( bool hasLeftMenu )</name>
<desc>@brief Called whenever the mouse enters, or persists is in the menu.

@param hasLeftMenu True if the mouse has left the menu, otherwise is false.
@tsexample
// Mouse enters or persists within the menu, causing the callback to occur.
GuiMenuBar::onMouseInMenu(%this,%hasLeftMenu)
{
^// Code to run when the callback occurs
}
@endtsexample

@see GuiTickCtrl</desc>
</field>
<field>
<name>onSubmenuSelect( string submenuId, string submenuText )</name>
<desc>@brief Called whenever a submenu is selected.

@param submenuId Id of the selected submenu
@param submenuText Text of the selected submenu

@tsexample
GuiMenuBar::onSubmenuSelect(%this,%submenuId,%submenuText)
{
^// Code to run when the callback occurs
}
@endtsexample

@see GuiTickCtrl</desc>
</field>
<field>
<name>padding</name>
<desc>Extra padding to add to the bounds of the control.</desc>
</field>
</class>
<class>
<name>GuiMenuBarClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiMeshRoadEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteNode</name>
<desc>deleteNode()</desc>
</method>
<method>
<name>getMode</name>
</method>
<method>
<name>getNodeDepth</name>
</method>
<method>
<name>getNodeNormal</name>
</method>
<method>
<name>getNodePosition</name>
</method>
<method>
<name>getNodeWidth</name>
</method>
<method>
<name>getSelectedRoad</name>
</method>
<method>
<name>matchTerrainToRoad</name>
</method>
<method>
<name>regenerate</name>
</method>
<method>
<name>setMode</name>
<desc>setMode( String mode )</desc>
</method>
<method>
<name>setNodeDepth</name>
</method>
<method>
<name>setNodeNormal</name>
</method>
<method>
<name>setNodePosition</name>
</method>
<method>
<name>setNodeWidth</name>
</method>
<method>
<name>setSelectedRoad</name>
</method>
<field>
<name>bottomMaterialName</name>
<desc>Default Material used by the Mesh Road Editor on bottom surface road creation.</desc>
</field>
<field>
<name>DefaultDepth</name>
<desc>float DefaultDepth</desc>
</field>
<field>
<name>DefaultNormal</name>
<desc>Point3F DefaultNormal</desc>
</field>
<field>
<name>DefaultWidth</name>
<desc>float DefaultWidth</desc>
</field>
<field>
<name>HoverNodeColor</name>
<desc>ColorI HoverNodeColor</desc>
</field>
<field>
<name>HoverSplineColor</name>
<desc>ColorI HoverSplineColor</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>SelectedSplineColor</name>
<desc>ColorI SelectedSplineColor</desc>
</field>
<field>
<name>sideMaterialName</name>
<desc>Default Material used by the Mesh Road Editor on side surface road creation.</desc>
</field>
<field>
<name>topMaterialName</name>
<desc>Default Material used by the Mesh Road Editor on upper surface road creation.</desc>
</field>
</class>
<class>
<name>GuiMeshRoadEditorCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiMessageVectorCtrl</name>
<base>GuiControl</base>
<method>
<name>attach</name>
<args>( MessageVector item )</args>
<desc>@brief Push a line onto the back of the list.

Detailed description

@param param Description

@tsexample
// All messages are stored in this HudMessageVector, the actual
// MainChatHud only displays the contents of this vector.
new MessageVector(HudMessageVector);

// Attach the MessageVector to the chat control
chatHud.attach(HudMessageVector);
@endtsexample

@return Value</desc>
</method>
<method>
<name>detach</name>
<args>()</args>
<desc>@brief Stop listing messages from the MessageVector previously attached to, if any.

Detailed description

@param param Description

@tsexample
// Deatch the MessageVector from HudMessageVector
// HudMessageVector will no longer render the text
chatHud.detach();
@endtsexample</desc>
</method>
<field>
<name>allowedMatches</name>
<desc>string allowedMatches</desc>
</field>
<field>
<name>lineContinuedIndex</name>
<desc>int lineContinuedIndex</desc>
</field>
<field>
<name>lineSpacing</name>
<desc>int lineSpacing</desc>
</field>
<field>
<name>matchColor</name>
<desc>ColorI matchColor</desc>
</field>
<field>
<name>maxColorIndex</name>
<desc>int maxColorIndex</desc>
</field>
</class>
<class>
<name>GuiMessageVectorCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiMLTextCtrl</name>
<base>GuiControl</base>
<method>
<name>addText</name>
<args>( string text, bool reformat )</args>
<desc>@brief Appends the text in the control with additional text. Also .

@param text New text to append to the existing text.
@param reformat If true, the control will also be visually reset.
@tsexample
// Define new text to add
%text = "New Text to Add";

// Set reformat boolean
%reformat = "true";

// Inform the control to add the new text
%thisGuiMLTextCtrl.addText(%text,%reformat);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>forceReflow</name>
<args>()</args>
<desc>@brief Forces the text control to reflow the text after new text is added, possibly resizing the control.

@tsexample
// Define new text to add
%newText = "BACON!";

// Add the new text to the control
%thisGuiMLTextCtrl.addText(%newText);

// Inform the GuiMLTextCtrl object to force a reflow to ensure the added text fits properly.
%thisGuiMLTextCtrl.forceReflow();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>getText</name>
<args>()</args>
<desc>@brief Returns the text from the control, including TorqueML characters.

@tsexample
// Get the text displayed in the control
%controlText = %thisGuiMLTextCtrl.getText();
@endtsexample

@return Text string displayed in the control, including any TorqueML characters.

@see GuiControl</desc>
</method>
<method>
<name>scrollToBottom</name>
<args>()</args>
<desc>@brief Scroll to the bottom of the text.

@tsexample
// Inform GuiMLTextCtrl object to scroll to its bottom
%thisGuiMLTextCtrl.scrollToBottom();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>scrollToTag</name>
<args>( int tagID )</args>
<desc>@brief Scroll down to a specified tag.

Detailed description

@param tagID TagID to scroll the control to
@tsexample
// Define the TagID we want to scroll the control to
%tagId = "4";

// Inform the GuiMLTextCtrl to scroll to the defined TagID
%thisGuiMLTextCtrl.scrollToTag(%tagId);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>scrollToTop</name>
<args>( int param1, int param2 )</args>
<desc>@brief Scroll to the top of the text.

@tsexample
// Inform GuiMLTextCtrl object to scroll to its top
%thisGuiMLTextCtrl.scrollToTop();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setAlpha</name>
<args>( float alphaVal )</args>
<desc>@brief Sets the alpha value of the control.

@param alphaVal n - 1.0 floating value for the alpha
@tsexample
// Define the alphe value
%alphaVal = "0.5";

// Inform the control to update its alpha value.
%thisGuiMLTextCtrl.setAlpha(%alphaVal);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setCursorPosition</name>
<args>( int newPos )</args>
<desc>@brief Change the text cursor's position to a new defined offset within the text in the control.

@param newPos Offset to place cursor.
@tsexample
// Define cursor offset position
%position = "23";

// Inform the GuiMLTextCtrl object to move the cursor to the new position.
%thisGuiMLTextCtrl.setCursorPosition(%position);
@endtsexample

@return Returns true if the cursor position moved, or false if the position was not changed.

@see GuiControl</desc>
</method>
<method>
<name>setText</name>
<args>( string text )</args>
<desc>@brief Set the text contained in the control.

@param text The text to display in the control.
@tsexample
// Define the text to display
%text = "Nifty Control Text";

// Set the text displayed within the control
%thisGuiMLTextCtrl.setText(%text);
@endtsexample

@see GuiControl</desc>
</method>
<field>
<name>allowColorChars</name>
<desc>If true, the control will allow characters to have unique colors.</desc>
</field>
<field>
<name>deniedSound</name>
<desc>If the text will not fit in the control, the deniedSound is played.</desc>
</field>
<field>
<name>lineSpacing</name>
<desc>The number of blank pixels to place between each line.</desc>
</field>
<field>
<name>maxChars</name>
<desc>Maximum number of characters that the control will display.</desc>
</field>
<field>
<name>onResize( string width, string maxY )</name>
<desc>@brief Called whenever the control size changes.

@param width The new width value for the control
@param maxY The current maximum allowed Y value for the control

@tsexample
// Control size changed, causing the callback to occur.
GuiMLTextCtrl::onResize(%this,%width,%maxY)
^{
^^// Code to call when the control size changes
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onURL( string url )</name>
<desc>@brief Called whenever a URL was clicked on within the control.

@param url The URL address that was clicked on.
@tsexample
// A URL address was clicked on in the control, causing the callback to occur.
GuiMLTextCtrl::onUrl(%this,%url)
^{
^^// Code to run whenever a URL was clicked on
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>text</name>
<desc>Text to display in this control.</desc>
</field>
<field>
<name>useURLMouseCursor</name>
<desc>If true, the mouse cursor will turn into a hand cursor while over a link in the text.
This is dependant on the markup language used by the GuiMLTextCtrl</desc>
</field>
</class>
<class>
<name>GuiMLTextCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiMLTextEditCtrl</name>
<base>GuiMLTextCtrl</base>
<field>
<name>escapeCommand</name>
<desc>Script function to run whenever the 'escape' key is pressed when this control is in focus.</desc>
</field>
</class>
<class>
<name>GuiMLTextEditCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiMouseEventCtrl</name>
<base>GuiControl</base>
<field>
<name>lockMouse</name>
<desc>Whether the control should lock the mouse between up and down button events.</desc>
</field>
<field>
<name>onMouseDown( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the mouse is pressed down while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse was pressed down in this control, causing the callback
GuiMouseEventCtrl::onMouseDown(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onMouseDragged( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the mouse is dragged while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse was dragged in this control, causing the callback
GuiMouseEventCtrl::onMouseDragged(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onMouseEnter( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the mouse enters this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse entered this control, causing the callback
GuiMouseEventCtrl::onMouseEnter(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onMouseLeave( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the mouse leaves this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse left this control, causing the callback
GuiMouseEventCtrl::onMouseLeave(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onMouseMove( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the mouse is moved (without dragging) while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse was moved in this control, causing the callback
GuiMouseEventCtrl::onMouseMove(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onMouseUp( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the mouse is released while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Mouse was released in this control, causing the callback
GuiMouseEventCtrl::onMouseUp(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onRightMouseDown( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the right mouse button is pressed while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Right mouse button was pressed in this control, causing the callback
GuiMouseEventCtrl::onRightMouseDown(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onRightMouseDragged( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the mouse is dragged in this control while the right mouse button is pressed.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Right mouse button was dragged in this control, causing the callback
GuiMouseEventCtrl::onRightMouseDragged(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onRightMouseUp( U8 modifier, Point2I mousePoint, U8 mouseClickCount )</name>
<desc>@brief Callback that occurs whenever the right mouse button is released while in this control.

@param modifier Key that was pressed during this callback. Values are:

$EventModifier::RSHIFT

$EventModifier::SHIFT

$EventModifier::LCTRL

$EventModifier::RCTRL

$EventModifier::CTRL

$EventModifier::CTRL

$EventModifier::RALT

$EventModifier::ALT

@param mousePoint X/Y location of the mouse point
@param mouseClickCount How many mouse clicks have occured for this event

@tsexample
// Right mouse button was released in this control, causing the callback
GuiMouseEventCtrl::onRightMouseUp(%this,%modifier,%mousePoint,%mouseClickCount)
{
^// Code to call when a mouse event occurs.
}
@endtsexample

@see GuiControl</desc>
</field>
</class>
<class>
<name>GuiMouseEventCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiNoMouseCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiNoMouseCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiObjectView</name>
<base>GuiTSCtrl</base>
<method>
<name>getCameraSpeed</name>
<args>()</args>
<desc>@brief Return the current multiplier for camera zooming and rotation.

@tsexample
// Request the current camera zooming and rotation multiplier value
%multiplier = %thisGuiObjectView.getCameraSpeed();
@endtsexample

@return Camera zooming / rotation multiplier value.

@see GuiControl</desc>
</method>
<method>
<name>getModel</name>
<args>()</args>
<desc>@brief Return the model displayed in this view.

@tsexample
// Request the displayed model name from the GuiObjectView object.
%modelName = %thisGuiObjectView.getModel();
@endtsexample

@return Name of the displayed model.

@see GuiControl</desc>
</method>
<method>
<name>getMountedModel</name>
<args>()</args>
<desc>@brief Return the name of the mounted model.

@tsexample
// Request the name of the mounted model from the GuiObjectView object
%mountedModelName = %thisGuiObjectView.getMountedModel();
@endtsexample

@return Name of the mounted model.

@see GuiControl</desc>
</method>
<method>
<name>getMountSkin</name>
<args>( int param1, int param2 )</args>
<desc>@brief Return the name of skin used on the mounted model.

@tsexample
// Request the skin name from the model mounted on to the main model in the control
%mountModelSkin = %thisGuiObjectView.getMountSkin();
@endtsexample

@return Name of the skin used on the mounted model.

@see GuiControl</desc>
</method>
<method>
<name>getOrbitDistance</name>
<args>()</args>
<desc>@brief Return the current distance at which the camera orbits the object.

@tsexample
// Request the current orbit distance
%orbitDistance = %thisGuiObjectView.getOrbitDistance();
@endtsexample

@return The distance at which the camera orbits the object.

@see GuiControl</desc>
</method>
<method>
<name>getSkin</name>
<args>()</args>
<desc>@brief Return the name of skin used on the primary model.

@tsexample
// Request the name of the skin used on the primary model in the control
%skinName = %thisGuiObjectView.getSkin();
@endtsexample

@return Name of the skin used on the primary model.

@see GuiControl</desc>
</method>
<method>
<name>setCameraSpeed</name>
<args>( float factor )</args>
<desc>@brief Sets the multiplier for the camera rotation and zoom speed.

@param factor Multiplier for camera rotation and zoom speed.
@tsexample
// Set the factor value
%factor = "0.75";

// Inform the GuiObjectView object to set the camera speed.
%thisGuiObjectView.setCameraSpeed(%factor);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setLightAmbient</name>
<args>( ColorF color )</args>
<desc>@brief Set the light ambient color on the sun object used to render the model.

@param color Ambient color of sunlight.
@tsexample
// Define the sun ambient color value
%color = "1.0 0.4 0.6";

// Inform the GuiObjectView object to set the sun ambient color to the requested value
%thisGuiObjectView.setLightAmbient(%color);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setLightColor</name>
<args>( ColorF color )</args>
<desc>@brief Set the light color on the sun object used to render the model.

@param color Color of sunlight.
@tsexample
// Set the color value for the sun
%color = "1.0 0.4 0.5";

// Inform the GuiObjectView object to change the sun color to the defined value
%thisGuiObjectView.setLightColor(%color);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setLightDirection</name>
<args>( Point3F direction )</args>
<desc>@brief Set the light direction from which to light the model.

@param direction XYZ direction from which the light will shine on the model
@tsexample
// Set the light direction
%direction = "1.0 0.2 0.4"

// Inform the GuiObjectView object to change the light direction to the defined value
%thisGuiObjectView.setLightDirection(%direction);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setModel</name>
<args>( string shapeName )</args>
<desc>@brief Sets the model to be displayed in this control.

@param shapeName Name of the model to display.
@tsexample
// Define the model we want to display
%shapeName = "gideon.dts";

// Tell the GuiObjectView object to display the defined model
%thisGuiObjectView.setModel(%shapeName);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setMount</name>
<args>( string shapeName, string mountNodeIndexOrName )</args>
<desc>@brief Mounts the given model to the specified mount point of the primary model displayed in this control.

Detailed description

@param shapeName Name of the model to mount.
@param mountNodeIndexOrName Index or name of the mount point to be mounted to. If index, corresponds to "mountN" in your shape where N is the number passed here.
@tsexample
// Set the shapeName to mount
%shapeName = "GideonGlasses.dts"

// Set the mount node of the primary model in the control to mount the new shape at
%mountNodeIndexOrName = "3";
//OR:
%mountNodeIndexOrName = "Face";

// Inform the GuiObjectView object to mount the shape at the specified node.
%thisGuiObjectView.setMount(%shapeName,%mountNodeIndexOrName);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setMountedModel</name>
<args>( string shapeName )</args>
<desc>@brief Sets the model to be mounted on the primary model.

@param shapeName Name of the model to mount.
@tsexample
// Define the model name to mount
%modelToMount = "GideonGlasses.dts";

// Inform the GuiObjectView object to mount the defined model to the existing model in the control
%thisGuiObjectView.setMountedModel(%modelToMount);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setMountSkin</name>
<args>( string skinName )</args>
<desc>@brief Sets the skin to use on the mounted model.

@param skinName Name of the skin to set on the model mounted to the main model in the control
@tsexample
// Define the name of the skin
%skinName = "BronzeGlasses";

// Inform the GuiObjectView Control of the skin to use on the mounted model
%thisGuiObjectViewCtrl.setMountSkin(%skinName);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setOrbitDistance</name>
<args>( float distance )</args>
<desc>@brief Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.

Detailed description

@param distance The distance to set the orbit to (will be clamped).
@tsexample
// Define the orbit distance value
%orbitDistance = "1.5";

// Inform the GuiObjectView object to set the orbit distance to the defined value
%thisGuiObjectView.setOrbitDistance(%orbitDistance);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setSeq</name>
<args>( string indexOrName )</args>
<desc>@brief Sets the animation to play for the viewed object.

@param indexOrName The index or name of the animation to play.
@tsexample
// Set the animation index value, or animation sequence name.
%indexVal = "3";
//OR:
%indexVal = "idle";

// Inform the GuiObjectView object to set the animation sequence of the object in the control.
%thisGuiObjectVew.setSeq(%indexVal);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setSkin</name>
<args>( string skinName )</args>
<desc>@brief Sets the skin to use on the model being displayed.

@param skinName Name of the skin to use.
@tsexample
// Define the skin we want to apply to the main model in the control
%skinName = "disco_gideon";

// Inform the GuiObjectView control to update the skin the to defined skin
%thisGuiObjectView.setSkin(%skinName);
@endtsexample

@see GuiControl</desc>
</method>
<field>
<name>animSequence</name>
<desc>The animation sequence to play on the model.</desc>
</field>
<field>
<name>cameraSpeed</name>
<desc>Multiplier for mouse camera operations.</desc>
</field>
<field>
<name>lightAmbient</name>
<desc>Ambient color of the sunlight used to render the model.</desc>
</field>
<field>
<name>lightColor</name>
<desc>Diffuse color of the sunlight used to render the model.</desc>
</field>
<field>
<name>lightDirection</name>
<desc>Direction from which the model is illuminated.</desc>
</field>
<field>
<name>maxOrbitDiststance</name>
<desc>Minimum distance below which the camera will not zoom in further.</desc>
</field>
<field>
<name>minOrbitDiststance</name>
<desc>Maxiumum distance to which the camera can be zoomed out.</desc>
</field>
<field>
<name>mountedNode</name>
<desc>Name of node on primary model to which to mount the secondary shape.</desc>
</field>
<field>
<name>mountedShapeFile</name>
<desc>Optional shape file to mount on the primary model (e.g. weapon).</desc>
</field>
<field>
<name>mountedSkin</name>
<desc>Skin name used on mounted shape file.</desc>
</field>
<field>
<name>onMouseEnter()</name>
<desc>@brief Called whenever the mouse enters the control.

@tsexample
// The mouse has entered the control, causing the callback to occur
GuiObjectView::onMouseEnter(%this)
^{
^^// Code to run when the mouse enters this control
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onMouseLeave()</name>
<desc>@brief Called whenever the mouse leaves the control.

@tsexample
// The mouse has left the control, causing the callback to occur
GuiObjectView::onMouseLeave(%this)
^{
^^// Code to run when the mouse leaves this control
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>orbitDiststance</name>
<desc>Distance from which to render the model.</desc>
</field>
<field>
<name>shapeFile</name>
<desc>The object model shape file to show in the view.</desc>
</field>
<field>
<name>skin</name>
<desc>The skin to use on the object model.</desc>
</field>
</class>
<class>
<name>GuiObjectViewClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiPaneControl</name>
<base>GuiControl</base>
<method>
<name>setCollapsed</name>
<args>( bool collapse )</args>
<desc>Collapse or un-collapse the control.

@param collapse True to collapse the control, false to un-collapse it</desc>
</method>
<field>
<name>barBehindText</name>
<desc>Whether to draw the bitmapped pane bar behind the header text, too.</desc>
</field>
<field>
<name>caption</name>
<desc>Text label to display as the pane header.</desc>
</field>
<field>
<name>captionID</name>
<desc>String table text ID to use as caption string (overrides 'caption').</desc>
</field>
<field>
<name>collapsable</name>
<desc>Whether the pane can be collapsed by clicking its header.</desc>
</field>
</class>
<class>
<name>GuiPaneControlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiPanel</name>
<base>GuiContainer</base>
</class>
<class>
<name>GuiPanelClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiParticleGraphCtrl</name>
<base>GuiControl</base>
<method>
<name>addPlotPoint</name>
<args>(int plotID, float x, float y, bool setAdded = true;)</args>
<desc>Add a data point to the given plot.@return</desc>
</method>
<method>
<name>changePlotPoint</name>
<args>(int plotID, int i, float x, float y)</args>
<desc>Change a data point to the given plot and plot position.
@param plotID The plot you want to access
@param i The data point.
@param x,y The plot position.
@return No return value.</desc>
</method>
<method>
<name>clearAllGraphs</name>
<args>()</args>
<desc>Clear all of the graphs.@return No return value</desc>
</method>
<method>
<name>clearGraph</name>
<args>(int plotID)</args>
<desc>Clear the graph of the given plot.@return No return value</desc>
</method>
<method>
<name>getGraphColor</name>
<args>(int plotID)</args>
<desc>Get the color of the graph passed.@return Returns the color of the graph as a string of RGB values formatted as "R G B"</desc>
</method>
<method>
<name>getGraphMax</name>
<args>(int plotID)</args>
<desc>Get the maximum values of the graph ranges.
@return Returns the maximum of the range formatted as "x-max y-max"</desc>
</method>
<method>
<name>getGraphMin</name>
<args>(int plotID)</args>
<desc>Get the minimum values of the graph ranges.
@return Returns the minimum of the range formatted as "x-min y-min"</desc>
</method>
<method>
<name>getGraphName</name>
<args>(int plotID)</args>
<desc>Get the name of the graph passed.
@return Returns the name of the plot</desc>
</method>
<method>
<name>getPlotIndex</name>
<args>(int plotID, float x, float y)</args>
<desc>Gets the index of the point passed on the plotID passed (graph ID).
@param plotID The plot you wish to check.
@param x,y The coordinates of the point to get.
@return Returns the index of the point.</desc>
</method>
<method>
<name>getPlotPoint</name>
<args>(int plotID, int samples)</args>
<desc>Get a data point from the plot specified, samples from the start of the graph.@return The data point ID</desc>
</method>
<method>
<name>getSelectedPlot</name>
<args>()</args>
<desc>Gets the selected Plot (a.k.a. graph).
@return The plot's ID.</desc>
</method>
<method>
<name>getSelectedPoint</name>
<args>()</args>
<desc>Gets the selected Point on the Plot (a.k.a. graph).@return The last selected point ID</desc>
</method>
<method>
<name>insertPlotPoint</name>
<args>(int plotID, int i, float x, float y)</args>
<desc>Insert a data point to the given plot and plot position.
@param plotID The plot you want to access
@param i The data point.
@param x,y The plot position.
@return No return value.</desc>
</method>
<method>
<name>isExistingPoint</name>
<args>(int plotID, int samples)</args>
<desc>@return Returns true or false whether or not the point in the plot passed is an existing point.</desc>
</method>
<method>
<name>resetSelectedPoint</name>
<args>()</args>
<desc>This will reset the currently selected point to nothing.@return No return value.</desc>
</method>
<method>
<name>setAutoGraphMax</name>
<args>(bool autoMax)</args>
<desc>Set whether the max will automatically be set when adding points (ie if you add a value over the current max, the max is increased to that value).
@return No return value.</desc>
</method>
<method>
<name>setAutoRemove</name>
<args>(bool autoRemove)</args>
<desc>Set whether or not a point should be deleted when you drag another one over it.@return No return value.</desc>
</method>
<method>
<name>setGraphHidden</name>
<args>(int plotID, bool isHidden)</args>
<desc>Set whether the graph number passed is hidden or not.@return No return value.</desc>
</method>
<method>
<name>setGraphMax</name>
<args>(int plotID, float maxX, float maxY)</args>
<desc>Set the max values of the graph of plotID.@param plotID The plot to modify
@param maxX,maxY The maximum bound of the value range.
@return No return value.</desc>
</method>
<method>
<name>setGraphMaxX</name>
<args>(int plotID, float maxX)</args>
<desc>Set the max X value of the graph of plotID.@param plotID The plot to modify.
@param maxX The maximum x value.
@return No return Value.</desc>
</method>
<method>
<name>setGraphMaxY</name>
<args>(int plotID, float maxY)</args>
<desc>Set the max Y value of the graph of plotID.@param plotID The plot to modify.
@param maxY The maximum y value.
@return No return Value.</desc>
</method>
<method>
<name>setGraphMin</name>
<args>(int plotID, float minX, float minY)</args>
<desc>Set the min values of the graph of plotID.
@param plotID The plot to modify
@param minX,minY The minimum bound of the value range.
@return No return value.</desc>
</method>
<method>
<name>setGraphMinX</name>
<args>(int plotID, float minX)</args>
<desc>Set the min X value of the graph of plotID.
@param plotID The plot to modify.
@param minX The minimum x value.
@return No return Value.</desc>
</method>
<method>
<name>setGraphMinY</name>
<args>(int plotID, float minY)</args>
<desc>Set the min Y value of the graph of plotID.@param plotID The plot to modify.
@param minY The minimum y value.
@return No return Value.</desc>
</method>
<method>
<name>setGraphName</name>
<args>(int plotID, string graphName)</args>
<desc>Set the name of the given plot.
@param plotID The plot to modify.
@param graphName The name to set on the plot.
@return No return value.</desc>
</method>
<method>
<name>setPointXMovementClamped</name>
<args>(bool clamped)</args>
<desc>Set whether the x position of the selected graph point should be clamped@return No return value.</desc>
</method>
<method>
<name>setRenderAll</name>
<args>(bool renderAll)</args>
<desc>Set whether or not a position should be rendered on every point or just the last selected.@return No return value.</desc>
</method>
<method>
<name>setRenderGraphTooltip</name>
<args>(bool renderGraphTooltip)</args>
<desc>Set whether or not to render the graph tooltip.@return No return value.</desc>
</method>
<method>
<name>setSelectedPlot</name>
<args>(int plotID)</args>
<desc>Set the selected plot (a.k.a. graph).@return No return value</desc>
</method>
<method>
<name>setSelectedPoint</name>
<args>(int point)</args>
<desc>Set the selected point on the graph.
@return No return value</desc>
</method>
</class>
<class>
<name>GuiParticleGraphCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiPopUpMenuCtrl</name>
<base>GuiTextCtrl</base>
<method>
<name>add</name>
<args>(string name, int idNum, int scheme=0)</args>
</method>
<method>
<name>addScheme</name>
<args>(int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL)</args>
</method>
<method>
<name>changeTextById</name>
<args>( int id, string text )</args>
</method>
<method>
<name>clear</name>
<desc>Clear the popup list.</desc>
</method>
<method>
<name>clearEntry</name>
<args>(S32 entry)</args>
</method>
<method>
<name>findText</name>
<args>(string text)</args>
<desc>Returns the position of the first entry containing the specified text.</desc>
</method>
<method>
<name>forceClose</name>
</method>
<method>
<name>forceOnAction</name>
</method>
<method>
<name>getSelected</name>
</method>
<method>
<name>getText</name>
</method>
<method>
<name>getTextById</name>
<args>(int id)</args>
</method>
<method>
<name>replaceText</name>
<args>(bool doReplaceText)</args>
</method>
<method>
<name>setEnumContent</name>
<args>(string class, string enum)</args>
<desc>This fills the popup with a classrep's field enumeration type info.

More of a helper function than anything.   If console access to the field list is added, at least for the enumerated types, then this should go away..</desc>
</method>
<method>
<name>setFirstSelected</name>
<args>([scriptCallback=true])</args>
</method>
<method>
<name>setNoneSelected</name>
</method>
<method>
<name>setSelected</name>
<args>(int id, [scriptCallback=true])</args>
</method>
<method>
<name>size</name>
<desc>Get the size of the menu - the number of entries in it.</desc>
</method>
<method>
<name>sort</name>
<desc>Sort the list alphabetically.</desc>
</method>
<method>
<name>sortID</name>
<desc>Sort the list by ID.</desc>
</method>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
<field>
<name>bitmapBounds</name>
<desc>Point2I bitmapBounds</desc>
</field>
<field>
<name>maxPopupHeight</name>
<desc>int maxPopupHeight</desc>
</field>
<field>
<name>reverseTextList</name>
<desc>bool reverseTextList</desc>
</field>
<field>
<name>sbUsesNAColor</name>
<desc>bool sbUsesNAColor</desc>
</field>
</class>
<class>
<name>GuiPopUpMenuCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiPopUpMenuCtrlEx</name>
<base>GuiTextCtrl</base>
<method>
<name>add</name>
<args>(string name, int idNum, int scheme=0)</args>
</method>
<method>
<name>addCategory</name>
<args>( string text )</args>
<desc>@brief Add a category to the list.

Acts as a separator between entries, allowing for sub-lists

@param text Name of the new category</desc>
</method>
<method>
<name>addScheme</name>
<args>( int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL )</args>
<desc>@brief Create a new scheme and add it to the list of choices for when a new text entry is added.

@param id Numerical id associated with this scheme
@param fontColor The base text font color. Formatted as "Red Green Blue", each a numerical between 0 and 255.
@param fontColorHL Color of text when being highlighted. Formatted as "Red Green Blue", each a numerical between 0 and 255.
@param fontColorSel Color of text when being selected. Formatted as "Red Green Blue", each a numerical between 0 and 255.</desc>
</method>
<method>
<name>clear</name>
<args>()</args>
<desc>@brief Clear the popup list.</desc>
</method>
<method>
<name>clearEntry</name>
<args>(S32 entry)</args>
</method>
<method>
<name>findText</name>
<args>(string text)</args>
<desc>Returns the id of the first entry containing the specified text or -1 if not found.@param text String value used for the query

@return Numerical ID of entry containing the text.</desc>
</method>
<method>
<name>forceClose</name>
<args>()</args>
<desc>@brief Manually force this control to collapse and close.</desc>
</method>
<method>
<name>forceOnAction</name>
<args>()</args>
<desc>@brief Manually for the onAction function, which updates everything in this control.</desc>
</method>
<method>
<name>getColorById</name>
<desc>@brief Get color of an entry's box

@param id ID number of entry to query

@return ColorI in the format of "Red Green Blue Alpha", each of with is a value between 0 - 255</desc>
</method>
<method>
<name>getSelected</name>
<args>()</args>
<desc>@brief Get the current selection of the menu.

@return Returns the ID of the currently selected entry</desc>
</method>
<method>
<name>getText</name>
<args>()</args>
<desc>@brief Get the.

Detailed description

@param param Description

@tsexample
// Comment
code();
@endtsexample

@return Returns current text in string format</desc>
</method>
<method>
<name>getTextById</name>
<args>( int id )</args>
<desc>@brief Get the text of an entry based on an ID.

@param id The ID assigned to the entry being queried

@return String contained by the specified entry, NULL if empty or bad ID</desc>
</method>
<method>
<name>replaceText</name>
<desc>@brief Flag that causes each new text addition to replace the current entry

@param True to turn on replacing, false to disable it</desc>
</method>
<method>
<name>setEnumContent</name>
<desc>@brief This fills the popup with a classrep's field enumeration type info.

More of a helper function than anything.   If console access to the field list is added, at least for the enumerated types, then this should go away.

@param class Name of the class containing the enum
@param enum Name of the enum value to acces</desc>
</method>
<method>
<name>setFirstSelected</name>
<args>([scriptCallback=true])</args>
<desc>@hide</desc>
</method>
<method>
<name>setNoneSelected</name>
<args>( int param )</args>
<desc>@brief Clears selection in the menu.</desc>
</method>
<method>
<name>setSelected</name>
<args>(int id, [scriptCallback=true])</args>
<desc>@hide</desc>
</method>
<method>
<name>setText</name>
<args>( string text )</args>
<desc>@brief Set the current text to a specified value.

@param text String containing new text to set</desc>
</method>
<method>
<name>size</name>
<desc>@brief Get the size of the menu

@return Number of entries in the menu</desc>
</method>
<method>
<name>sort</name>
<args>()</args>
<desc>@brief Sort the list alphabetically.</desc>
</method>
<method>
<name>sortID</name>
<args>()</args>
<desc>@brief Sort the list by ID.</desc>
</method>
<field>
<name>bitmap</name>
<desc>File name of bitmap to use</desc>
</field>
<field>
<name>bitmapBounds</name>
<desc>Boundaries of bitmap displayed</desc>
</field>
<field>
<name>hotTrackCallback</name>
<desc>Whether to provide a 'onHotTrackItem' callback when a list item is hovered over</desc>
</field>
<field>
<name>maxPopupHeight</name>
<desc>Length of menu when it extends</desc>
</field>
<field>
<name>reverseTextList</name>
<desc>Reverses text list if popup extends up, instead of down</desc>
</field>
<field>
<name>sbUsesNAColor</name>
<desc>Deprecated@internal</desc>
</field>
</class>
<class>
<name>GuiPopUpMenuCtrlExClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiProgressBitmapCtrl</name>
<base>GuiTextCtrl</base>
<method>
<name>setBitmap</name>
<args>( string filename )</args>
<desc>Set the bitmap to use for rendering the progress bar.

@param filename ~Path to the bitmap file.

@note Directly assign to #bitmap rather than using this method.

@see GuiProgressBitmapCtrl::setBitmap</desc>
</method>
<field>
<name>bitmap</name>
<desc>~Path to the bitmap file to use for rendering the progress bar.

If the profile assigned to the control already has a bitmap assigned, this property need not be set in which case the bitmap from the profile is used.</desc>
</field>
</class>
<class>
<name>GuiProgressBitmapCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiProgressCtrl</name>
<base>GuiTextCtrl</base>
</class>
<class>
<name>GuiProgressCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiRadioCtrl</name>
<base>GuiCheckBoxCtrl</base>
</class>
<class>
<name>GuiRadioCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiRectHandles</name>
<base>GuiControl</base>
<field>
<name>handleColor</name>
<desc>Use given custom color for handles.</desc>
</field>
<field>
<name>handleRect</name>
<desc>RectF of handle's box.</desc>
</field>
<field>
<name>handleSize</name>
<desc>Size of handles in pixels.</desc>
</field>
<field>
<name>useCustomColor</name>
<desc>Use given custom color for handles.</desc>
</field>
</class>
<class>
<name>GuiRectHandlesClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiRiverEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteNode</name>
<desc>deleteNode()</desc>
</method>
<method>
<name>getMode</name>
</method>
<method>
<name>getNodeDepth</name>
</method>
<method>
<name>getNodeNormal</name>
</method>
<method>
<name>getNodePosition</name>
</method>
<method>
<name>getNodeWidth</name>
</method>
<method>
<name>getSelectedRiver</name>
</method>
<method>
<name>regenerate</name>
</method>
<method>
<name>setMode</name>
<desc>setMode( String mode )</desc>
</method>
<method>
<name>setNodeDepth</name>
</method>
<method>
<name>setNodeNormal</name>
</method>
<method>
<name>setNodePosition</name>
</method>
<method>
<name>setNodeWidth</name>
</method>
<method>
<name>setSelectedRiver</name>
</method>
<field>
<name>DefaultDepth</name>
<desc>float DefaultDepth</desc>
</field>
<field>
<name>DefaultNormal</name>
<desc>Point3F DefaultNormal</desc>
</field>
<field>
<name>DefaultWidth</name>
<desc>float DefaultWidth</desc>
</field>
<field>
<name>HoverNodeColor</name>
<desc>ColorI HoverNodeColor</desc>
</field>
<field>
<name>HoverSplineColor</name>
<desc>ColorI HoverSplineColor</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>SelectedSplineColor</name>
<desc>ColorI SelectedSplineColor</desc>
</field>
</class>
<class>
<name>GuiRiverEditorCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiRoadEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteNode</name>
<desc>deleteNode()</desc>
</method>
<method>
<name>deleteRoad</name>
</method>
<method>
<name>getMode</name>
</method>
<method>
<name>getNodePosition</name>
</method>
<method>
<name>getNodeWidth</name>
</method>
<method>
<name>getSelectedNode</name>
</method>
<method>
<name>getSelectedRoad</name>
</method>
<method>
<name>setMode</name>
<desc>setMode( String mode )</desc>
</method>
<method>
<name>setNodePosition</name>
</method>
<method>
<name>setNodeWidth</name>
</method>
<method>
<name>setSelectedRoad</name>
</method>
<field>
<name>DefaultWidth</name>
<desc>float DefaultWidth</desc>
</field>
<field>
<name>HoverNodeColor</name>
<desc>ColorI HoverNodeColor</desc>
</field>
<field>
<name>HoverSplineColor</name>
<desc>ColorI HoverSplineColor</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>materialName</name>
<desc>Default Material used by the Road Editor on road creation.</desc>
</field>
<field>
<name>SelectedSplineColor</name>
<desc>ColorI SelectedSplineColor</desc>
</field>
</class>
<class>
<name>GuiRoadEditorCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiRolloutCtrl</name>
<base>GuiControl</base>
<method>
<name>collapse</name>
<args>()</args>
<desc>Collapse the rollout if it is currently expanded.  This will make the rollout's child control invisible.

@note The rollout will animate to collapsed state.  To instantly collapse without animation, use instantCollapse().</desc>
</method>
<method>
<name>expand</name>
<args>()</args>
<desc>Expand the rollout if it is currently collapsed.  This will make the rollout's child control visible.

@note The rollout will animate to expanded state.  To instantly expand without animation, use instantExpand().</desc>
</method>
<method>
<name>instantCollapse</name>
<args>()</args>
<desc>Instantly collapse the rollout without animation.  To smoothly slide the rollout to collapsed state, use collapse().</desc>
</method>
<method>
<name>instantExpand</name>
<args>()</args>
<desc>Instantly expand the rollout without animation.  To smoothly slide the rollout to expanded state, use expand().</desc>
</method>
<method>
<name>isExpanded</name>
<args>()</args>
<desc>Determine whether the rollout is currently expanded, i.e. whether the child control is visible.

@return True if the rollout is expanded, false if not.</desc>
</method>
<method>
<name>sizeToContents</name>
<args>()</args>
<desc>Resize the rollout to exactly fit around its child control.  This can be used to manually trigger a recomputation of the rollout size.</desc>
</method>
<method>
<name>toggleCollapse</name>
<args>()</args>
<desc>Toggle the current collapse state of the rollout.  If it is currently expanded, then collapse it.  If it is currently collapsed, then expand it.</desc>
</method>
<method>
<name>toggleExpanded</name>
<args>( bool instantly=false )</args>
<desc>Toggle the current expansion state of the rollout  If it is currently expanded, then collapse it.  If it is currently collapsed, then expand it.

@param instant If true, the rollout will toggle its state without animation.  Otherwise, the rollout will smoothly slide into the opposite state.</desc>
</method>
<field>
<name>autoCollapseSiblings</name>
<desc>Whether to automatically collapse sibling rollouts.

If this is true, the rollout will automatically collapse all sibling rollout controls when it is expanded.  If this is false, the auto-collapse behavior can be triggered by CTRL (CMD on MAC) clicking the rollout header.  CTRL/CMD clicking also works if this is false, in which case the auto-collapsing of sibling controls will be temporarily deactivated.</desc>
</field>
<field>
<name>caption</name>
<desc>Text label to display on the rollout header.</desc>
</field>
<field>
<name>clickCollapse</name>
<desc>Whether the rollout can be collapsed by clicking its header.</desc>
</field>
<field>
<name>defaultHeight</name>
<desc>Default height of the client area.  This is used when no child control has been added to the rollout.</desc>
</field>
<field>
<name>expanded</name>
<desc>The current rollout expansion state.</desc>
</field>
<field>
<name>hideHeader</name>
<desc>Whether to render the rollout header.

@note If this is false, the user cannot toggle the rollout state with the mouse.</desc>
</field>
<field>
<name>margin</name>
<desc>Margin to put around child control.</desc>
</field>
<field>
<name>onCollapsed()</name>
<desc>Called when the rollout is collapsed.</desc>
</field>
<field>
<name>onExpanded()</name>
<desc>Called when the rollout is expanded.</desc>
</field>
<field>
<name>onHeaderRightClick()</name>
<desc>Called when the user right-clicks on the rollout's header.  This is useful for implementing context menus for rollouts.</desc>
</field>
</class>
<class>
<name>GuiRolloutCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiScriptNotifyCtrl</name>
<base>GuiControl</base>
<field>
<name>onChildAdded</name>
<desc>Enables/disables onChildAdded callback</desc>
</field>
<field>
<name>onChildAdded( SimObjectId ID, SimObjectId childID )</name>
<desc>Called when a child is added to this GUI.

@param ID Unique object ID assigned when created (%this in script).
@param childID Unique object ID of child being added.</desc>
</field>
<field>
<name>onChildRemoved</name>
<desc>Enables/disables onChildRemoved callback</desc>
</field>
<field>
<name>onChildRemoved( SimObjectId ID, SimObjectId childID )</name>
<desc>Called when a child is removed from this GUI.

@param ID Unique object ID assigned when created (%this in script).
@param childID Unique object ID of child being removed.</desc>
</field>
<field>
<name>onChildResized</name>
<desc>Enables/disables onChildResized callback</desc>
</field>
<field>
<name>onChildResized( SimObjectId ID, SimObjectId childID )</name>
<desc>Called when a child is of this GUI is being resized.

@param ID Unique object ID assigned when created (%this in script).
@param childID Unique object ID of child being resized.</desc>
</field>
<field>
<name>onGainFirstResponder</name>
<desc>Enables/disables onGainFirstResponder callback</desc>
</field>
<field>
<name>onGainFirstResponder( SimObjectId ID )</name>
<desc>Called when this GUI gains focus.

@param ID Unique object ID assigned when created (%this in script).</desc>
</field>
<field>
<name>onLoseFirstResponder</name>
<desc>Enables/disables onLoseFirstResponder callback</desc>
</field>
<field>
<name>onLoseFirstResponder( SimObjectId ID )</name>
<desc>Called when this GUI loses focus.

@param ID Unique object ID assigned when created (%this in script).</desc>
</field>
<field>
<name>onParentResized</name>
<desc>Enables/disables onParentResized callback</desc>
</field>
<field>
<name>onParentResized( SimObjectId ID )</name>
<desc>Called when this GUI's parent is resized.

@param ID Unique object ID assigned when created (%this in script).</desc>
</field>
<field>
<name>onResize</name>
<desc>Enables/disables onResize callback</desc>
</field>
<field>
<name>onResize( SimObjectId ID )</name>
<desc>Called when this GUI is resized.

@param ID Unique object ID assigned when created (%this in script).</desc>
</field>
</class>
<class>
<name>GuiScriptNotifyCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiScrollCtrl</name>
<base>GuiContainer</base>
<method>
<name>computeSizes</name>
<args>()</args>
<desc>Refresh sizing and positioning of child controls.</desc>
</method>
<method>
<name>getScrollPosition</name>
<args>()</args>
<desc>Get the current coordinates of the scrolled content.

@return The current position of the scrolled content.</desc>
</method>
<method>
<name>getScrollPositionX</name>
<args>()</args>
<desc>Get the current X coordinate of the scrolled content.

@return The current X coordinate of the scrolled content.</desc>
</method>
<method>
<name>getScrollPositionY</name>
<args>()</args>
<desc>Get the current Y coordinate of the scrolled content.@return The current Y coordinate of the scrolled content.</desc>
</method>
<method>
<name>scrollToBottom</name>
<args>()</args>
<desc>Scroll all the way to the bottom of the vertical scrollbar and the left of the horizontal bar.</desc>
</method>
<method>
<name>scrollToObject</name>
<args>( GuiControl control )</args>
<desc>Scroll the control so that the given child @a control is visible.

@param control A child control.</desc>
</method>
<method>
<name>scrollToTop</name>
<args>()</args>
<desc>Scroll all the way to the top of the vertical and left of the horizontal scrollbar.</desc>
</method>
<method>
<name>setScrollPosition</name>
<args>( int x, int y )</args>
<desc>Set the position of the scrolled content.

@param x Position on X axis.
@param y Position on y axis.</desc>
</method>
<field>
<name>childMargin</name>
<desc>Padding region to put around child contents.</desc>
</field>
<field>
<name>constantThumbHeight</name>
<desc>bool constantThumbHeight</desc>
</field>
<field>
<name>hScrollBar</name>
<desc>When to display the horizontal scrollbar.</desc>
</field>
<field>
<name>lockHorizScroll</name>
<desc>Horizontal scrolling not allowed if set.</desc>
</field>
<field>
<name>lockVertScroll</name>
<desc>Vertical scrolling not allowed if set.</desc>
</field>
<field>
<name>mouseWheelScrollSpeed</name>
<desc>Pixels/Tick - if not positive then mousewheel scrolling occurs instantly (like other scrolling).</desc>
</field>
<field>
<name>onScroll()</name>
<desc>Called each time the child controls are scrolled by some amount.</desc>
</field>
<field>
<name>vScrollBar</name>
<desc>When to display the vertical scrollbar.</desc>
</field>
<field>
<name>willFirstRespond</name>
<desc>bool willFirstRespond</desc>
</field>
</class>
<class>
<name>GuiScrollCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiSeparatorCtrl</name>
<base>GuiControl</base>
<field>
<name>borderMargin</name>
<desc>int borderMargin</desc>
</field>
<field>
<name>caption</name>
<desc>Optional text label to display.</desc>
</field>
<field>
<name>invisible</name>
<desc>bool invisible</desc>
</field>
<field>
<name>leftMargin</name>
<desc>Left margin of text label.</desc>
</field>
<field>
<name>type</name>
<desc>Orientation of separator.</desc>
</field>
</class>
<class>
<name>GuiSeparatorCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiShapeEdPreview</name>
<base>EditTSCtrl</base>
<method>
<name>addThread</name>
<args>()</args>
<desc>Add a new thread (initially without any sequence set)</desc>
</method>
<method>
<name>computeShapeBounds</name>
<args>()</args>
<desc>Compute the bounding box of the shape using the current detail and node transforms

@return the bounding box "min.x min.y min.z max.x max.y max.z"</desc>
</method>
<method>
<name>fitToShape</name>
<args>()</args>
<desc>Adjust the camera position and zoom to fit the shape within the view.</desc>
</method>
<method>
<name>getMeshHidden</name>
<args>( string name )</args>
<desc>Return whether the named object is currently hidden</desc>
</method>
<method>
<name>getMountThreadDir</name>
<args>( int slot )</args>
<desc>Get the playback direction of the sequence playing on this mounted shape
@param slot mounted shape slot
@return direction of the sequence (-1=reverse, 0=paused, 1=forward)</desc>
</method>
<method>
<name>getMountThreadPos</name>
<args>( int slot )</args>
<desc>Get the playback position of the sequence playing on this mounted shape
@param slot mounted shape slot
@return playback position of the sequence (0-1)</desc>
</method>
<method>
<name>getMountThreadSequence</name>
<args>( int slot )</args>
<desc>Get the name of the sequence playing on this mounted shape
@param slot mounted shape slot
@return name of the sequence (if any)</desc>
</method>
<method>
<name>getThreadCount</name>
<args>()</args>
<desc>Get the number of threads

@return the number of threads</desc>
</method>
<method>
<name>getThreadSequence</name>
<args>()</args>
<desc>Get the name of the sequence assigned to the active thread</desc>
</method>
<method>
<name>mountShape</name>
<args>( string shapePath, string nodeName, string type, int slot )</args>
<desc>Mount a shape onto the main shape at the specified node

@param shapePath path to the shape to mount
@param nodeName name of the node on the main shape to mount to
@param type type of mounting to use (Object, Image or Wheel)
@param slot mount slot</desc>
</method>
<method>
<name>refreshShape</name>
<args>()</args>
<desc>Refresh the shape (used when the shape meshes or nodes have been added or removed)</desc>
</method>
<method>
<name>refreshThreadSequences</name>
<args>()</args>
<desc>Refreshes thread sequences (in case of removed/renamed sequences</desc>
</method>
<method>
<name>removeThread</name>
<args>( int slot )</args>
<desc>Removes the specifed thread

@param slot index of the thread to remove</desc>
</method>
<method>
<name>setAllMeshesHidden</name>
<args>( bool hidden )</args>
<desc>Show or hide all objects in the shape</desc>
</method>
<method>
<name>setMeshHidden</name>
<args>( string name, bool hidden )</args>
<desc>Show or hide the named object in the shape</desc>
</method>
<method>
<name>setModel</name>
<args>( string shapePath )</args>
<desc>Sets the model to be displayed in this control

@param shapeName Name of the model to display.
@return True if the model was loaded successfully, false otherwise.</desc>
</method>
<method>
<name>setMountNode</name>
<args>( int slot, string nodeName )</args>
<desc>Set the node a shape is mounted to.

@param slot mounted shape slot
@param nodename name of the node to mount to</desc>
</method>
<method>
<name>setMountThreadDir</name>
<args>( int slot, float dir )</args>
<desc>Set the playback direction of the shape mounted in the specified slot
@param slot mounted shape slot
@param dir playback direction (-1=backwards, 0=paused, 1=forwards)</desc>
</method>
<method>
<name>setMountThreadPos</name>
<args>( int slot, float pos )</args>
<desc>Set the sequence position of the shape mounted in the specified slot
@param slot mounted shape slot
@param pos sequence position (0-1)</desc>
</method>
<method>
<name>setMountThreadSequence</name>
<args>( int slot, string name )</args>
<desc>Set the sequence to play for the shape mounted in the specified slot
@param slot mounted shape slot
@param name name of the sequence to play</desc>
</method>
<method>
<name>setOrbitPos</name>
<args>( Point3F pos )</args>
<desc>Set the camera orbit position

@param pos Position in the form "x y z"</desc>
</method>
<method>
<name>setThreadSequence</name>
<args>( string name, float duration=0, float pos=0, bool play=false )</args>
<desc>Sets the sequence to play for the active thread.

@param name name of the sequence to play
@param duration transition duration (0 for no transition)
@param pos position in the new sequence to transition to
@param play if true, the new sequence will play during the transition</desc>
</method>
<method>
<name>setTimeScale</name>
<args>( float scale )</args>
<desc>Set the time scale of all threads

@param scale new time scale value</desc>
</method>
<method>
<name>unmountAll</name>
<args>()</args>
<desc>Unmount all shapes</desc>
</method>
<method>
<name>unmountShape</name>
<args>( int slot )</args>
<desc>Unmount the shape in the specified slot
@param slot mounted shape slot</desc>
</method>
<method>
<name>updateNodeTransforms</name>
<args>()</args>
<desc>Refresh the shape node transforms (used when a node transform has been modified externally)</desc>
</method>
<field>
<name>activeThread</name>
<desc>Index of the active thread, or -1 if none</desc>
</field>
<field>
<name>colMeshes</name>
<desc>The number of collision meshes in the shape</desc>
</field>
<field>
<name>colPolys</name>
<desc>The total number of collision polygons (all meshes) in the shape</desc>
</field>
<field>
<name>currentDL</name>
<desc>The current detail level</desc>
</field>
<field>
<name>detailPolys</name>
<desc>Number of polygons in the current detail</desc>
</field>
<field>
<name>detailSize</name>
<desc>The size of the current detail</desc>
</field>
<field>
<name>editSun</name>
<desc>If true, dragging the gizmo will rotate the sun direction</desc>
</field>
<field>
<name>fixedDetail</name>
<desc>If false, the current detail is selected based on camera distance</desc>
</field>
<field>
<name>gridDimension</name>
<desc>Grid dimensions (number of rows and columns) in the form "rows cols"</desc>
</field>
<field>
<name>numBones</name>
<desc>The number of bones in the current detail level (skins only)</desc>
</field>
<field>
<name>numDrawCalls</name>
<desc>The number of draw calls in the current detail level</desc>
</field>
<field>
<name>numMaterials</name>
<desc>The number of materials in the current detail level</desc>
</field>
<field>
<name>numWeights</name>
<desc>The number of vertex weights in the current detail level (skins only)</desc>
</field>
<field>
<name>onThreadPosChanged( float pos, bool inTransition )</name>
<desc>Called when the position of the active thread has changed, such as during playback.</desc>
</field>
<field>
<name>orbitDist</name>
<desc>The current distance from the camera to the model</desc>
</field>
<field>
<name>pixelSize</name>
<desc>The current pixel size of the model</desc>
</field>
<field>
<name>renderBounds</name>
<desc>Flag indicating whether to render the shape bounding box</desc>
</field>
<field>
<name>renderColMeshes</name>
<desc>Flag indicating whether to render the shape's collision geometry</desc>
</field>
<field>
<name>renderGhost</name>
<desc>Flag indicating whether to render the shape in 'ghost' mode (transparent)</desc>
</field>
<field>
<name>renderGrid</name>
<desc>Flag indicating whether to draw the grid</desc>
</field>
<field>
<name>renderMounts</name>
<desc>Flag indicating whether to render mounted objects</desc>
</field>
<field>
<name>renderNodes</name>
<desc>Flag indicating whether to render the shape nodes</desc>
</field>
<field>
<name>renderObjBox</name>
<desc>Flag indicating whether to render the selected object's bounding box</desc>
</field>
<field>
<name>selectedNode</name>
<desc>Index of the selected node, or -1 if none</desc>
</field>
<field>
<name>selectedObject</name>
<desc>Index of the selected object, or -1 if none</desc>
</field>
<field>
<name>sunAmbient</name>
<desc>Diffuse color for the sun</desc>
</field>
<field>
<name>sunAngleX</name>
<desc>X-axis rotation angle for the sun</desc>
</field>
<field>
<name>sunAngleZ</name>
<desc>Z-axis rotation angle for the sun</desc>
</field>
<field>
<name>sunDiffuse</name>
<desc>Ambient color for the sun</desc>
</field>
<field>
<name>threadDirection</name>
<desc>Playback direction of the active thread</desc>
</field>
<field>
<name>threadPingPong</name>
<desc>'PingPong' mode of the active thread</desc>
</field>
<field>
<name>threadPos</name>
<desc>Current position of the active thread (0-1)</desc>
</field>
</class>
<class>
<name>GuiShapeEdPreviewClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiShapeNameHud</name>
<base>GuiControl</base>
<field>
<name>distanceFade</name>
<desc>Visibility distance (how far the player must be from the ShapeBase object in focus) for this control to render.</desc>
</field>
<field>
<name>fillColor</name>
<desc>Standard color for the background of the control.</desc>
</field>
<field>
<name>frameColor</name>
<desc>Color for the control's frame.</desc>
</field>
<field>
<name>showFill</name>
<desc>If true, we draw the background color of the control.</desc>
</field>
<field>
<name>showFrame</name>
<desc>If true, we draw the frame of the control.</desc>
</field>
<field>
<name>textColor</name>
<desc>Color for the text on this control.</desc>
</field>
<field>
<name>verticalOffset</name>
<desc>Amount to vertically offset the control in relation to the ShapeBase object in focus.</desc>
</field>
</class>
<class>
<name>GuiShapeNameHudClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiSliderCtrl</name>
<base>GuiControl</base>
<method>
<name>addSceneEventSliderMarker</name>
<desc>addSceneEventSliderMarker(F32 time,S32 uf_seqnum,S32 uf_frame,S32 uf_node,S32 uf_type,S32 uf_id)</desc>
</method>
<method>
<name>addSliderMarker</name>
<desc>addSliderMarker(U32 type,F32 time)</desc>
</method>
<method>
<name>addUltraframeSliderMarker</name>
<desc>addUltraframeSliderMarker(F32 time,S32 uf_seqnum,S32 uf_frame,S32 uf_node,S32 uf_type,S32 uf_id)</desc>
</method>
<method>
<name>clearSliderMarkers</name>
<desc>clearSliderMarkers()</desc>
</method>
<method>
<name>getValue</name>
<args>()</args>
<desc>Get the current value of the slider based on the position of the thumb.
@return Slider position (from range.x to range.y).</desc>
</method>
<method>
<name>isThumbBeingDragged</name>
<args>()</args>
<desc>Returns true if the thumb is currently being dragged by the user.  This method is mainly useful for scrubbing type sliders where the slider position is sync'd to a changing value.  When the user is dragging the thumb, however, the sync'ing should pause and not get in the way of the user.</desc>
</method>
<method>
<name>removeSliderMarker</name>
<desc>removeSliderMarker(U32 type,F32 time)</desc>
</method>
<method>
<name>setValue</name>
<args>( float pos, bool doCallback=false )</args>
<desc>Set position of the thumb on the slider.
@param pos New slider position (from range.x to range.y)
@param doCallback If true, the altCommand callback will be invoked</desc>
</method>
<field>
<name>onMouseDragged()</name>
<desc>Called when the left mouse button is dragged across the slider.</desc>
</field>
<field>
<name>range</name>
<desc>Min and max values corresponding to left and right slider position.</desc>
</field>
<field>
<name>snap</name>
<desc>Whether to snap the slider to tick marks.</desc>
</field>
<field>
<name>ticks</name>
<desc>Spacing between tick marks in pixels. 0=off.</desc>
</field>
<field>
<name>value</name>
<desc>The value corresponding to the current slider position.</desc>
</field>
</class>
<class>
<name>GuiSliderCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiSpeedometerHud</name>
<base>GuiBitmapCtrl</base>
<field>
<name>center</name>
<desc>Center of the needle, offset from the GuiSpeedometerHud control top left corner</desc>
</field>
<field>
<name>color</name>
<desc>Color of the needle</desc>
</field>
<field>
<name>length</name>
<desc>Length of the needle from center to end</desc>
</field>
<field>
<name>maxAngle</name>
<desc>Angle (in radians) of the needle when the Vehicle speed is &gt;= maxSpeed. An angle of 0 points right, 90 points up etc).</desc>
</field>
<field>
<name>maxSpeed</name>
<desc>Maximum Vehicle speed (in Torque units per second) to represent on the speedo (Vehicle speeds greater than this are clamped to maxSpeed).</desc>
</field>
<field>
<name>minAngle</name>
<desc>Angle (in radians) of the needle when the Vehicle speed is 0. An angle of 0 points right, 90 points up etc).</desc>
</field>
<field>
<name>tail</name>
<desc>Length of the needle from center to tail</desc>
</field>
<field>
<name>Width</name>
<desc>Width of the needle</desc>
</field>
</class>
<class>
<name>GuiSpeedometerHudClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiSplitContainer</name>
<base>GuiContainer</base>
<field>
<name>fixedPanel</name>
<desc>Which (if any) side of the splitter to keep at a fixed size.</desc>
</field>
<field>
<name>fixedSize</name>
<desc>Width of the fixed panel specified by #fixedPanel (if any).</desc>
</field>
<field>
<name>orientation</name>
<desc>Whether to split between top and bottom (horizontal) or between left and right (vertical).</desc>
</field>
<field>
<name>splitPoint</name>
<desc>Point on control through which the splitter goes.

Changed relatively if size of control changes.</desc>
</field>
<field>
<name>splitterSize</name>
<desc>Width of the splitter bar between the two sides.  Default is 2.</desc>
</field>
</class>
<class>
<name>GuiSplitContainerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiStackControl</name>
<base>GuiControl</base>
<method>
<name>freeze</name>
<args>( bool freeze )</args>
<desc>Prevents control from restacking - useful when adding or removing child controls
@param freeze True to freeze the control, false to unfreeze it

@tsexample
%stackCtrl.freeze(true);
// add controls to stack
%stackCtrl.freeze(false);
@endtsexample</desc>
</method>
<method>
<name>isFrozen</name>
<args>()</args>
<desc>Return whether or not this control is frozen</desc>
</method>
<method>
<name>updateStack</name>
<args>()</args>
<desc>Restack the child controls.</desc>
</method>
<field>
<name>changeChildPosition</name>
<desc>Determines whether to reposition child controls.

If true, horizontally stacked children are aligned along the top edge of the stack control. Vertically stacked children are aligned along the left edge of the stack control. If false, horizontally stacked children retain their Y position, and vertically stacked children retain their X position.</desc>
</field>
<field>
<name>changeChildSizeToFit</name>
<desc>Determines whether to resize child controls.

If true, horizontally stacked children keep their width, but have their height set to the stack control height. Vertically stacked children keep their height, but have their width set to the stack control width. If false, child controls are not resized.</desc>
</field>
<field>
<name>dynamicNonStackExtent</name>
<desc>Determines whether to resize the stack control along the non-stack axis (change height for horizontal stacking, change width for vertical stacking). No effect if dynamicSize is false.

If true, the stack will be resized to the maximum of the child control widths/heights. If false, the stack will not be resized.</desc>
</field>
<field>
<name>dynamicPos</name>
<desc>Determines whether to reposition the stack along the stack axis when it is auto-resized. No effect if dynamicSize is false.

If true, the stack will grow left for horizontal stacking, and grow up for vertical stacking.
If false, the stack will grow right for horizontal stacking, and grow down for vertical stacking.</desc>
</field>
<field>
<name>dynamicSize</name>
<desc>Determines whether to resize the stack control along the stack axis (change width for horizontal stacking, change height for vertical stacking).

If true, the stack width/height will be resized to the sum of the child control widths/heights. If false, the stack will not be resized.</desc>
</field>
<field>
<name>horizStacking</name>
<desc>Controls the type of horizontal stacking to use (&lt;i&gt;Left to Right&lt;/i&gt; or &lt;i&gt;Right to Left&lt;/i&gt;)</desc>
</field>
<field>
<name>padding</name>
<desc>Distance (in pixels) between stacked child controls.</desc>
</field>
<field>
<name>stackingType</name>
<desc>Determines the method used to position the child controls.</desc>
</field>
<field>
<name>vertStacking</name>
<desc>Controls the type of vertical stacking to use (&lt;i&gt;Top to Bottom&lt;/i&gt; or &lt;i&gt;Bottom to Top&lt;/i&gt;)</desc>
</field>
</class>
<class>
<name>GuiStackControlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiSwatchButtonCtrl</name>
<base>GuiButtonBaseCtrl</base>
<method>
<name>setColor</name>
<args>( string newColor )</args>
<desc>Set the color of the swatch control.
@param newColor The new color string given to the swatch control in float format "r g b a".
@note It's also important to note that when setColor is called causes
the control's altCommand field to be executed.</desc>
</method>
<field>
<name>color</name>
<desc>The foreground color of GuiSwatchButtonCtrl</desc>
</field>
</class>
<class>
<name>GuiSwatchButtonCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTabBookCtrl</name>
<base>GuiContainer</base>
<method>
<name>addPage</name>
<args>( string title="" )</args>
<desc>Add a new tab page to the control.

@param title Title text for the tab page header.</desc>
</method>
<method>
<name>getSelectedPage</name>
<args>()</args>
<desc>Get the index of the currently selected tab page.

@return Index of the selected tab page or -1 if no tab page is selected.</desc>
</method>
<method>
<name>selectPage</name>
<args>( int index )</args>
<desc>Set the selected tab page.

@param index Index of the tab page.</desc>
</method>
<field>
<name>allowReorder</name>
<desc>Whether reordering tabs with the mouse is allowed.</desc>
</field>
<field>
<name>defaultPage</name>
<desc>Index of page to select on first onWake() call (-1 to disable).</desc>
</field>
<field>
<name>frontTabPadding</name>
<desc>X offset of first tab page header.</desc>
</field>
<field>
<name>minTabWidth</name>
<desc>Minimum width allocated to a tab page header.</desc>
</field>
<field>
<name>onTabRightClick( String text, int index )</name>
<desc>Called when the user right-clicks on a tab page header.

@param text Text of the page header for the tab that is being selected.
@param index Index of the tab page being selected.</desc>
</field>
<field>
<name>onTabSelected( String text, int index )</name>
<desc>Called when a new tab page is selected.

@param text Text of the page header for the tab that is being selected.
@param index Index of the tab page being selected.</desc>
</field>
<field>
<name>selectedPage</name>
<desc>Index of currently selected page.</desc>
</field>
<field>
<name>tabHeight</name>
<desc>Height of tab page headers.</desc>
</field>
<field>
<name>tabMargin</name>
<desc>Spacing to put between individual tab page headers.</desc>
</field>
<field>
<name>tabPosition</name>
<desc>Where to place the tab page headers.</desc>
</field>
</class>
<class>
<name>GuiTabBookCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTabPageCtrl</name>
<base>GuiTextCtrl</base>
<method>
<name>select</name>
<args>()</args>
<desc>Select this page in its tab book.</desc>
</method>
<field>
<name>fitBook</name>
<desc>Determines whether to resize this page when it is added to the tab book. If true, the page will be resized according to the tab book extents and &lt;i&gt;tabPosition&lt;/i&gt; property.</desc>
</field>
</class>
<class>
<name>GuiTabPageCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTerrPreviewCtrl</name>
<base>GuiControl</base>
<method>
<name>getOrigin</name>
<desc>Return a Point2F containing the position of the origin.</desc>
</method>
<method>
<name>getRoot</name>
<desc>Return a Point2F representing the position of the root.</desc>
</method>
<method>
<name>getValue</name>
<desc>Returns a 4-tuple containing: root_x root_y origin_x origin_y</desc>
</method>
<method>
<name>reset</name>
<desc>Reset the view of the terrain.</desc>
</method>
<method>
<name>setOrigin</name>
<args>(float x, float y)</args>
<desc>Set the origin of the view.</desc>
</method>
<method>
<name>setRoot</name>
<desc>Add the origin to the root and reset the origin.</desc>
</method>
<method>
<name>setValue</name>
<desc>Accepts a 4-tuple in the same form as getValue returns.

@see GuiTerrPreviewCtrl::getValue()</desc>
</method>
</class>
<class>
<name>GuiTerrPreviewCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTextCtrl</name>
<base>GuiContainer</base>
<method>
<name>setText</name>
<args>( string text )</args>
<desc>@brief Sets the text in the control.

@param text Text to display in the control.
@tsexample
// Set the text to show in the control
%text = "Gideon - Destroyer of World";

// Inform the GuiTextCtrl control to change its text to the defined value
%thisGuiTextCtrl.setText(%text);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setTextID</name>
<args>( string textID )</args>
<desc>@brief Maps the text ctrl to a variable used in localization, rather than raw text.

@param textID Name of variable text should be mapped to
@tsexample
// Inform the GuiTextCtrl control of the textID to use
%thisGuiTextCtrl.setTextID("STR_QUIT");
@endtsexample

@see GuiControl@see Localization</desc>
</method>
<field>
<name>maxLength</name>
<desc>Defines the maximum length of the text.  The default is 1024.</desc>
</field>
<field>
<name>text</name>
<desc>The text to show on the control.</desc>
</field>
<field>
<name>textID</name>
<desc>Maps the text of this control to a variable used in localization, rather than raw text.</desc>
</field>
</class>
<class>
<name>GuiTextCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTextEditCtrl</name>
<base>GuiTextCtrl</base>
<method>
<name>clearSelectedText</name>
<args>()</args>
<desc>@brief Unselects all selected text in the control.

@tsexample
// Inform the control to unselect all of its selected text
%thisGuiTextEditCtrl.clearSelectedText();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>forceValidateText</name>
<args>()</args>
<desc>@brief Force a validation to occur.

@tsexample
// Inform the control to force a validation of its text.
%thisGuiTextEditCtrl.forceValidateText();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>getCursorPos</name>
<args>()</args>
<desc>@brief Returns the current position of the text cursor in the control.

@tsexample
// Acquire the cursor position in the control
%position = %thisGuiTextEditCtrl.getCursorPost();
@endtsexample

@return Text cursor position within the control.

@see GuiControl</desc>
</method>
<method>
<name>getText</name>
<args>()</args>
<desc>@brief Acquires the current text displayed in this control.

@tsexample
// Acquire the value of the text control.
%text = %thisGuiTextEditCtrl.getText();
@endtsexample

@return The current text within the control.

@see GuiControl</desc>
</method>
<method>
<name>isAllTextSelected</name>
<args>()</args>
<desc>@brief Checks to see if all text in the control has been selected.

@tsexample
// Check to see if all text has been selected or not.
%allSelected = %thisGuiTextEditCtrl.isAllTextSelected();
@endtsexample

@return True if all text in the control is selected, otherwise false.

@see GuiControl</desc>
</method>
<method>
<name>selectAllText</name>
<args>()</args>
<desc>@brief Selects all text within the control.

@tsexample
// Inform the control to select all of its text.
%thisGuiTextEditCtrl.selectAllText();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setCursorPos</name>
<args>( int position )</args>
<desc>@brief Sets the text cursor at the defined position within the control.

@param position Text position to set the text cursor.
@tsexample
// Define the cursor position
%position = "12";

// Inform the GuiTextEditCtrl control to place the text cursor at the defined position
%thisGuiTextEditCtrl.setCursorPos(%position);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setText</name>
<args>( string text )</args>
<desc>@brief Sets the text in the control.

@param text Text to place in the control.
@tsexample
// Define the text to display
%text = "Text!"

// Inform the GuiTextEditCtrl to display the defined text
%thisGuiTextEditCtrl.setText(%text);
@endtsexample

@see GuiControl</desc>
</method>
<field>
<name>deniedSound</name>
<desc>If the attempted text cannot be entered, this sound effect will be played.</desc>
</field>
<field>
<name>escapeCommand</name>
<desc>Script command to be called when the Escape key is pressed.</desc>
</field>
<field>
<name>historySize</name>
<desc>How large of a history buffer to maintain.</desc>
</field>
<field>
<name>onReturn()</name>
<desc>@brief Called when the 'Return' or 'Enter' key is pressed.

@tsexample
// Return or Enter key was pressed, causing the callback to occur.
GuiTextEditCtrl::onReturn(%this)
^{
^^// Code to run when the onReturn callback occurs
^}
@endtsexample

@see GuiTextCtrl
@see GuiControl</desc>
</field>
<field>
<name>onTabComplete( string val )</name>
<desc>@brief Called if tabComplete is true, and the 'tab' key is pressed.

@param val Input to mimick the '1' sent by the actual tab key button press.
@tsexample
// Tab key has been pressed, causing the callback to occur.
GuiTextEditCtrl::onTabComplete(%this,%val)
^{
^^//Code to run when the onTabComplete callback occurs
^}
@endtsexample

@see GuiTextCtrl
@see GuiControl</desc>
</field>
<field>
<name>onValidate()</name>
<desc>@brief Called whenever the control is validated.

@tsexample
// The control gets validated, causing the callback to occur
GuiTextEditCtrl::onValidated(%this)
^{
^^// Code to run when the control is validated
^}
@endtsexample

@see GuiTextCtrl
@see GuiControl</desc>
</field>
<field>
<name>password</name>
<desc>If true, all characters entered will be stored in the control, however will display as the character stored in passwordMask.</desc>
</field>
<field>
<name>passwordMask</name>
<desc>If 'password' is true, this is the character that will be used to mask the characters in the control.</desc>
</field>
<field>
<name>sinkAllKeyEvents</name>
<desc>If true, every key event will act as if the Enter key was pressed.</desc>
</field>
<field>
<name>tabComplete</name>
<desc>If true, when the 'tab' key is pressed, it will act as if the Enter key was pressed on the control.</desc>
</field>
<field>
<name>validate</name>
<desc>Script command to be called when the first validater is lost.</desc>
</field>
</class>
<class>
<name>GuiTextEditCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTextEditSliderBitmapCtrl</name>
<base>GuiTextEditCtrl</base>
<field>
<name>bitmap</name>
<desc>Unused</desc>
</field>
<field>
<name>focusOnMouseWheel</name>
<desc>If true, the control will accept giving focus to the user when the mouse wheel is used.</desc>
</field>
<field>
<name>format</name>
<desc>Character format type to place in the control.</desc>
</field>
<field>
<name>increment</name>
<desc>How far to increment the slider on each step.</desc>
</field>
<field>
<name>range</name>
<desc>Maximum vertical and horizontal range to allow in the control.</desc>
</field>
</class>
<class>
<name>GuiTextEditSliderBitmapCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTextEditSliderCtrl</name>
<base>GuiTextEditCtrl</base>
<field>
<name>focusOnMouseWheel</name>
<desc>If true, the control will accept giving focus to the user when the mouse wheel is used.</desc>
</field>
<field>
<name>format</name>
<desc>Character format type to place in the control.</desc>
</field>
<field>
<name>increment</name>
<desc>How far to increment the slider on each step.</desc>
</field>
<field>
<name>range</name>
<desc>Maximum vertical and horizontal range to allow in the control.</desc>
</field>
</class>
<class>
<name>GuiTextEditSliderCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTextListCtrl</name>
<base>GuiArrayCtrl</base>
<method>
<name>addRow</name>
<args>( int id=0, string text="", int index=-1 )</args>
<desc>@brief Adds a new row at end of the list with the defined id and text.
If index is used, then the new row is inserted at the row location of 'index'.

@param id Id of the new row.
@param text Text to display at the new row.
@param index Index to insert the new row at. If not used, new row will be placed at the end of the list.
@tsexample
// Define the id
%id = "4";

// Define the text to display
%text = "Display Text"

// Define the index (optional)
%index = "2"

// Inform the GuiTextListCtrl control to add the new row with the defined information.
%rowIndex = %thisGuiTextListCtrl.addRow(%id,%text,%index);
@endtsexample

@return Returns the row index of the new row. If 'index' was defined, then this just returns the number of rows in the list.

@see References</desc>
</method>
<method>
<name>clear</name>
<args>()</args>
<desc>@brief Clear the list.

@tsexample
// Inform the GuiTextListCtrl control to clear its contents
%thisGuiTextListCtrl.clear();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>clearSelection</name>
<args>()</args>
<desc>@brief Set the selection to nothing.

@tsexample
// Deselect anything that is currently selected
%thisGuiTextListCtrl.clearSelection();
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>findTextIndex</name>
<args>( string needle )</args>
<desc>@brief Find needle in the list, and return the row number it was found in.

@param needle Text to find in the list.
@tsexample
// Define the text to find in the list
%needle = "Text To Find";

// Request the row number that contains the defined text to find

%rowNumber = %thisGuiTextListCtrl.findTextIndex(%needle);

@endtsexample

@return Row number that the defined text was found in,

@see GuiControl</desc>
</method>
<method>
<name>getRowId</name>
<args>( int index )</args>
<desc>@brief Get the row ID for an index.

@param index Index to get the RowID at
@tsexample
// Define the index
%index = "3";

// Request the row ID at the defined index
%rowId = %thisGuiTextListCtrl.getRowId(%index);
@endtsexample

@return RowId at the defined index.

@see GuiControl</desc>
</method>
<method>
<name>getRowNumById</name>
<args>( int id )</args>
<desc>@brief Get the row number for a specified id.

@param id Id to get the row number at
@tsexample
// Define the id
%id = "4";

// Request the row number from the GuiTextListCtrl control at the defined id.
%rowNumber = %thisGuiTextListCtrl.getRowNumById(%id);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>getRowText</name>
<args>( int index )</args>
<desc>@brief Get the text of the row with the specified index.

@param index Row index to acquire the text at.
@tsexample
// Define the row index
%index = "5";

// Request the text from the row at the defined index
%rowText = %thisGuiTextListCtrl.getRowText(%index);
@endtsexample

@return Text at the defined row index.

@see GuiControl</desc>
</method>
<method>
<name>getRowTextById</name>
<args>( int id )</args>
<desc>@brief Get the text of a row with the specified id.

@tsexample
// Define the id
%id = "4";

// Inform the GuiTextListCtrl control to return the text at the defined row id
%rowText = %thisGuiTextListCtrl.getRowTextById(%id);
@endtsexample

@return Row text at the requested row id.

@see GuiControl</desc>
</method>
<method>
<name>getSelectedId</name>
<args>()</args>
<desc>@brief Get the ID of the currently selected item.

@tsexample
// Acquire the ID of the selected item in the list.
%id = %thisGuiTextListCtrl.getSelectedId();
@endtsexample

@return The id of the selected item in the list.

@see GuiControl</desc>
</method>
<method>
<name>getSelectedRow</name>
<args>()</args>
<desc>@brief Returns the selected row index (not the row ID).

@tsexample
// Acquire the selected row index
%rowIndex = %thisGuiTextListCtrl.getSelectedRow();
@endtsexample

@return Index of the selected row

@see GuiControl</desc>
</method>
<method>
<name>isRowActive</name>
<args>( int rowNum )</args>
<desc>@brief Check if the specified row is currently active or not.

@param rowNum Row number to check the active state.
@tsexample
// Define the row number
%rowNum = "5";

// Request the active state of the defined row number from the GuiTextListCtrl control.
%rowActiveState = %thisGuiTextListCtrl.isRowActive(%rowNum);
@endtsexample

@return Active state of the defined row number.

@see GuiControl</desc>
</method>
<method>
<name>removeRow</name>
<args>( int index )</args>
<desc>@brief Remove a row from the table, based on its index.

@param index Row index to remove from the list.
@tsexample
// Define the row index
%index = "4";

// Inform the GuiTextListCtrl control to remove the row at the defined row index
%thisGuiTextListCtrl.removeRow(%index);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>removeRowById</name>
<args>( int id )</args>
<desc>@brief Remove row with the specified id.

@param id Id to remove the row entry at
@tsexample
// Define the id
%id = "4";

// Inform the GuiTextListCtrl control to remove the row at the defined id
%thisGuiTextListCtrl.removeRowById(%id);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>rowCount</name>
<args>()</args>
<desc>@brief Get the number of rows.

@tsexample
// Get the number of rows in the list
%rowCount = %thisGuiTextListCtrl.rowCount();
@endtsexample

@return Number of rows in the list.

@see GuiControl</desc>
</method>
<method>
<name>scrollVisible</name>
<args>( int rowNum )</args>
<desc>@brief Scroll so the specified row is visible

@param rowNum Row number to make visible
@tsexample
// Define the row number to make visible
%rowNum = "4";

// Inform the GuiTextListCtrl control to scroll the list so the defined rowNum is visible.
%thisGuiTextListCtrl.scrollVisible(%rowNum);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setRowActive</name>
<args>( int rowNum, bool active )</args>
<desc>@brief Mark a specified row as active/not.

@param rowNum Row number to change the active state.
@param active Boolean active state to set the row number.
@tsexample
// Define the row number
%rowNum = "4";

// Define the boolean active state
%active = "true";

// Informthe GuiTextListCtrl control to set the defined active state at the defined row number.
%thisGuiTextListCtrl.setRowActive(%rowNum,%active);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setRowById</name>
<args>( int id, string text )</args>
<desc>@brief Sets the text at the defined id.

@param id Id to change.
@param text Text to use at the Id.
@tsexample
// Define the id
%id = "4";

// Define the text
%text = "Text To Display";

// Inform the GuiTextListCtrl control to display the defined text at the defined id
%thisGuiTextListCtrl.setRowById(%id,%text);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setSelectedById</name>
<args>( int id )</args>
<desc>@brief Finds the specified entry by id, then marks its row as selected.

@param id Entry within the text list to make selected.
@tsexample
// Define the id
%id = "5";

// Inform the GuiTextListCtrl control to set the defined id entry as selected
%thisGuiTextListCtrl.setSelectedById(%id);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>setSelectedRow</name>
<args>( int rowNum )</args>
<desc>@briefSelects the specified row.

@param rowNum Row number to set selected.
@tsexample
// Define the row number to set selected
%rowNum = "4";

%guiTextListCtrl.setSelectedRow(%rowNum);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>sort</name>
<args>( int columnId, bool increasing=true )</args>
<desc>@brief Performs a standard (alphabetical) sort on the values in the specified column.

@param columnId Column ID to perform the sort on.
@param increasing If false, sort will be performed in reverse.
@tsexample
// Define the columnId
%id = "1";

// Define if we are increasing or not
%increasing = "false";

// Inform the GuiTextListCtrl to perform the sort operation
%thisGuiTextListCtrl.sort(%id,%increasing);
@endtsexample

@see GuiControl</desc>
</method>
<method>
<name>sortNumerical</name>
<args>( int columnID, bool increasing=true )</args>
<desc>@brief Perform a numerical sort on the values in the specified column.

Detailed description

@param columnId Column ID to perform the sort on.
@param increasing If false, sort will be performed in reverse.
@tsexample
// Define the columnId
%id = "1";

// Define if we are increasing or not
%increasing = "false";

// Inform the GuiTextListCtrl to perform the sort operation
%thisGuiTextListCtrl.sortNumerical(%id,%increasing);
@endtsexample

@see GuiControl</desc>
</method>
<field>
<name>clipColumnText</name>
<desc>If true, text exceeding a column's given width will get clipped.</desc>
</field>
<field>
<name>columns</name>
<desc>A vector of column offsets.  The number of values determines the number of columns in the table.</desc>
</field>
<field>
<name>fitParentWidth</name>
<desc>If true, the width of this control will match the width of its parent.</desc>
</field>
<field>
<name>onDeleteKey( string id )</name>
<desc>@brief Called when the delete key has been pressed.

@param id Id of the selected item in the list
@tsexample
// The delete key was pressed while the GuiTextListCtrl was in focus, causing the callback to occur.
GuiTextListCtrl::onDeleteKey(%this,%id)
^{
^^// Code to run when the delete key is pressed
^}
@endtsexample

@see GuiControl</desc>
</field>
<field>
<name>onSelect( string cellid, string text )</name>
<desc>@brief Called whenever an item in the list is selected.

@param cellid The ID of the cell that was selected
@param text The text in the selected cel

@tsexample
// A cel in the control was selected, causing the callback to occur
GuiTextListCtrl::onSelect(%this,%callid,%text)
^{
^^// Code to run when a cel item is selected
^}
@endtsexample

@see GuiControl</desc>
</field>
</class>
<class>
<name>GuiTextListCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTheoraCtrl</name>
<base>GuiControl</base>
<method>
<name>getCurrentTime</name>
<args>()</args>
<desc>Get the current playback time.

@return The elapsed playback time in seconds.</desc>
</method>
<method>
<name>isPlaybackDone</name>
<args>()</args>
<desc>Test whether the video has finished playing.

@return True if the video has finished playing, false otherwise.</desc>
</method>
<method>
<name>pause</name>
<args>()</args>
<desc>Pause playback of the video.  If the video is not currently playing, the call is ignored.

While stopped, the control displays the last frame.</desc>
</method>
<method>
<name>play</name>
<args>()</args>
<desc>Start playing the video.  If the video is already playing, the call is ignored.</desc>
</method>
<method>
<name>setFile</name>
<args>( string filename )</args>
<desc>Set the video file to play.  If a video is already playing, playback is stopped and the new video file is loaded.

@param filename The video file to load.</desc>
</method>
<method>
<name>stop</name>
<args>()</args>
<desc>Stop playback of the video.  The next call to play() will then start playback from the beginning of the video.

While stopped, the control renders empty with just the background color.</desc>
</method>
<field>
<name>backgroundColor</name>
<desc>Fill color when video is not playing.</desc>
</field>
<field>
<name>matchVideoSize</name>
<desc>Whether to automatically match control extents to the video size.</desc>
</field>
<field>
<name>playOnWake</name>
<desc>Whether to start playing video when control is woken up.</desc>
</field>
<field>
<name>renderDebugInfo</name>
<desc>If true, displays an overlay on top of the video with useful debugging information.</desc>
</field>
<field>
<name>stopOnSleep</name>
<desc>Whether to stop video when control is set to sleep.

If this is not set to true, the video will be paused when the control is put to sleep.  This is because there is no support for seeking in the video stream in the player backend and letting the time source used to synchronize video (either audio or a raw timer) get far ahead of frame decoding will cause possibly very long delays when the control is woken up again.</desc>
</field>
<field>
<name>theoraFile</name>
<desc>Theora video file to play.</desc>
</field>
<field>
<name>transcoder</name>
<desc>The routine to use for Y'CbCr to RGB conversion.</desc>
</field>
</class>
<class>
<name>GuiTheoraCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTickCtrl</name>
<base>GuiControl</base>
<method>
<name>setProcessTicks</name>
<args>( [tick = true] )</args>
<desc>This will set this object to either be processing ticks or not</desc>
</method>
</class>
<class>
<name>GuiTickCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiToggleButtonCtrl</name>
<base>GuiButtonCtrl</base>
</class>
<class>
<name>GuiToggleButtonCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiToolboxButtonCtrl</name>
<base>GuiButtonCtrl</base>
<method>
<name>setHoverBitmap</name>
<args>( filepath name )</args>
<desc>sets the bitmap that shows when the button is disabled</desc>
</method>
<method>
<name>setLoweredBitmap</name>
<args>( filepath name )</args>
<desc>sets the bitmap that shows when the button is disabled</desc>
</method>
<method>
<name>setNormalBitmap</name>
<args>( filepath name )</args>
<desc>sets the bitmap that shows when the button is active</desc>
</method>
<field>
<name>hoverBitmap</name>
<desc>filename hoverBitmap</desc>
</field>
<field>
<name>loweredBitmap</name>
<desc>filename loweredBitmap</desc>
</field>
<field>
<name>normalBitmap</name>
<desc>filename normalBitmap</desc>
</field>
</class>
<class>
<name>GuiToolboxButtonCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTreeViewCtrl</name>
<base>GuiArrayCtrl</base>
<method>
<name>addChildSelectionByValue</name>
<desc>addChildSelectionByValue(TreeItemId parent, value)</desc>
</method>
<method>
<name>addSelection</name>
<args>( id object, (bool isLastSelection = true) )</args>
<desc>selects an item</desc>
</method>
<method>
<name>buildIconTable</name>
<args>(builds an icon table)</args>
</method>
<method>
<name>buildVisibleTree</name>
<desc>Build the visible tree</desc>
</method>
<method>
<name>clear</name>
<args>()</args>
<desc>empty tree</desc>
</method>
<method>
<name>clearSelection</name>
<args>(clears selection)</args>
</method>
<method>
<name>deleteSelection</name>
<args>(deletes the selected items)</args>
</method>
<method>
<name>editItem</name>
<args>(TreeItemId item, string newText, string newValue)</args>
</method>
<method>
<name>expandItem</name>
<args>(TreeItemId item, bool expand=true)</args>
</method>
<method>
<name>findChildItemByName</name>
<args>( int parent, string name )</args>
<desc>Return the ID of the child that matches the given name or 0.</desc>
</method>
<method>
<name>findItemByName</name>
<args>(find item by name and returns the mId)</args>
</method>
<method>
<name>findItemByObjectId</name>
<args>(find item by object id and returns the mId)</args>
</method>
<method>
<name>findItemByValue</name>
<args>(find item by value and returns the mId)</args>
</method>
<method>
<name>getChild</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>getFirstRootItem</name>
<desc>Get id for root item.</desc>
</method>
<method>
<name>getItemCount</name>
</method>
<method>
<name>getItemText</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>getItemValue</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>getNextSibling</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>getParent</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>getPrevSibling</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>getSelectedItem</name>
<args>( int index=0 )</args>
<desc>Return the selected item at the given index.</desc>
</method>
<method>
<name>getSelectedItemList</name>
<desc>returns a space seperated list of mulitple item ids</desc>
</method>
<method>
<name>getSelectedItemsCount</name>
</method>
<method>
<name>getSelectedObject</name>
<args>( int index=0 )</args>
<desc>Return the currently selected SimObject at the given index in inspector mode or -1</desc>
</method>
<method>
<name>getSelectedObjectList</name>
<desc>Returns a space sperated list of all selected object ids.</desc>
</method>
<method>
<name>getTextToRoot</name>
<args>(TreeItemId item,Delimiter=none)</args>
<desc>gets the text from the current node to the root, concatenating at each branch upward, with a specified delimiter optionally</desc>
</method>
<method>
<name>hideSelection</name>
<args>( [bool state] )</args>
<desc>set hidden state of objects in selection</desc>
</method>
<method>
<name>insertItem</name>
<args>(TreeItemId parent, name, value, icon, normalImage=0, expandedImage=0)</args>
</method>
<method>
<name>isItemSelected</name>
<args>( TreeItemId id )</args>
<desc>Check if the given item is selected within the tree.</desc>
</method>
<method>
<name>isParentItem</name>
<args>( int id )</args>
<desc>Returns true if the given item contains child items.</desc>
</method>
<method>
<name>lockSelection</name>
<args>(locks selections)</args>
</method>
<method>
<name>markItem</name>
<args>(TreeItemId item, bool mark=true)</args>
</method>
<method>
<name>moveItemDown</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>moveItemUp</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>onRenameValidate</name>
<desc>For internal use.</desc>
</method>
<method>
<name>open</name>
<args>(SimSet obj, bool okToEdit=true)</args>
<desc>Set the root of the tree view to the specified object, or to the root set.</desc>
</method>
<method>
<name>removeAllChildren</name>
<desc>removeAllChildren(TreeItemId parent)</desc>
</method>
<method>
<name>removeChildSelectionByValue</name>
<desc>removeChildSelectionByValue(TreeItemId parent, value)</desc>
</method>
<method>
<name>removeItem</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>removeSelection</name>
<args>(deselects an item)</args>
</method>
<method>
<name>scrollVisible</name>
<args>(TreeItemId item)</args>
</method>
<method>
<name>scrollVisibleByObjectId</name>
<args>(show item by object id. returns true if sucessful.)</args>
</method>
<method>
<name>selectItem</name>
<args>(TreeItemId item, bool select=true)</args>
</method>
<method>
<name>setDebug</name>
<args>( bool value=true )</args>
<desc>Enable/disable debug output.</desc>
</method>
<method>
<name>setItemImages</name>
<args>( int id, int normalImage, int expandedImage )</args>
<desc>Sets the normal and expanded images to show for the given item.</desc>
</method>
<method>
<name>setItemTooltip</name>
<args>( int id, string text )</args>
<desc>Set the tooltip to show for the given item.</desc>
</method>
<method>
<name>showItemRenameCtrl</name>
<args>( TreeItemId id )</args>
<desc>Show the rename text field for the given item (only one at a time).</desc>
</method>
<method>
<name>sort</name>
<args>( int parent, bool traverseHierarchy=false, bool parentsFirst=false, bool caseSensitive=true )</args>
<desc>Sorts all items of the given parent (or root).  With 'hierarchy', traverses hierarchy.</desc>
</method>
<method>
<name>toggleHideSelection</name>
<args>()</args>
<desc>Toggle hidden state of objects in selection.</desc>
</method>
<method>
<name>toggleLockSelection</name>
<args>()</args>
<desc>Toggle locked state of objects in selection.</desc>
</method>
<field>
<name>canRenameObjects</name>
<desc>If true clicking on a selected item ( that is an object and not the root ) will allow you to rename it.</desc>
</field>
<field>
<name>clearAllOnSingleSelection</name>
<desc>bool clearAllOnSingleSelection</desc>
</field>
<field>
<name>compareToObjectID</name>
<desc>bool compareToObjectID</desc>
</field>
<field>
<name>deleteObjectAllowed</name>
<desc>bool deleteObjectAllowed</desc>
</field>
<field>
<name>destroyTreeOnSleep</name>
<desc>If true, the entire tree item hierarchy is deleted when the control goes to sleep.</desc>
</field>
<field>
<name>dragToItemAllowed</name>
<desc>bool dragToItemAllowed</desc>
</field>
<field>
<name>fullRowSelect</name>
<desc>bool fullRowSelect</desc>
</field>
<field>
<name>itemHeight</name>
<desc>int itemHeight</desc>
</field>
<field>
<name>mouseDragging</name>
<desc>bool mouseDragging</desc>
</field>
<field>
<name>multipleSelections</name>
<desc>If true, multiple items can be selected concurrently.</desc>
</field>
<field>
<name>renameInternal</name>
<desc>If true then object renaming operates on the internalName rather than the object name.</desc>
</field>
<field>
<name>showClassNameForUnnamedObjects</name>
<desc>If true, class names will be used as object names for unnamed objects.</desc>
</field>
<field>
<name>showClassNames</name>
<desc>If true, item text labels for objects will include class names.</desc>
</field>
<field>
<name>showInternalNames</name>
<desc>If true, item text labels for obje ts will include internal names.</desc>
</field>
<field>
<name>showObjectIds</name>
<desc>If true, item text labels for objects will include object IDs.</desc>
</field>
<field>
<name>showObjectNames</name>
<desc>If true, item text labels for objects will include object names.</desc>
</field>
<field>
<name>showRoot</name>
<desc>If true, the root item is shown in the tree.</desc>
</field>
<field>
<name>tabSize</name>
<desc>int tabSize</desc>
</field>
<field>
<name>textOffset</name>
<desc>int textOffset</desc>
</field>
<field>
<name>tooltipOnWidthOnly</name>
<desc>bool tooltipOnWidthOnly</desc>
</field>
<field>
<name>useInspectorTooltips</name>
<desc>bool useInspectorTooltips</desc>
</field>
</class>
<class>
<name>GuiTreeViewCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiTSCtrl</name>
<base>GuiContainer</base>
<method>
<name>calculateViewDistance</name>
<args>( float radius )</args>
<desc>Given the camera's current FOV, get the distance from the camera's viewpoint at which the given radius will fit in the render area.
@param radius Radius in world-space units which should fit in the view.
@return The distance from the viewpoint at which the given radius would be fully visible.</desc>
</method>
<method>
<name>getWorldToScreenScale</name>
<args>()</args>
<desc>Get the ratio between world-space units and pixels.
@return The amount of world-space units covered by the extent of a single pixel.</desc>
</method>
<method>
<name>project</name>
<args>( Point3F worldPosition )</args>
<desc>Transform world-space coordinates to screen-space (x, y, depth) coordinates.
@param worldPosition The world-space position to transform to screen-space.
@return The</desc>
</method>
<method>
<name>unproject</name>
<args>( Point3F screenPosition )</args>
<desc>Transform 3D screen-space coordinates (x, y, depth) to world space.
This method can be, for example, used to find the world-space position relating to the current mouse cursor position.
@param screenPosition The x/y position on the screen plus the depth from the screen-plane outwards.
@return The world-space position corresponding to the given screen-space coordinates.</desc>
</method>
<field>
<name>cameraZRot</name>
<desc>Z rotation angle of camera.</desc>
</field>
<field>
<name>forceFOV</name>
<desc>The vertical field of view in degrees or zero to use the normal camera FOV.</desc>
</field>
<field>
<name>reflectPriority</name>
<desc>The share of the per-frame reflection update work this control's rendering should run.
The reflect update priorities of all visible GuiTSCtrls are added together and each control is assigned a share of the per-frame reflection update time according to its percentage of the total priority value.</desc>
</field>
</class>
<class>
<name>GuiTSCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiVariableInspector</name>
<base>GuiInspector</base>
<method>
<name>loadVars</name>
<desc>loadVars( searchString )</desc>
</method>
</class>
<class>
<name>GuiVariableInspectorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiWindowCollapseCtrl</name>
<base>GuiWindowCtrl</base>
</class>
<class>
<name>GuiWindowCollapseCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>GuiWindowCtrl</name>
<base>GuiContainer</base>
<method>
<name>attach</name>
<args>( GuiWindowCtrl bottomWindow, GuiWindowCtrl topWindow )</args>
<desc>Attach @a bottomWindow to @topWindow so that @a bottomWindow moves along with @a topWindow when it is dragged.

@param bottomWindow
@param topWindow</desc>
</method>
<method>
<name>attachTo</name>
<args>( GuiWindowCtrl window )</args>
</method>
<method>
<name>selectWindow</name>
<args>()</args>
<desc>Bring the window to the front.</desc>
</method>
<method>
<name>setCollapseGroup</name>
<args>( bool state )</args>
<desc>Set the window's collapsing state.</desc>
</method>
<method>
<name>toggleCollapseGroup</name>
<args>()</args>
<desc>Toggle the window collapsing.</desc>
</method>
<field>
<name>canClose</name>
<desc>Whether the window has a close button.</desc>
</field>
<field>
<name>canCollapse</name>
<desc>Whether the window can be collapsed by clicking its title bar.</desc>
</field>
<field>
<name>canMaximize</name>
<desc>Whether the window has a maximize button.</desc>
</field>
<field>
<name>canMinimize</name>
<desc>Whether the window has a minimize button.</desc>
</field>
<field>
<name>canMove</name>
<desc>Whether the window can be moved by dragging its titlebar.</desc>
</field>
<field>
<name>closeCommand</name>
<desc>Script code to execute when the window is closed.</desc>
</field>
<field>
<name>edgeSnap</name>
<desc>If true, the window will snap to the edges of other windows when moved close to them.</desc>
</field>
<field>
<name>onClose()</name>
<desc>Called when the close button has been pressed.</desc>
</field>
<field>
<name>onCollapse()</name>
<desc>Called when the window is collapsed by clicking its title bar.</desc>
</field>
<field>
<name>onMaximize()</name>
<desc>Called when the window has been maximized.</desc>
</field>
<field>
<name>onMinimize()</name>
<desc>Called when the window has been minimized.</desc>
</field>
<field>
<name>onRestore()</name>
<desc>Called when the window is restored from minimized, maximized, or collapsed state.</desc>
</field>
<field>
<name>resizeHeight</name>
<desc>Whether the window can be resized vertically.</desc>
</field>
<field>
<name>resizeWidth</name>
<desc>Whether the window can be resized horizontally.</desc>
</field>
<field>
<name>text</name>
<desc>Text label to display in titlebar.</desc>
</field>
</class>
<class>
<name>GuiWindowCtrlClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>HoverVehicle</name>
<base>Vehicle</base>
</class>
<class>
<name>HoverVehicleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>HoverVehicleData</name>
<base>VehicleData</base>
<field>
<name>brakingActivationSpeed</name>
<desc>Maximum speed below which a braking force is applied.

@see brakingForce</desc>
</field>
<field>
<name>brakingForce</name>
<desc>Force generated by braking.
The vehicle is considered to be braking if it is moving, but the throttle is off, and no left or right thrust is being applied. This force is only applied when the vehicle's velocity is less than brakingActivationSpeed.</desc>
</field>
<field>
<name>dragForce</name>
<desc>Drag force factor that acts opposite to the vehicle velocity.
Also used to determnine the vehicle's maxThrustSpeed.
@see mainThrustForce</desc>
</field>
<field>
<name>dustTrailEmitter</name>
<desc>Emitter to generate particles for the vehicle's dust trail.
The trail of dust particles is generated only while the vehicle is moving.</desc>
</field>
<field>
<name>dustTrailFreqMod</name>
<desc>Number of dust trail particles to generate based on vehicle speed.
The vehicle's speed is divided by this value to determine how many particles to generate each frame. Lower values give a more dense trail, higher values a more sparse trail.</desc>
</field>
<field>
<name>dustTrailOffset</name>
<desc>"X Y Z" offset from the vehicle's origin from which to generate dust trail particles.
By default particles are emitted directly beneath the origin of the vehicle model.</desc>
</field>
<field>
<name>engineSound</name>
<desc>Looping engine sound.
The volume is dynamically adjusted based on the current thrust level.</desc>
</field>
<field>
<name>floatingGravMag</name>
<desc>Scale factor applied to the vehicle gravitational force when the vehicle is floating.

@see stabLenMin</desc>
</field>
<field>
<name>floatingThrustFactor</name>
<desc>Scalar applied to the vehicle's thrust force when the vehicle is floating.
@note The floatingThrustFactor must be between 0.0 and 1.0 (inclusive).</desc>
</field>
<field>
<name>floatSound</name>
<desc>Looping sound played while the vehicle is floating.

@see stabMinLen</desc>
</field>
<field>
<name>forwardJetEmitter</name>
<desc>Emitter to generate particles for forward jet thrust.
Forward jet thrust particles are emitted from model nodes JetNozzle0 and JetNozzle1.</desc>
</field>
<field>
<name>gyroDrag</name>
<desc>Damping torque that acts against the vehicle's current angular momentum.</desc>
</field>
<field>
<name>jetSound</name>
<desc>Looping sound played when the vehicle is jetting.</desc>
</field>
<field>
<name>mainThrustForce</name>
<desc>Force generated by thrusting the vehicle forward.
Also used to determine the maxThrustSpeed:

@tsexample
maxThrustSpeed = (mainThrustForce + strafeThrustForce) / dragForce;
@endtsexample</desc>
</field>
<field>
<name>normalForce</name>
<desc>Force generated in the ground normal direction when the vehicle is not floating (within stabalizer length from the ground).

@see stabLenMin</desc>
</field>
<field>
<name>pitchForce</name>
<desc>Pitch (rotation about the X-axis) force applied when steering in the y-axis direction.</desc>
</field>
<field>
<name>restorativeForce</name>
<desc>Force generated to stabalize the vehicle (return it to neutral pitch/roll) when the vehicle is floating (more than stabalizer length from the ground.

@see stabLenMin</desc>
</field>
<field>
<name>reverseThrustForce</name>
<desc>Force generated by thrusting the vehicle backward.</desc>
</field>
<field>
<name>rollForce</name>
<desc>Roll (rotation about the Y-axis) force applied when steering in the x-axis direction.</desc>
</field>
<field>
<name>stabDampingConstant</name>
<desc>Damping spring force acting against changes in the stabalizer length.

@see stabLenMin</desc>
</field>
<field>
<name>stabLenMax</name>
<desc>Length of the base stabalizer when travelling at maximum speed (maxThrustSpeed).

@see stabLenMin

@see mainThrustForce</desc>
</field>
<field>
<name>stabLenMin</name>
<desc>Length of the base stabalizer when travelling at minimum speed (0).
Each tick, the vehicle performs 2 raycasts (from the center back and center front of the vehicle) to check for contact with the ground. The base stabalizer length determines the length of that raycast; if neither raycast hit the ground, the vehicle is floating, stabalizer spring and ground normal forces are not applied.

&lt;img src="images/hoverVehicle_forces.png"&gt;
@see stabSpringConstant</desc>
</field>
<field>
<name>stabSpringConstant</name>
<desc>Value used to generate stabalizer spring force. The force generated depends on stabilizer compression, that is how close the vehicle is to the ground proportional to current stabalizer length.

@see stabLenMin</desc>
</field>
<field>
<name>steeringForce</name>
<desc>Yaw (rotation about the Z-axis) force applied when steering in the x-axis direction.about the vehicle's Z-axis)</desc>
</field>
<field>
<name>strafeThrustForce</name>
<desc>Force generated by thrusting the vehicle to one side.
Also used to determine the vehicle's maxThrustSpeed.
@see mainThrustForce</desc>
</field>
<field>
<name>triggerTrailHeight</name>
<desc>Maximum height above surface to emit dust trail particles.
If the vehicle is less than triggerTrailHeight above a static surface with a material that has 'showDust' set to true, the vehicle will emit particles from the dustTrailEmitter.</desc>
</field>
<field>
<name>turboFactor</name>
<desc>Scale factor applied to the vehicle's thrust force when jetting.</desc>
</field>
<field>
<name>vertFactor</name>
<desc>Scalar applied to the vertical portion of the velocity drag acting on the vehicle.
For the horizontal (X and Y) components of velocity drag, a factor of 0.25 is applied when the vehicle is floating, and a factor of 1.0 is applied when the vehicle is not floating. This velocity drag is multiplied by the vehicle's dragForce, as defined above, and the result is subtracted from it's movement force.
@note The vertFactor must be between 0.0 and 1.0 (inclusive).</desc>
</field>
</class>
<class>
<name>HoverVehicleDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>HTTPObject</name>
<base>TCPObject</base>
<method>
<name>get</name>
<args>( string Address, string requirstURI, string query )</args>
<desc>@brief Send a GET command to a server to send or retrieve data.

@param Address HTTP web address to send this get call to. Be sure to include the port at the end (IE: "www.torquepowered.com:80").
@param requirstURI Specific location on the server to access (IE: "index.php".)
@param query Optional. Actual data to transmit to the server. Can be anything required providing it sticks with limitations of the HTTP protocol.
@tsexample
// Create an HTTP object for communications
%httpObj = new HTTPObject();

// Specify a URL to transmit to
%url = "www.TorquePowered.com";

// Specify a URI to communicate with
%URI = "/index.php";

// Specify a query to send.
%query = "";

// Send the GET command to the server
%httpObj.get(%url,%URI,%query);
@endtsexample</desc>
</method>
<method>
<name>post</name>
<args>( string Address, string requirstURI, string query, string post )</args>
<desc>@brief Send POST command to a server to send or retrieve data.

@param Address HTTP web address to send this get call to. Be sure to include the port at the end (IE: "www.torquepowered.com:80").
@param requirstURI Specific location on the server to access (IE: "index.php".)
@param query Actual data to transmit to the server. Can be anything required providing it sticks with limitations of the HTTP protocol.
@param post Submission data to be processed.
@tsexample
// Create an HTTP object for communications
%httpObj = new HTTPObject();

// Specify a URL to transmit to
%url = "www.TorquePowered.com";

// Specify a URI to communicate with
%URI = "/index.php";

// Specify a query to send.
%query = "";

// Specify the submission data.
%post = "";

// Send the POST command to the server
%httpObj.POST(%url,%URI,%query,%post);
@endtsexample</desc>
</method>
</class>
<class>
<name>HTTPObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>InspectorFieldUndoAction</name>
<base>UndoAction</base>
<field>
<name>arrayIndex</name>
<desc>string arrayIndex</desc>
</field>
<field>
<name>fieldName</name>
<desc>string fieldName</desc>
</field>
<field>
<name>fieldValue</name>
<desc>string fieldValue</desc>
</field>
<field>
<name>inspectorGui</name>
<desc>GuiInspector inspectorGui</desc>
</field>
<field>
<name>objectId</name>
<desc>int objectId</desc>
</field>
</class>
<class>
<name>InspectorFieldUndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>InteriorInstance</name>
<base>SceneObject</base>
<method>
<name>changeMaterial</name>
<args>( string mapTo, Material oldMat, Material newMat )</args>
<desc>@brief Change one of the materials on the shape.

This method changes materials per mapTo with others. The material that is being replaced is mapped to unmapped_mat as a part of this transition.

@note Warning, right now this only sort of works. It doesn't do a live update like it should.
@param mapTo The name of the material target to remap (from getTargetName)
@param oldMat The old Material that was mapped
@param newMat The new Material to map

@tsexample
// remap the first material in the shape
%mapTo = %interiorObject.getTargetName( 0 );
%interiorObject.changeMaterial( %mapTo, 0, MyMaterial );
@endtsexample</desc>
</method>
<method>
<name>exportToCollada</name>
<args>( bool bakeTransform )</args>
<desc>@brief Exports the Interior to a Collada file

@param bakeTransform Bakes the InteriorInstance's transform into the vertex positions

@tsexample
// Export to COLLADA, do not bakeTransform
%interiorObject.exportToCollada(0);
@endtsexample</desc>
</method>
<method>
<name>getModelFile</name>
<args>()</args>
<desc>@brief Get the interior file name

@return The name of the interior's model file in .DIF.

@tsexample
%interiorObject.getModelFile();
@endtsexample</desc>
</method>
<method>
<name>getNumDetailLevels</name>
<args>()</args>
<desc>@brief Get the number of detail levels interior was created with

@tsexample
%numLODs = %interiorObject.getNumDetailLevels();
echo(%numLODs);
@endtsexample</desc>
</method>
<method>
<name>getTargetCount</name>
<args>( int detailLevel )</args>
<desc>@brief Get the number of materials used by interior

@param^detailLevel Interior level of detail to scan
@return The number of materials used by the interior at a specified detail level

@tsexample
// Find materials used at first level of detail
%targetCount = %interiorObject.getTargetCount(1);
echo(%targetCount);
@endtsexample</desc>
</method>
<method>
<name>getTargetName</name>
<args>( int detailLevel, int targetNum )</args>
<desc>@brief Get the name of the indexed shape material

@param^detailLevel Target LOD
@param^targetNum Index mapped to the target

@return The name of the target (material) at the specified detail level and index

@tsexample
// First level of detail, top of the index map
%targetName = %interiorObject.getTargetName(1, 0);
echo(%targetName);
@endtsexample</desc>
</method>
<method>
<name>setAlarmMode</name>
<args>( string alarmMode )</args>
<desc>@brief This sets the alarm mode of the interior

The alarm mode is used when debugging bad geometry for an interior. When on, the the bad verties will be rendered a different color.

@param alarmMode If true the interior will be in an alarm state next frame. Options are 'On' or 'Off'.

@tsexample
// Turn on alarm mode debugging for interior
%interiorObject.setAlarmMode("On");
@endtsexample</desc>
</method>
<method>
<name>setDetailLevel</name>
<args>( int level )</args>
<desc>@brief Manually changes the current detail level, rather than automatically via view distance

@param level Detail level to force.

@tsexample
%interiorObject.setDetailLevel(2);
@endtsexample</desc>
</method>
<method>
<name>setSkinBase</name>
<args>( string basename )</args>
<desc>@brief Changes the skin (material) of the interior

This is a legacy function and should be deprecated. Use InteriorInstace::changeMaterial instead

@param basename Name of the new skin or material

@tsexample
// Switch skin to another material
%interiorObject.setSkinBase("wall.stucco");
@endtsexample</desc>
</method>
<field>
<name>interiorFile</name>
<desc>Path and filename of the Interior file (.DIF) to load for this InteriorInstance.</desc>
</field>
<field>
<name>showTerrainInside</name>
<desc>Enables rendering a TerrainBlock when inside an interior zone.</desc>
</field>
</class>
<class>
<name>InteriorInstanceClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Item</name>
<base>ShapeBase</base>
<method>
<name>getLastStickyNormal</name>
<args>()</args>
<desc>@brief Get the normal of the surface on which the object is stuck.

@return Returns The XYZ position of where this Item is stuck.
@tsexample
// Acquire the position where this Item is currently stuck
%stuckPosition = %item.getLastStickPos();

@endtsexample</desc>
</method>
<method>
<name>getLastStickyPos</name>
<args>()</args>
<desc>@brief Get the position on the surface on which this Item is stuck.

@return Returns The XYZ position of where this Item is stuck.
@tsexample
// Acquire the position where this Item is currently stuck
%stuckPosition = %item.getLastStickPos();

@endtsexample</desc>
</method>
<method>
<name>isRotating</name>
<args>()</args>
<desc>@brief Is the object still rotating?

@return True if the object is still rotating, false if it is not.
@tsexample
// Query the item on if it is or is not rotating.
%isRotating = %itemData.isRotating();

@endtsexample</desc>
</method>
<method>
<name>isStatic</name>
<args>()</args>
<desc>@brief Is the object static (ie, non-movable)?

@return True if the object is static, false if it is not.
@tsexample
// Query the item on if it is or is not static.
%isStatic = %itemData.isStatic();

@endtsexample</desc>
</method>
<method>
<name>setCollisionTimeout</name>
<args>( int ignoreColObj=NULL )</args>
<desc>@brief Temporarily disable collisions against a specific ShapeBase object.

@param objectID ShapeBase object ID to disable collisions against.
@return Returns true if the ShapeBase object requested could be found, false if it could not.
@tsexample
// Set the ShapeBase Object ID to disable collisions against
%ignoreColObj = %player.getID();

// Inform this Item object to ignore collisions temproarily against the %ignoreColObj.
%item.setCollisionTimeout(%ignoreColObj);

@endtsexample</desc>
</method>
<field>
<name>onEnterLiquid( string objID, string waterCoverage, string liquidType )</name>
<desc>Informs an Item object that it has entered liquid, along with information about the liquid type.
@param objID Object ID for this Item object.
@param waterCoverage How much coverage of water this Item object has.
@param liquidType The type of liquid that this Item object has entered.
@see Item, ItemData, waterObject</desc>
</field>
<field>
<name>onLeaveLiquid( string objID, string liquidType )</name>
<desc>Informs an Item object that it has left a liquid, along with information about the liquid type.
@param objID Object ID for this Item object.
@param liquidType The type of liquid that this Item object has left.
@see Item, ItemData, waterObject</desc>
</field>
<field>
<name>onStickyCollision( string objID )</name>
<desc>Informs the Item object that it is now sticking to another object.
@param objID Object ID this Item object.
@see Item, ItemData</desc>
</field>
<field>
<name>rotate</name>
<desc>If true, the object will automatically rotate around its Z axis.</desc>
</field>
<field>
<name>static</name>
<desc>If true, the object is not moving in the world (and will not be updated through the network).</desc>
</field>
</class>
<class>
<name>ItemClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ItemData</name>
<base>ShapeBaseData</base>
<field>
<name>dynamicType</name>
<desc>An integer value which, if speficied, is added to the value retured by getType().</desc>
</field>
<field>
<name>elasticity</name>
<desc>A floating-point value specifying how 'bouncy' this ItemData is.</desc>
</field>
<field>
<name>friction</name>
<desc>A floating-point value specifying how much velocity is lost to impact and sliding friction.</desc>
</field>
<field>
<name>gravityMod</name>
<desc>Floating point value to multiply the existing gravity with for just this ItemData.</desc>
</field>
<field>
<name>lightColor</name>
<desc>Color value to make this light. Example: "1.0,1.0,1.0"</desc>
</field>
<field>
<name>lightOnlyStatic</name>
<desc>If true, this ItemData will only cast a light if the Item for this ItemData has a Static value of true.</desc>
</field>
<field>
<name>lightRadius</name>
<desc>Distance from the center point of this ItemData for the light to affect</desc>
</field>
<field>
<name>LightTime</name>
<desc>Time value for the light of this ItemData, used to control the pulse speed of the PulsingLight LightType.</desc>
</field>
<field>
<name>lightType</name>
<desc>Type of light to apply to this ItemData. Options are NoLight, ConstantLight, PulsingLight. Default is NoLight.</desc>
</field>
<field>
<name>maxVelocity</name>
<desc>Maximum velocity that this ItemData is able to move.</desc>
</field>
<field>
<name>sticky</name>
<desc>If true, ItemData will 'stick' to any surface it collides with.</desc>
</field>
</class>
<class>
<name>ItemDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>LangTable</name>
<base>SimObject</base>
<method>
<name>addLanguage</name>
<args>(string filename, [string languageName])</args>
<desc>@brief Adds a language to the table

@param filename Name and path to the language file
@param languageName Optional name to assign to the new language entry

@return True If file was successfully found and language created</desc>
</method>
<method>
<name>getCurrentLanguage</name>
<args>()</args>
<desc>@brief Get the ID of the current language table

@return Numerical ID of the current language table</desc>
</method>
<method>
<name>getLangName</name>
<args>(int language)</args>
<desc>@brief Return the readable name of the language table

@param language Numerical ID of the language table to access

@return String containing the name of the table, NULL if ID was invalid or name was never specified</desc>
</method>
<method>
<name>getNumLang</name>
<args>()</args>
<desc>@brief Used to find out how many languages are in the table

@return Size of the vector containing the languages, numerical</desc>
</method>
<method>
<name>getString</name>
<args>(string filename)</args>
<desc>@brief Grabs a string from the specified table

If an invalid is passed, the function will attempt to to grab from the default table

@param filename Name of the language table to access

@return Text from the specified language table, "" if ID was invalid and default table is not set</desc>
</method>
<method>
<name>setCurrentLanguage</name>
<args>(int language)</args>
<desc>@brief Sets the current language table for grabbing text

@param language ID of the table</desc>
</method>
<method>
<name>setDefaultLanguage</name>
<args>(int language)</args>
<desc>@brief Sets the default language table

@param language ID of the table</desc>
</method>
</class>
<class>
<name>LangTableClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>LevelInfo</name>
<base>NetObject</base>
<field>
<name>advancedLightmapSupport</name>
<desc>Enable expanded support for mixing static and dynamic lighting (more costly)</desc>
</field>
<field>
<name>canvasClearColor</name>
<desc>The color used to clear the background before the scene or any GUIs are rendered.</desc>
</field>
<field>
<name>decalBias</name>
<desc>NearPlane bias used when rendering Decal and DecalRoad. This should be tuned to the visibleDistance in your level.</desc>
</field>
<field>
<name>fogAtmosphereHeight</name>
<desc>A height in meters for altitude fog falloff.</desc>
</field>
<field>
<name>fogColor</name>
<desc>The default color for the scene fog.</desc>
</field>
<field>
<name>fogDensity</name>
<desc>The 0 to 1 density value for the exponential fog falloff.</desc>
</field>
<field>
<name>fogDensityOffset</name>
<desc>An offset from the camera in meters for moving the start of the fog effect.</desc>
</field>
<field>
<name>nearClip</name>
<desc>Closest distance from the camera's position to render the world.</desc>
</field>
<field>
<name>soundAmbience</name>
<desc>The global ambient sound environment.</desc>
</field>
<field>
<name>soundDistanceModel</name>
<desc>The distance attenuation model to use.</desc>
</field>
<field>
<name>visibleDistance</name>
<desc>Furthest distance fromt he camera's position to render the world.</desc>
</field>
</class>
<class>
<name>LevelInfoClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>LightAnimData</name>
<base>SimDataBlock</base>
<field>
<name>brightnessA</name>
<desc>The value of the A key in the keyframe sequence.</desc>
</field>
<field>
<name>brightnessKeys</name>
<desc>The keyframe sequence encoded into a string where characters from A to Z define a position between the two animation values.</desc>
</field>
<field>
<name>brightnessPeriod</name>
<desc>The animation time for keyframe sequence.</desc>
</field>
<field>
<name>brightnessSmooth</name>
<desc>If true the transition between keyframes will be smooth.</desc>
</field>
<field>
<name>brightnessZ</name>
<desc>The value of the Z key in the keyframe sequence.</desc>
</field>
<field>
<name>colorA</name>
<desc>The value of the A key in the keyframe sequence.</desc>
</field>
<field>
<name>colorKeys</name>
<desc>The keyframe sequence encoded into a string where characters from A to Z define a position between the two animation values.</desc>
</field>
<field>
<name>colorPeriod</name>
<desc>The animation time for keyframe sequence.</desc>
</field>
<field>
<name>colorSmooth</name>
<desc>If true the transition between keyframes will be smooth.</desc>
</field>
<field>
<name>colorZ</name>
<desc>The value of the Z key in the keyframe sequence.</desc>
</field>
<field>
<name>offsetA</name>
<desc>The value of the A key in the keyframe sequence.</desc>
</field>
<field>
<name>offsetKeys</name>
<desc>The keyframe sequence encoded into a string where characters from A to Z define a position between the two animation values.</desc>
</field>
<field>
<name>offsetPeriod</name>
<desc>The animation time for keyframe sequence.</desc>
</field>
<field>
<name>offsetSmooth</name>
<desc>If true the transition between keyframes will be smooth.</desc>
</field>
<field>
<name>OffsetZ</name>
<desc>The value of the Z key in the keyframe sequence.</desc>
</field>
<field>
<name>rotA</name>
<desc>The value of the A key in the keyframe sequence.</desc>
</field>
<field>
<name>rotKeys</name>
<desc>The keyframe sequence encoded into a string where characters from A to Z define a position between the two animation values.</desc>
</field>
<field>
<name>rotPeriod</name>
<desc>The animation time for keyframe sequence.</desc>
</field>
<field>
<name>rotSmooth</name>
<desc>If true the transition between keyframes will be smooth.</desc>
</field>
<field>
<name>rotZ</name>
<desc>The value of the Z key in the keyframe sequence.</desc>
</field>
</class>
<class>
<name>LightAnimDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>LightBase</name>
<base>SceneObject</base>
<method>
<name>pauseAnimation</name>
<desc>Stops the light animation.</desc>
</method>
<method>
<name>playAnimation</name>
<args>( [LightAnimData anim] )</args>
<desc>Plays a light animation on the light.  If no LightAnimData is passed the existing one is played.@hide</desc>
</method>
<method>
<name>setLightEnabled</name>
<args>( bool state )</args>
<desc>@brief Toggles the light on and off

@param state Turns the light on (true) or off (false)
@tsexample
// Disable the light
CrystalLight.setLightEnabled(false);

// Renable the light
CrystalLight.setLightEnabled(true);
@endtsexample</desc>
</method>
<field>
<name>animate</name>
<desc>Toggles animation for the light on and off</desc>
</field>
<field>
<name>animationPeriod</name>
<desc>The length of time in seconds for a single playback of the light animation</desc>
</field>
<field>
<name>animationPhase</name>
<desc>The phase used to offset the animation start time to vary the animation of nearby lights.</desc>
</field>
<field>
<name>animationType</name>
<desc>Datablock containing light animation information (LightAnimData)</desc>
</field>
<field>
<name>attenuationRatio</name>
<desc>The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.</desc>
</field>
<field>
<name>brightness</name>
<desc>Adjusts the lights power, 0 being off completely.</desc>
</field>
<field>
<name>castShadows</name>
<desc>Enables/disabled shadow casts by this light.</desc>
</field>
<field>
<name>color</name>
<desc>Changes the base color hue of the light.</desc>
</field>
<field>
<name>cookie</name>
<desc>A custom pattern texture which is projected from the light.</desc>
</field>
<field>
<name>fadeStartDistance</name>
<desc>Start fading shadows out at this distance.  0 = auto calculate this distance.</desc>
</field>
<field>
<name>flareScale</name>
<desc>Globally scales all features of the light flare</desc>
</field>
<field>
<name>flareType</name>
<desc>Datablock containing light flare information (LightFlareData)</desc>
</field>
<field>
<name>includeLightmappedGeometryInShadow</name>
<desc>This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>isEnabled</name>
<desc>Enables/Disables the object rendering and functionality in the scene.</desc>
</field>
<field>
<name>lastSplitTerrainOnly</name>
<desc>This toggles only terrain being rendered to the last split of a PSSM shadow map.</desc>
</field>
<field>
<name>logWeight</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>numSplits</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>overDarkFactor</name>
<desc>The ESM shadow darkening factor</desc>
</field>
<field>
<name>priority</name>
<desc>Used for sorting of lights by the light manager. Priority determines if a light has a stronger effect than, those with a lower value</desc>
</field>
<field>
<name>representedInLightmap</name>
<desc>This light is represented in lightmaps (static light, default: false)</desc>
</field>
<field>
<name>shadowDarkenColor</name>
<desc>The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>shadowDistance</name>
<desc>The distance from the camera to extend the PSSM shadow.</desc>
</field>
<field>
<name>shadowSoftness</name>
<desc>float shadowSoftness</desc>
</field>
<field>
<name>shadowType</name>
<desc>The type of shadow to use on this light.</desc>
</field>
<field>
<name>texSize</name>
<desc>The texture size of the shadow map.</desc>
</field>
</class>
<class>
<name>LightBaseClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>LightDescription</name>
<base>SimDataBlock</base>
<method>
<name>apply</name>
<args>()</args>
<desc>@brief Force an inspectPostApply call for the benefit of tweaking via the console

Normally this functionality is only exposed to objects via the World Editor, once changes have been made. Exposing apply to script allows you to make changes to it on the fly without the World Editor.

@note This is intended for debugging and tweaking, not for game play

@tsexample
// Change a property of the light description
RocketLauncherLightDesc.brightness = 10;

// Make it so
RocketLauncherLightDesc.apply();
@endtsexample</desc>
</method>
<field>
<name>animationPeriod</name>
<desc>The length of time in seconds for a single playback of the light animation</desc>
</field>
<field>
<name>animationPhase</name>
<desc>The phase used to offset the animation start time to vary the animation of nearby lights.</desc>
</field>
<field>
<name>animationType</name>
<desc>Datablock containing light animation information (LightAnimData)</desc>
</field>
<field>
<name>attenuationRatio</name>
<desc>The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.</desc>
</field>
<field>
<name>brightness</name>
<desc>Adjusts the lights power, 0 being off completely.</desc>
</field>
<field>
<name>castShadows</name>
<desc>Enables/disabled shadow casts by this light.</desc>
</field>
<field>
<name>color</name>
<desc>Changes the base color hue of the light.</desc>
</field>
<field>
<name>cookie</name>
<desc>A custom pattern texture which is projected from the light.</desc>
</field>
<field>
<name>fadeStartDistance</name>
<desc>Start fading shadows out at this distance.  0 = auto calculate this distance.</desc>
</field>
<field>
<name>flareScale</name>
<desc>Globally scales all features of the light flare</desc>
</field>
<field>
<name>flareType</name>
<desc>Datablock containing light flare information (LightFlareData)</desc>
</field>
<field>
<name>includeLightmappedGeometryInShadow</name>
<desc>This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>lastSplitTerrainOnly</name>
<desc>This toggles only terrain being rendered to the last split of a PSSM shadow map.</desc>
</field>
<field>
<name>logWeight</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>numSplits</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>overDarkFactor</name>
<desc>The ESM shadow darkening factor</desc>
</field>
<field>
<name>range</name>
<desc>Controls the size (radius) of the light</desc>
</field>
<field>
<name>representedInLightmap</name>
<desc>This light is represented in lightmaps (static light, default: false)</desc>
</field>
<field>
<name>shadowDarkenColor</name>
<desc>The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>shadowDistance</name>
<desc>The distance from the camera to extend the PSSM shadow.</desc>
</field>
<field>
<name>shadowSoftness</name>
<desc>float shadowSoftness</desc>
</field>
<field>
<name>shadowType</name>
<desc>The type of shadow to use on this light.</desc>
</field>
<field>
<name>texSize</name>
<desc>The texture size of the shadow map.</desc>
</field>
</class>
<class>
<name>LightDescriptionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>LightFlareData</name>
<base>SimDataBlock</base>
<method>
<name>apply</name>
<args>()</args>
<desc>Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply</desc>
</method>
<field>
<name>elementDist</name>
<desc>Where this element appears along the flare beam.</desc>
</field>
<field>
<name>elementRect</name>
<desc>A rectangle specified in pixels of the flareTexture image.</desc>
</field>
<field>
<name>elementRotate</name>
<desc>Defines if this element orients to point along the flare beam or if it is always upright.</desc>
</field>
<field>
<name>elementScale</name>
<desc>Size scale applied to this element.</desc>
</field>
<field>
<name>elementTint</name>
<desc>Used to modulate this element's color if elementUseLightColor is false.
@see elementUseLightColor</desc>
</field>
<field>
<name>elementUseLightColor</name>
<desc>If true this element's color is modulated by the light color. If false, elementTint will be used.
@see elementTint</desc>
</field>
<field>
<name>flareEnabled</name>
<desc>Allows the user to disable this flare globally for any lights referencing it.</desc>
</field>
<field>
<name>flareTexture</name>
<desc>The texture / sprite sheet for this flare.</desc>
</field>
<field>
<name>occlusionRadius</name>
<desc>Radius in world units to test for occlusion if supported by hardware, disable by setting radius non-positive.</desc>
</field>
<field>
<name>overallScale</name>
<desc>Size scale applied to all elements of the flare.</desc>
</field>
<field>
<name>renderReflectPass</name>
<desc>If false this flare does not render in reflections. If true then elements with a distance of zero (eg. directly over the light source) will render into reflections.</desc>
</field>
</class>
<class>
<name>LightFlareDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Lightning</name>
<base>GameBase</base>
<method>
<name>strikeObject</name>
<args>( int id=NULL )</args>
<desc>Creates a LightningStrikeEvent which strikes a specific object.
@tsexample
// Define a ShapeBase ID
%shapeBaseID = 4566;

// Tell the lightning object to create a LightningStrikeEvent which hits a specific target.
%lightning.strikeObject(%shapeBaseID);
@endtsexample</desc>
</method>
<method>
<name>strikeRandomPoint</name>
<args>()</args>
<desc>Creates a LightningStrikeEvent which attempts to strike a random target in range of the Lightning object.
@tsexample
// Tell the lightning object to create a LightningStrikeEvent which will hit a target if one is available.
%lightning.strikeRandomPoint();
@endtsexample</desc>
</method>
<method>
<name>warningFlashes</name>
<args>()</args>
<desc>Adds a new LightningStrikeEvent to all clients.
@tsexample
// Tell the lightning object to create a LightningStrikeEvent on all connected clients.
%lightning.warningFlashes();
@endtsexample</desc>
</method>
<field>
<name>applyDamage( Point3F hitPosition, Point3F hitNormal, SceneObject hitObject )</name>
<desc>Informs an object that it was hit by lightning and needs to take damage.
@param Lightning object.
@param Object that was hit.
@param Position the lightning bolt hit in the world.
@param Range that the lightning bolt struck.
@see Lightning, LightningData</desc>
</field>
<field>
<name>boltStartRadius</name>
<desc>The radius in which a lightning bolt can occur from the center of the LightningData object.</desc>
</field>
<field>
<name>chanceToHitTarget</name>
<desc>Percentage change between 0.0f and 1.0f that the lightning bolt will hit something.</desc>
</field>
<field>
<name>color</name>
<desc>Color to blend the StrikeTextures in LightningData with.</desc>
</field>
<field>
<name>fadeColor</name>
<desc>Color to blend the StrikeTextures in LightningData with when the bolt is fading away.</desc>
</field>
<field>
<name>strikeRadius</name>
<desc>Radius in which a lightning bolt may occur from the center of the Lightning object.</desc>
</field>
<field>
<name>strikesPerMinute</name>
<desc>Number of lightning strikes to perform per minute.</desc>
</field>
<field>
<name>strikeWidth</name>
<desc>Width of a lightning bolt.</desc>
</field>
<field>
<name>useFog</name>
<desc>Boolean, determines the useage of fog on the lightning bolts.</desc>
</field>
</class>
<class>
<name>LightningClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>LightningData</name>
<base>GameBaseData</base>
<field>
<name>strikeSound</name>
<desc>Sound profile to play on a lightning strike.</desc>
</field>
<field>
<name>strikeTextures</name>
<desc>List of textures to use during a lightning strike.</desc>
</field>
<field>
<name>thunderSounds</name>
<desc>List of thunder sound effects to play.</desc>
</field>
</class>
<class>
<name>LightningDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>LightningStrikeEvent</name>
</class>
<class>
<name>LightningStrikeEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Marker</name>
<base>SceneObject</base>
<field>
<name>msToNext</name>
<desc>Milliseconds to next marker in sequence.</desc>
</field>
<field>
<name>seqNum</name>
<desc>Marker position in sequence of markers on this path.</desc>
</field>
<field>
<name>smoothingType</name>
<desc>Path smoothing at this marker/knot. "Linear"means no smoothing, while "Spline" means to smooth.</desc>
</field>
<field>
<name>type</name>
<desc>Type of this marker/knot. A "normal" knot will have a smooth camera translation/rotation effect.
"Position Only"will do the same for translations, leaving rotation un-touched.
Lastly, a "Kink" means the rotation will take effect immediately for an abrupt rotation change.</desc>
</field>
</class>
<class>
<name>MarkerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Material</name>
<base>SimObject</base>
<method>
<name>dumpInstances</name>
<desc>Dumps a formatted list of the currently allocated material instances for this material to the console.</desc>
</method>
<method>
<name>flush</name>
<desc>Flushes all material instances that use this material.</desc>
</method>
<method>
<name>getAnimFlags</name>
</method>
<method>
<name>getFilename</name>
<desc>Get filename of material</desc>
</method>
<method>
<name>isAutoGenerated</name>
<desc>Returns true if this Material was automatically generated by MaterialList::mapMaterials()</desc>
</method>
<method>
<name>reload</name>
<desc>Reloads all material instances that use this material.</desc>
</method>
<method>
<name>setAutoGenerated</name>
<desc>setAutoGenerated(bool isAutoGenerated): Set whether or not the Material is autogenerated.</desc>
</method>
<field>
<name>alphaRef</name>
<desc>The alpha reference value for alpha testing.  Must be between 0 to 255.
@see alphaTest</desc>
</field>
<field>
<name>alphaTest</name>
<desc>Enables alpha test when rendering the material.
@see alphaRef</desc>
</field>
<field>
<name>animFlags</name>
<desc>The types of animation to play on this material.</desc>
</field>
<field>
<name>baseTex</name>
<desc>For backwards compatibility.
@see diffuseMap</desc>
</field>
<field>
<name>bumpAtlas</name>
<desc>@internal</desc>
</field>
<field>
<name>bumpTex</name>
<desc>For backwards compatibility.
@see normalMap</desc>
</field>
<field>
<name>castShadows</name>
<desc>If set to false the lighting system will not cast shadows from this material.</desc>
</field>
<field>
<name>cellIndex</name>
<desc>@internal</desc>
</field>
<field>
<name>cellLayout</name>
<desc>@internal</desc>
</field>
<field>
<name>cellSize</name>
<desc>@internal</desc>
</field>
<field>
<name>colorMultiply</name>
<desc>For backwards compatibility.
@see diffuseColor</desc>
</field>
<field>
<name>cubemap</name>
<desc>The name of a CubemapData for environment mapping.</desc>
</field>
<field>
<name>customFootstepSound</name>
<desc>The sound to play when the player walks over the material.  If this is set, it overrides #footstepSoundId.  This field is useful for directly assigning custom footstep sounds to materials without having to rely on the PlayerData sound assignment.

@warn Be aware that materials are client-side objects.  This means that the SFXTracks assigned to materials must be client-side, too.</desc>
</field>
<field>
<name>customImpactSound</name>
<desc>The sound to play when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.  If this is set, it overrides #impactSoundId.  This field is useful for directly assigning custom impact sounds to materials without having to rely on the PlayerData sound assignment.

@warn Be aware that materials are client-side objects.  This means that the SFXTracks assigned to materials must be client-side, too.</desc>
</field>
<field>
<name>detailMap</name>
<desc>A typically greyscale detail texture additively blended into the material.</desc>
</field>
<field>
<name>detailNormalMap</name>
<desc>A second normal map texture applied at the detail scale.  You can use the DXTnm format only when per-pixel specular highlights are disabled.</desc>
</field>
<field>
<name>detailNormalMapStrength</name>
<desc>Used to scale the strength of the detail normal map when blended with the base normal map.</desc>
</field>
<field>
<name>detailScale</name>
<desc>The scale factor for the detail map.</desc>
</field>
<field>
<name>detailTex</name>
<desc>For backwards compatibility.
@see detailMap</desc>
</field>
<field>
<name>diffuseColor</name>
<desc>This color is multiplied against the diffuse texture color.  If no diffuse texture is present this is the material color.</desc>
</field>
<field>
<name>diffuseMap</name>
<desc>The diffuse color texture map.</desc>
</field>
<field>
<name>doubleSided</name>
<desc>Disables backface culling casing surfaces to be double sided. Note that the lighting on the backside will be a mirror of the front side of the surface.</desc>
</field>
<field>
<name>dynamicCubemap</name>
<desc>Enables the material to use the dynamic cubemap from the ShapeBase object its applied to.</desc>
</field>
<field>
<name>effectColor</name>
<desc>If #showDust is true, this is the set of colors to use for the ParticleData of the dust emitter.

@see ParticleData::colors</desc>
</field>
<field>
<name>emissive</name>
<desc>Enables emissive lighting for the material.</desc>
</field>
<field>
<name>envMap</name>
<desc>The name of an environment map cube map to apply to this material.</desc>
</field>
<field>
<name>envTex</name>
<desc>For backwards compatibility.
@see envMap</desc>
</field>
<field>
<name>footstepSoundId</name>
<desc>What sound to play from the PlayerData sound list when the player walks over the material.  -1 (default) to not play any sound.

The IDs are:

- 0: PlayerData::FootSoftSound
- 1: PlayerData::FootHardSound
- 2: PlayerData::FootMetalSound
- 3: PlayerData::FootSnowSound
- 4: PlayerData::FootShallowSound
- 5: PlayerData::FootWadingSound
- 6: PlayerData::FootUnderwaterSound
- 7: PlayerData::FootBubblesSound
- 8: PlayerData::movingBubblesSound
- 9: PlayerData::waterBreathSound
- 10: PlayerData::impactSoftSound
- 11: PlayerData::impactHardSound
- 12: PlayerData::impactMetalSound
- 13: PlayerData::impactSnowSound
- 14: PlayerData::impactWaterEasy
- 15: PlayerData::impactWaterMedium
- 16: PlayerData::impactWaterHard
- 17: PlayerData::exitingWater</desc>
</field>
<field>
<name>glow</name>
<desc>Enables rendering this material to the glow buffer.</desc>
</field>
<field>
<name>impactSoundId</name>
<desc>What sound to play from the PlayerData sound list when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.

For a list of IDs, see #footstepSoundId</desc>
</field>
<field>
<name>lightMap</name>
<desc>The lightmap texture used with pureLight.</desc>
</field>
<field>
<name>mapTo</name>
<desc>Used to map this material to the material name used by TSShape.</desc>
</field>
<field>
<name>minnaertConstant</name>
<desc>The Minnaert shading constant value.  Must be greater than 0 to enable the effect.</desc>
</field>
<field>
<name>normalMap</name>
<desc>The normal map texture.  You can use the DXTnm format only when per-pixel specular highlights are disabled, or a specular map is in use.</desc>
</field>
<field>
<name>overlayMap</name>
<desc>A secondary diffuse color texture map which will use the second texcoord of a mesh.</desc>
</field>
<field>
<name>overlayTex</name>
<desc>For backwards compatibility.
@see overlayMap</desc>
</field>
<field>
<name>parallaxScale</name>
<desc>Enables parallax mapping and defines the scale factor for the parallax effect.  Typically this value is less than 0.4 else the effect breaks down.</desc>
</field>
<field>
<name>pixelSpecular</name>
<desc>This enables per-pixel specular highlights controlled by the alpha channel of the normal map texture.  Note that if pixel specular is enabled the DXTnm format will not work with your normal map, unless you are also using a specular map.</desc>
</field>
<field>
<name>planarReflection</name>
<desc>@internal</desc>
</field>
<field>
<name>rotPivotOffset</name>
<desc>The piviot position in UV coordinates to center the rotation animation.</desc>
</field>
<field>
<name>rotSpeed</name>
<desc>The speed to rotate the texture in degrees per second when rotation animation is enabled.</desc>
</field>
<field>
<name>scrollDir</name>
<desc>The scroll direction in UV space when scroll animation is enabled.</desc>
</field>
<field>
<name>scrollSpeed</name>
<desc>The speed to scroll the texture in UVs per second when scroll animation is enabled.</desc>
</field>
<field>
<name>sequenceFramePerSec</name>
<desc>The number of frames per second for frame based sequence animations if greater than zero.</desc>
</field>
<field>
<name>sequenceSegmentSize</name>
<desc>The size of each frame in UV units for sequence animations.</desc>
</field>
<field>
<name>showDust</name>
<desc>Whether to emit dust particles from a shape moving over the material.  This is, for example, used by vehicles or players to decide whether to show dust trails.</desc>
</field>
<field>
<name>showFootprints</name>
<desc>Whether to show player footprint decals on this material.

@see PlayerData::decalData</desc>
</field>
<field>
<name>specular</name>
<desc>The color of the specular highlight when not using a specularMap.</desc>
</field>
<field>
<name>specularMap</name>
<desc>The specular map texture. The RGB channels of this texture provide a per-pixel replacement for the 'specular' parameter on the material. If this texture contains alpha information, the alpha channel of the texture will be used as the gloss map. This provides a per-pixel replacement for the 'specularPower' on the material</desc>
</field>
<field>
<name>specularPower</name>
<desc>The intensity of the specular highlight when not using a specularMap.</desc>
</field>
<field>
<name>subSurface</name>
<desc>Enables the subsurface scattering approximation.</desc>
</field>
<field>
<name>subSurfaceColor</name>
<desc>The color used for the subsurface scattering approximation.</desc>
</field>
<field>
<name>subSurfaceRolloff</name>
<desc>The 0 to 1 rolloff factor used in the subsurface scattering approximation.</desc>
</field>
<field>
<name>toneMap</name>
<desc>The tonemap texture used with pureLight.</desc>
</field>
<field>
<name>translucent</name>
<desc>If true this material is translucent blended.</desc>
</field>
<field>
<name>translucentBlendOp</name>
<desc>The type of blend operation to use when the material is translucent.</desc>
</field>
<field>
<name>translucentZWrite</name>
<desc>If enabled and the material is translucent it will write into the depth buffer.</desc>
</field>
<field>
<name>useAnisotropic</name>
<desc>Use anisotropic filtering for the textures of this stage.</desc>
</field>
<field>
<name>vertColor</name>
<desc>If enabled, vertex colors are premultiplied with diffuse colors.</desc>
</field>
<field>
<name>vertLit</name>
<desc>If true the vertex color is used for lighting.</desc>
</field>
<field>
<name>waveAmp</name>
<desc>The wave amplitude when wave animation is enabled.</desc>
</field>
<field>
<name>waveFreq</name>
<desc>The wave frequency when wave animation is enabled.</desc>
</field>
<field>
<name>waveType</name>
<desc>The type of wave animation to perform when wave animation is enabled.</desc>
</field>
</class>
<class>
<name>MaterialClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MaterialSet</name>
<base>SimSet</base>
</class>
<class>
<name>MECreateUndoAction</name>
<base>UndoAction</base>
<method>
<name>addObject</name>
<args>( SimObject obj )</args>
</method>
</class>
<class>
<name>MECreateUndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MEDeleteUndoAction</name>
<base>UndoAction</base>
<method>
<name>deleteObject</name>
<args>( SimObject obj )</args>
</method>
</class>
<class>
<name>MEDeleteUndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MenuBar</name>
<base>SimSet</base>
<method>
<name>attachToCanvas</name>
<args>(GuiCanvas, pos)</args>
</method>
<method>
<name>insert</name>
<args>(object, pos)</args>
<desc>insert object at position</desc>
</method>
<method>
<name>removeFromCanvas</name>
<args>()</args>
</method>
</class>
<class>
<name>MenuBarClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MeshRoad</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
<args>()</args>
<desc>Intended as a helper to developers and editor scripts.
Force trigger an inspectPostApply. This will transmit material and other fields ( not including nodes ) to client objects.</desc>
</method>
<method>
<name>regenerate</name>
<args>()</args>
<desc>Intended as a helper to developers and editor scripts.
Force MeshRoad to recreate its geometry.</desc>
</method>
<method>
<name>setNodeDepth</name>
<args>( int idx, float meters )</args>
<desc>Intended as a helper to developers and editor scripts.
Sets the depth in meters of a particular node.</desc>
</method>
<field>
<name>bottomMaterial</name>
<desc>Material for the bottom surface of the road.</desc>
</field>
<field>
<name>breakAngle</name>
<desc>Angle in degrees - MeshRoad will subdivide the spline if its curve is greater than this threshold.</desc>
</field>
<field>
<name>Node</name>
<desc>Do not modify, for internal use.</desc>
</field>
<field>
<name>sideMaterial</name>
<desc>Material for the left, right, front, and back surfaces of the road.</desc>
</field>
<field>
<name>textureLength</name>
<desc>The length in meters of textures mapped to the MeshRoad.</desc>
</field>
<field>
<name>topMaterial</name>
<desc>Material for the upper surface of the road.</desc>
</field>
<field>
<name>widthSubdivisions</name>
<desc>Subdivide segments widthwise this many times when generating vertices.</desc>
</field>
</class>
<class>
<name>MeshRoadClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Message</name>
<base>SimObject</base>
<method>
<name>addReference</name>
<args>()</args>
<desc>Increment the reference count for this message</desc>
</method>
<method>
<name>freeReference</name>
<args>()</args>
<desc>Decrement the reference count for this message</desc>
</method>
<method>
<name>getType</name>
<args>()</args>
<desc>Get message type (script class name or C++ class name if no script defined class)</desc>
</method>
<field>
<name>onAdd()</name>
<desc>Script callback when a message is first created and registered.

@tsexample
function Message::onAdd(%this)
{
^// Perform on add code here
}
@endtsexample</desc>
</field>
<field>
<name>onRemove()</name>
<desc>Script callback when a message is deleted.

@tsexample
function Message::onRemove(%this)
{
^// Perform on remove code here
}
@endtsexample</desc>
</field>
</class>
<class>
<name>MessageClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MessageForwarder</name>
<base>ScriptMsgListener</base>
<field>
<name>toQueue</name>
<desc>Name of queue to forward to</desc>
</field>
</class>
<class>
<name>MessageForwarderClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MessageVector</name>
<base>SimObject</base>
<method>
<name>clear</name>
<args>()</args>
<desc>Clear all messages in the vector

@tsexample
HudMessageVector.clear();
@endtsexample</desc>
</method>
<method>
<name>deleteLine</name>
<args>( int deletePos )</args>
<desc>Delete the line at the specified position.

@param deletePos Position in the vector containing the line to be deleted
@tsexample
// Delete the first line (index 0) in the vector...
HudMessageVector.deleteLine(0);
@endtsexample

@return False if deletePos is greater than the number of lines in the current vector</desc>
</method>
<method>
<name>dump</name>
<args>(string filename, string header=NULL)</args>
<desc>Dump the message vector to a file, optionally prefixing a header.@hide</desc>
</method>
<method>
<name>getLineIndexByTag</name>
<args>( int tag )</args>
<desc>Scan through the vector, returning the line number of the first line that matches the specified tag; else returns -1 if no match was found.

@param tag Numerical value assigned to a message when it was added or inserted
@tsexample
// Locate a line of text tagged with the value "1", then delete it.
%taggedLine = HudMessageVector.getLineIndexByTag(1);
HudMessageVector.deleteLine(%taggedLine);
@endtsexample

@return Line with matching tag, other wise -1</desc>
</method>
<method>
<name>getLineTag</name>
<args>( int pos )</args>
<desc>Get the tag of a specified line.

@param pos Position in vector to grab tag from
@tsexample
// Remove all lines that do not have a tag value of 1.
while( HudMessageVector.getNumLines())
{
%tag = HudMessageVector.getLineTag(1);
if(%tag != 1)
%tag.delete();
HudMessageVector.popFrontLine();
}
@endtsexample

@return Tag value of a given line, if the position is greater than the number of lines return 0</desc>
</method>
<method>
<name>getLineText</name>
<args>( int pos )</args>
<desc>Get the text at a specified line.

@param pos Position in vector to grab text from
@tsexample
// Print a line of text at position 1.
%text = HudMessageVector.getLineText(1);
echo(%text);
@endtsexample

@return Text at specified line, if the position is greater than the number of lines return ""</desc>
</method>
<method>
<name>getLineTextByTag</name>
<args>( int tag )</args>
<desc>Scan through the lines in the vector, returning the first line that has a matching tag.

@param tag Numerical value assigned to a message when it was added or inserted
@tsexample
// Locate text in the vector tagged with the value "1", then print it
%taggedText = HudMessageVector.getLineTextByTag(1);
echo(%taggedText);
@endtsexample

@return Text from a line with matching tag, other wise ""</desc>
</method>
<method>
<name>getNumLines</name>
<args>()</args>
<desc>Get the number of lines in the vector.

@tsexample
// Find out how many lines have been stored in HudMessageVector
%chatLines = HudMessageVector.getNumLines();
echo(%chatLines);
@endtsexample</desc>
</method>
<method>
<name>insertLine</name>
<args>( int insertPos, string msg, int tag )</args>
<desc>Push a line onto the back of the list.

@param msg Text that makes up the message
@param tag Numerical value associated with this message, useful for searching.

@tsexample
// Add the message...
HudMessageVector.insertLine(1, "Hello World", 0);
@endtsexample

@return False if insertPos is greater than the number of lines in the current vector</desc>
</method>
<method>
<name>popBackLine</name>
<args>()</args>
<desc>Pop a line from the back of the list; destroys the line.

@tsexample
HudMessageVector.popBackLine();
@endtsexample

@return False if there are no lines to pop (underflow), true otherwise</desc>
</method>
<method>
<name>popFrontLine</name>
<args>()</args>
<desc>Pop a line from the front of the vector, destroying the line.

@tsexample
HudMessageVector.popFrontLine();
@endtsexample

@return False if there are no lines to pop (underflow), true otherwise</desc>
</method>
<method>
<name>pushBackLine</name>
<args>( string msg, int tag )</args>
<desc>Push a line onto the back of the list.

@param msg Text that makes up the message
@param tag Numerical value associated with this message, useful for searching.

@tsexample
// Add the message...
HudMessageVector.pushBackLine("Hello World", 0);
@endtsexample</desc>
</method>
<method>
<name>pushFrontLine</name>
<args>( string msg, int tag )</args>
<desc>Push a line onto the front of the vector.

@param msg Text that makes up the message
@param tag Numerical value associated with this message, useful for searching.

@tsexample
// Add the message...
HudMessageVector.pushFrontLine("Hello World", 0);
@endtsexample</desc>
</method>
</class>
<class>
<name>MessageVectorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MirrorSubObject</name>
<base>SceneObject</base>
</class>
<class>
<name>MirrorSubObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MissionArea</name>
<base>NetObject</base>
<method>
<name>getArea</name>
<args>()</args>
<desc>Returns 4 fields: starting x, starting y, extents x, extents y</desc>
</method>
<method>
<name>setArea</name>
<args>(int x, int y, int width, int height)</args>
<desc>@brief - Defines the size of the MissionArea

param x Starting X coordinate position for MissionArea
param y Starting Y coordinate position for MissionArea
param width New width of the MissionArea
param height New height of the MissionArea</desc>
</method>
<field>
<name>area</name>
<desc>Four corners (X1, X2, Y1, Y2) that makes up the level's boundaries</desc>
</field>
<field>
<name>flightCeiling</name>
<desc>Represents the top of the mission area, used by FlyingVehicle. MissionArea must be named "GlobalMissionArea" for this to be used.</desc>
</field>
<field>
<name>flightCeilingRange</name>
<desc>Distance from ceiling before FlyingVehicle thrust is cut off. MissionArea must be named "GlobalMissionArea" for this to be used.</desc>
</field>
</class>
<class>
<name>MissionAreaClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MissionAreaEditor</name>
<base>GuiBitmapCtrl</base>
<method>
<name>centerWorld</name>
<desc>Realign the world so that the mission area is centered.

This method moves every SceneObject (including terrain) in the world so that the center of the world is the center of the mission area.</desc>
</method>
<method>
<name>getArea</name>
<desc>Return a 4-tuple: area_x area_y area_width are_height</desc>
</method>
<method>
<name>setArea</name>
<args>(int x, int y, int w, int h)</args>
<desc>Set the mission area to the specified co-ordinates/extents.</desc>
</method>
<method>
<name>updateTerrain</name>
<desc>Update the terrain bitmap that is rendered as background in the control.</desc>
</method>
<field>
<name>cameraColor</name>
<desc>ColorI cameraColor</desc>
</field>
<field>
<name>defaultObjectColor</name>
<desc>ColorI defaultObjectColor</desc>
</field>
<field>
<name>enableEditing</name>
<desc>bool enableEditing</desc>
</field>
<field>
<name>enableMirroring</name>
<desc>bool enableMirroring</desc>
</field>
<field>
<name>handleFillColor</name>
<desc>ColorI handleFillColor</desc>
</field>
<field>
<name>handleFrameColor</name>
<desc>ColorI handleFrameColor</desc>
</field>
<field>
<name>mirrorArrowColor</name>
<desc>ColorI mirrorArrowColor</desc>
</field>
<field>
<name>mirrorIndex</name>
<desc>int mirrorIndex</desc>
</field>
<field>
<name>mirrorLineColor</name>
<desc>ColorI mirrorLineColor</desc>
</field>
<field>
<name>missionBoundsColor</name>
<desc>ColorI missionBoundsColor</desc>
</field>
<field>
<name>renderCamera</name>
<desc>bool renderCamera</desc>
</field>
<field>
<name>squareBitmap</name>
<desc>bool squareBitmap</desc>
</field>
<field>
<name>waterObjectColor</name>
<desc>ColorI waterObjectColor</desc>
</field>
</class>
<class>
<name>MissionAreaEditorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MissionMarker</name>
<base>ShapeBase</base>
</class>
<class>
<name>MissionMarkerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MissionMarkerData</name>
<base>ShapeBaseData</base>
</class>
<class>
<name>MissionMarkerDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>MoreAdvancedComponent</name>
<base>SimComponent</base>
</class>
<class>
<name>MoreAdvancedComponentClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>NetConnection</name>
<base>SimGroup</base>
<method>
<name>checkMaxRate</name>
<args>()</args>
<desc>@brief Ensures that all configured packet rates and sizes meet minimum requirements.

This method is normally only called when a NetConnection class is first constructed.  It need only be manually called if the global variables that set the packet rate or size have changed.

@note If $pref::Net::PacketRateToServer, $pref::Net::PacketRateToClient or $pref::Net::PacketSize have been changed since a NetConnection has been created, this method must be called on all connections for them to follow the new rates or size.</desc>
</method>
<method>
<name>clearPaths</name>
<args>()</args>
<desc>@brief On the server, resets the connection to indicate that mod paths have not been transmitted.

Typically when a mission has ended on the server, all connected clients are informed of this change and their connections are reset back to a starting state.  This method resets a connection on the server to indicate that mod paths have not been transmitted.

@tsexample
// Inform the clients
for (%clientIndex = 0; %clientIndex &lt; ClientGroup.getCount(); %clientIndex++)
{
// clear ghosts and paths from all clients
%cl = ClientGroup.getObject(%clientIndex);
%cl.endMission();
%cl.resetGhosting();
%cl.clearPaths();
}
@endtsexample</desc>
</method>
<method>
<name>connect</name>
<args>( string remoteAddress )</args>
<desc>@brief Connects to the remote address.

Attempts to connect with another NetConnection on the given address.  Typically once connected, a game's information is passed along from the server to the client, followed by the player entering the game world.  The actual procedure is dependent on the NetConnection subclass that is used.  i.e. GameConnection.
@param remoteAddress The address to connect to in the form of IP:&amp;lt;address&amp;gt;:&amp;lt;port&amp;rt; although the &lt;i&gt;IP:&lt;/i&gt; portion is optional.  The &lt;i&gt;address&lt;/i&gt; portion may be in the form of w.x.y.z or as a host name, in which case a DNS lookup will be performed.  You may also substitue the word &lt;i&gt;broadcast&lt;/i&gt; for the address to broadcast the connect request over the local subnet.

@see NetConnection::connectLocal() to connect to a server running within the same process as the client.</desc>
</method>
<method>
<name>connectLocal</name>
<args>()</args>
<desc>@brief Connects with the server that is running within the same process as the client.

@returns An error text message upon failure, or an empty string when successful.

@see See @ref local_connections for a description of local connections and their use.  See NetConnection::connect() to connect to a server running in another process (on the same machine or not).</desc>
</method>
<method>
<name>getAddress</name>
<args>()</args>
<desc>@brief Returns the far end network address for the connection.

The address will be in one of the following forms:
- &lt;b&gt;IP:Broadcast:&amp;lt;port&amp;gt;&lt;/b&gt; for broadcast type addresses
- &lt;b&gt;IP:&amp;lt;address&amp;gt;:&amp;lt;port&amp;gt;&lt;/b&gt; for IP addresses
- &lt;b&gt;local&lt;/b&gt; when connected locally (server and client running in same process</desc>
</method>
<method>
<name>getGhostID</name>
<args>( int realID )</args>
<desc>@brief On server or client, convert a real id to the ghost id for this connection.

Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use this method on the server or client to discover an object's ghost ID based on its real SimObject ID.
@param realID The real SimObject ID of the object.
@returns The ghost ID of the object for this connection, or -1 if it could not be resolved.

@see @ref ghosting_scoping for a description of the ghosting system.</desc>
</method>
<method>
<name>getGhostsActive</name>
<args>()</args>
<desc>@brief Returns the number of active ghosts on the connection.</desc>
</method>
<method>
<name>getPacketLoss</name>
<args>()</args>
<desc>@brief Returns the percentage of packets lost per tick.

@note This method is not yet hooked up.</desc>
</method>
<method>
<name>getPing</name>
<args>()</args>
<desc>@brief Returns the average round trip time (in ms) for the connection.

The round trip time is recalculated every time a notify packet is received.  Notify packets are used to information the connection that the far end successfully received the sent packet.</desc>
</method>
<method>
<name>resolveGhostID</name>
<args>( int ghostID )</args>
<desc>@brief On the client, convert a ghost ID from this connection to a real SimObject ID.

Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use this method on the client to discover an object's local SimObject ID when you only have a ghost ID.
@param ghostID The ghost ID of the object as sent by the server.
@returns The SimObject ID of the object, or 0 if it could not be resolved.

@tsexample
%object = ServerConnection.resolveGhostID( %ghostId );
@endtsexample

@see @ref ghosting_scoping for a description of the ghosting system.</desc>
</method>
<method>
<name>resolveObjectFromGhostIndex</name>
<args>( int ghostID )</args>
<desc>@brief On the server, convert a ghost ID from this connection to a real SimObject ID.

Torque's network ghosting system only exchanges ghost ID's between the server and client.  Use this method on the server to discover an object's local SimObject ID when you only have a ghost ID.
@param ghostID The ghost ID of the object as sent by the server.
@returns The SimObject ID of the object, or 0 if it could not be resolved.

@tsexample
%object = %client.resolveObjectFromGhostIndex( %ghostId );
@endtsexample

@see @ref ghosting_scoping for a description of the ghosting system.</desc>
</method>
<method>
<name>setSimulatedNetParams</name>
<args>( float packetLoss, int delay )</args>
<desc>@brief Simulate network issues on the connection for testing.

@param packetLoss The fraction of packets that will be lost.  Ranges from 0.0 (no loss) to 1.0 (complete loss)
@param delay Delays packets being transmitted by simulating a particular ping.  This is an absolute integer, measured in ms.</desc>
</method>
<method>
<name>transmitPaths</name>
<args>()</args>
<desc>@brief Sent by the server during phase 2 of the mission download to update mod paths.

Mod paths on the client need to be in sync with the server prior to objects being ghosted.  This is typically done during the standard mission start phase 2 when following Torque's example mission startup sequence.

@tsexample
function serverCmdMissionStartPhase2Ack(%client, %seq, %playerDB)
{
// Make sure to ignore calls from a previous mission load
if (%seq != $missionSequence || !$MissionRunning)
return;
if (%client.currentPhase != 1.5)
return;
%client.currentPhase = 2;

// Set the player datablock choice
%client.playerDB = %playerDB;

// Update mod paths, this needs to get there before the objects.
%client.transmitPaths();

// Start ghosting objects to the client
%client.activateGhosting();
}
@endtsexample</desc>
</method>
</class>
<class>
<name>NetConnectionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>NetObject</name>
<base>SimObject</base>
<method>
<name>clearScopeToClient</name>
<args>( NetConnection client )</args>
<desc>@brief Undo the effects of a scopeToClient() call.

@param client The connection to remove this object's scoping from</desc>
</method>
<method>
<name>getClientObject</name>
<args>()</args>
<desc>@brief Returns a pointer to the client object when on a local connection.

Short-Circuit-Networking: this is only valid for a local-client / singleplayer situation.

@tsexample
// Psuedo-code, some values left out for this example
%node = new ParticleEmitterNode(){};
%clientObject = %node.getClientObject();
if(isObject(%clientObject)
^%clientObject.setTransform("0 0 0");

@endtsexample

@return The ID of client object</desc>
</method>
<method>
<name>getGhostID</name>
<args>()</args>
<desc>@brief Get the ghost index of this object from the server.

@tsexample
%ghostID = LocalClientConnection.getGhostId( %serverObject );
@endtsexample

@return The index of this ghost in the GhostManager on the server</desc>
</method>
<method>
<name>getServerObject</name>
<args>()</args>
<desc>@brief Returns a pointer to the client object when on a local connection.

Short-Circuit-Netorking: this is only valid for a local-client / singleplayer situation.

@tsexample
// Psuedo-code, some values left out for this example
%node = new ParticleEmitterNode(){};
%serverObject = %node.getServerObject();
if(isObject(%serverObject)
^%serverObject.setTransform("0 0 0");

@endtsexample

@return The ID of server object</desc>
</method>
<method>
<name>isClientObject</name>
<args>()</args>
<desc>@brief Called to check if an object resides on the clientside.

@return True if the object resides on the client, false otherwise.</desc>
</method>
<method>
<name>isServerObject</name>
<args>()</args>
<desc>@brief Checks if an object resides on the server.

@return True if the object resides on the server, false otherwise.</desc>
</method>
<method>
<name>scopeToClient</name>
<args>( NetConnection client )</args>
<desc>@brief Cause the NetObject to be forced as scoped on the specified NetConnection.

@param client The connection this object will always be scoped to

@tsexample
// Called to create new cameras in TorqueScript
// %this - The active GameConnection
// %spawnPoint - The spawn point location where we creat the camera
function GameConnection::spawnCamera(%this, %spawnPoint)
{
^// If this connection's camera exists
^if(isObject(%this.camera))
^{
^^// Add it to the mission group to be cleaned up later
^^MissionCleanup.add( %this.camera );

^^// Force it to scope to the client side
^^%this.camera.scopeToClient(%this);
^}
}
@endtsexample</desc>
</method>
<method>
<name>setScopeAlways</name>
<args>()</args>
<desc>@brief Always scope this object on all connections.

The object is marked as ScopeAlways and is immediately ghosted to all active connections.  This function has no effect if the object is not marked as Ghostable.</desc>
</method>
</class>
<class>
<name>NetObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>NetStringEvent</name>
</class>
<class>
<name>NetStringEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>OpenFileDialog</name>
<base>FileDialog</base>
<field>
<name>MultipleFiles</name>
<desc>True/False whether multiple files may be selected and returned or not</desc>
</field>
<field>
<name>MustExist</name>
<desc>True/False whether the file returned must exist or not</desc>
</field>
</class>
<class>
<name>OpenFileDialogClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>OpenFolderDialog</name>
<base>OpenFileDialog</base>
<field>
<name>fileMustExist</name>
<desc>File that must in selected folder for it to be valid</desc>
</field>
</class>
<class>
<name>OpenFolderDialogClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ParticleData</name>
<base>SimDataBlock</base>
<method>
<name>reload</name>
<args>()</args>
<desc>Reloads this particle.
@tsexample
// Get the editor's current particle
%particle = PE_ParticleEditor.currParticle

// Change a particle value
%particle.setFieldValue(%propertyField,%value);

// Reload it
%particle.reload();
@endtsexample</desc>
</method>
<field>
<name>animateTexture</name>
<desc>If true, allow the particle texture to be an animated sprite.</desc>
</field>
<field>
<name>animTexFrames</name>
<desc>A list of frames and / or frame ranges to use for particle animation if animateTexture is true. Example: "0-16 20 19 18 17 31-21".</desc>
</field>
<field>
<name>animTexName</name>
<desc>Texture file to use for this particle if animateTexture is true.</desc>
</field>
<field>
<name>animTexTiling</name>
<desc>The number of frames, in the rows and columns, stored in animTexName. Maximum of 256 frames can be stored in a single animTexName when using animTexTiling. Entered as "Columns / Rows". eg. "4 4".</desc>
</field>
<field>
<name>colors</name>
<desc>Color values to set the particles, rgba. Up to 4 allowed. Will transition through colors based on values set in the times value. Example: colors[0] = "0.6 1.0 1.0 0.5".</desc>
</field>
<field>
<name>constantAcceleration</name>
<desc>Amount to continously accelerate this particle by.</desc>
</field>
<field>
<name>dragCoefficient</name>
<desc>Particle physics drag amount.</desc>
</field>
<field>
<name>framesPerSec</name>
<desc>If animateTexture is true, this defines the frames per second of the sprite animation.</desc>
</field>
<field>
<name>gravityCoefficient</name>
<desc>Strength of gravity on the particles.</desc>
</field>
<field>
<name>inheritedVelFactor</name>
<desc>Amount to allow the velocity inherited from the emitter to effect the velocity of these particles.</desc>
</field>
<field>
<name>lifetimeMS</name>
<desc>Time in milliseconds before this particle is destroyed.</desc>
</field>
<field>
<name>lifetimeVarianceMS</name>
<desc>Variance in lifetime of particle between 0 milliseconds and n.</desc>
</field>
<field>
<name>sizes</name>
<desc>Sizes to set the particles. Up to 4 allowed. Will transition through sizes based on values set in the times value.</desc>
</field>
<field>
<name>spinRandomMax</name>
<desc>Maximum allowed spin speed of this particle, between spinRandomMin and n.</desc>
</field>
<field>
<name>spinRandomMin</name>
<desc>Minimum allowed spin speed of this particle, between n and spinRandomMax.</desc>
</field>
<field>
<name>spinSpeed</name>
<desc>Speed at which to spin the particle.</desc>
</field>
<field>
<name>textureCoords</name>
<desc>4 dimensional array defining the 4 locational points, in F32 (where 0.0 is top / left and 1.0 is bottom / right) of the textureName to use for this particle.</desc>
</field>
<field>
<name>TextureName</name>
<desc>Texture file to use for this particle.</desc>
</field>
<field>
<name>times</name>
<desc>Times to transition between colors and sizes. Up to 4 allowed. Values are 0.0 - 1.0, and corrispond to the life of the particle where 0 is first created and 1 is end of lifespace.</desc>
</field>
<field>
<name>useInvAlpha</name>
<desc>If true, will invert the colors of this particle.</desc>
</field>
<field>
<name>windCoefficient</name>
<desc>Strength of wind on the particles.</desc>
</field>
</class>
<class>
<name>ParticleDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ParticleEmitter</name>
<base>GameBase</base>
</class>
<class>
<name>ParticleEmitterClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ParticleEmitterData</name>
<base>GameBaseData</base>
<method>
<name>reload</name>
<args>()</args>
<desc>Reloads this emitter
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Change a field value
%emitter.setFieldValue(%propertyField,%value);

// Reload this emitter
%emitter.reload();
@endtsexample</desc>
</method>
<field>
<name>alignDirection</name>
<desc>The direction aligned particles should face, defined as the 3 F32 values of X Y Z.</desc>
</field>
<field>
<name>alignParticles</name>
<desc>If true, particles always face along a particular axis.</desc>
</field>
<field>
<name>ambientFactor</name>
<desc>Used to generate the final particle color by interpolating between the particle color and the particle color multiplied by the ambient color.</desc>
</field>
<field>
<name>blendStyle</name>
<desc>Pre-defined blend factor setting. Use integer value. BlendNormal = 1, BlendAdditive = 2, BlendSubtractive = 3, BlendPremultAlpha = 4, BlendGreyscale = 5.</desc>
</field>
<field>
<name>ejectionOffset</name>
<desc>Z offset from emitter point to eject from.</desc>
</field>
<field>
<name>ejectionPeriodMS</name>
<desc>Time, in Milliseconds, between particle ejection.</desc>
</field>
<field>
<name>ejectionVelocity</name>
<desc>Ejection velocity.</desc>
</field>
<field>
<name>highResOnly</name>
<desc>This particle system should not use the mixed-resolution renderer. If your particle system has large amounts of overdraw, consider disabling this option.</desc>
</field>
<field>
<name>lifetimeMS</name>
<desc>Lifetime of particles.</desc>
</field>
<field>
<name>lifetimeVarianceMS</name>
<desc>Varience in lifetime from 0 milliseconds to n.</desc>
</field>
<field>
<name>orientOnVelocity</name>
<desc>If true, Particles will face the screen at the start.</desc>
</field>
<field>
<name>orientParticles</name>
<desc>If true, Particles will always face the screen.</desc>
</field>
<field>
<name>overrideAdvance</name>
<desc>If false, particles emitted in the same frame have their positions adjusted. If true, adjustment is skipped and particles will clump together.</desc>
</field>
<field>
<name>particles</name>
<desc>Used to load particle data directly from a string.</desc>
</field>
<field>
<name>periodVarianceMS</name>
<desc>Varience in ejection period between 0 milliseconds and n.</desc>
</field>
<field>
<name>phiReferenceVel</name>
<desc>Reference angle, from the verticle plane, to eject from.</desc>
</field>
<field>
<name>phiVariance</name>
<desc>Varience from the reference angle, from 0 to n.</desc>
</field>
<field>
<name>reverseOrder</name>
<desc>If true, reverses draw order of particles.</desc>
</field>
<field>
<name>softnessDistance</name>
<desc>For soft particles, the distance (in meters) where particles will be faded based on the difference in depth between the particle and the scene geometry.</desc>
</field>
<field>
<name>sortParticles</name>
<desc>If true, particles are sorted back-to-front.</desc>
</field>
<field>
<name>TextureName</name>
<desc>Emitter texture file to override particle textures.</desc>
</field>
<field>
<name>thetaMax</name>
<desc>Maximum angle, from the horizontal plane, to eject from.</desc>
</field>
<field>
<name>thetaMin</name>
<desc>Minimum angle, from the horizontal plane, to eject from.</desc>
</field>
<field>
<name>useEmitterColors</name>
<desc>If true, will use emitter specified colors instead of datablock colors.</desc>
</field>
<field>
<name>useEmitterSizes</name>
<desc>If true, will use emitter specified sizes instead of datablock sizes.</desc>
</field>
<field>
<name>velocityVariance</name>
<desc>Variance for velocity between 0 and n.</desc>
</field>
</class>
<class>
<name>ParticleEmitterDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ParticleEmitterNode</name>
<base>GameBase</base>
<method>
<name>setEmitterDataBlock</name>
<args>( ParticleEmitterData emitterDatablock=0 )</args>
<desc>Assigns the datablock for this emitter.
@param datablockID Numerical reference to datablock ID
@tsexample
// Get the editor's current particle emitter
%emitter = PE_EmitterEditor.currEmitter

// Assign a new datablock value
%emitter.setEmitterDatablock(%emitterDatablock);
@endtsexample</desc>
</method>
<field>
<name>active</name>
<desc>Boolean which sets and determines if this EmitterNode is active or not.</desc>
</field>
<field>
<name>emitter</name>
<desc>Particle emitter datablock to use.</desc>
</field>
<field>
<name>velocity</name>
<desc>Velocity to use when spawning the particles.</desc>
</field>
</class>
<class>
<name>ParticleEmitterNodeClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ParticleEmitterNodeData</name>
<base>GameBaseData</base>
<field>
<name>timeMultiple</name>
<desc>Time multiplier for particle emitter nodes.</desc>
</field>
</class>
<class>
<name>ParticleEmitterNodeDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Path</name>
<base>SimGroup</base>
<method>
<name>getPathId</name>
<args>()</args>
<desc>@brief Returns the PathID (not the object ID) of this path.

@return PathID (not the object ID) of this path.
@tsexample
// Acquire the PathID of this path object.
%pathID = %thisPath.getPathId();

@endtsexample</desc>
</method>
<field>
<name>isLooping</name>
<desc>If this is true, the loop is closed, otherwise it is open.</desc>
</field>
</class>
<class>
<name>PathCamera</name>
<base>ShapeBase</base>
<method>
<name>popFront</name>
<args>()</args>
<desc>Removes the knot at the front of the camera's path.
@tsexample
// Remove the first knot in the camera's path.
%pathCamera.popFront();
@endtsexample</desc>
</method>
<method>
<name>pushBack</name>
<args>( string transform="1.0 1.0 1.0 1.0 1.0 1.0 1.0", float speed=1.0, string type="Normal", string path="Linear" )</args>
<desc>Adds a new knot to the back of a path camera's path.
@param transform Transform vector for the new knot. (Pos_X Pos_Y Pos_Z Rot_X Rot_Y Rot_Z Angle)
@param speed Speed setting for this knot.
@param type Knot type (Normal, Position Only, Kink).
@param path Path type (Linear, Spline).
@tsexample
// Transform vector for new knot. (Pos_X Pos_Y Pos_Z Rot_X Rot_Y Rot_Z Angle)
%transform = "15.0 5.0 5.0 1.4 1.0 0.2 1.0"

// Speed setting for knot.
%speed = "1.0"

// Knot type. (Normal, Position Only, Kink)
%type = "Normal";

// Path Type. (Linear, Spline)
%path = "Linear";

// Inform the path camera to add a new knot to the back of its path
%pathCamera.pushBack(%transform,%speed,%type,%path);
@endtsexample</desc>
</method>
<method>
<name>pushFront</name>
<args>( string transform="1.0 1.0 1.0 1.0 1.0 1.0 1.0", float speed=1.0, string type="Normal", string path="Linear" )</args>
<desc>Adds a new knot to the front of a path camera's path.
@param transform Transform vector for the new knot. (Pos_X Pos_Y Pos_Z Rot_X Rot_Y Rot_Z Angle)
@param speed Speed setting for this knot.
@param type Knot type (Normal, Position Only, Kink).
@param path Path type (Linear, Spline).
@tsexample
// Transform vector for new knot. (Pos_X,Pos_Y,Pos_Z,Rot_X,Rot_Y,Rot_Z,Angle)
%transform = "15.0 5.0 5.0 1.4 1.0 0.2 1.0"

// Speed setting for knot.
%speed = "1.0";

// Knot type. (Normal, Position Only, Kink)
%type = "Normal";

// Path Type. (Linear, Spline)
%path = "Linear";

// Inform the path camera to add a new knot to the front of its path
%pathCamera.pushFront(%transform, %speed, %type, %path);
@endtsexample</desc>
</method>
<method>
<name>reset</name>
<args>( float speed=1.0f )</args>
<desc>Reset this path camera to the start of its path, and apply a new movement speed.
@param speed Speed for the camera to move along its path after being reset.
@tsexample
//Determine the new movement speed of this camera. If not set, the speed will default to 1.0.
%speed = "0.50";

// Inform the path camera to jump to the start of its path at the new speed value.
%pathCamera.reset(%speed);</desc>
</method>
<method>
<name>setPosition</name>
<args>( float position=0.0f )</args>
<desc>Set the current position of the camera along the path.
@param position Position along the path, from 0.0 - 1.0, to place the camera.
@tsexample
// Set the camera on a position along its path from 0.0 - 1.0.
%position = "0.35";

// Pop the pathCamera to its new position along the path.
%pathCamera.setPosition(%position);
@endtsexample</desc>
</method>
<method>
<name>setState</name>
<args>( string newState="forward" )</args>
<desc>Set the movement state for this path camera.
@param newState New movement state type for this camera. Forward, Backward or Stop.
@tsexample
// Set the state type (forward, backward, stop).
%state = "forward";

// Inform the pathCamera to change its movement state to the defined value.
%pathCamera.setState(%state);
@endtsexample</desc>
</method>
<method>
<name>setTarget</name>
<args>( float position=1.0f )</args>
<desc>Set the movement target for this camera along its path.
@param position Position target, between 0.0 and 1.0, for the camera to move to along its path.
@tsexample
// Set the position target, between 0.0 and 1.0, for this camera to move to.
%position = "0.50";

// Inform the pathCamera of the new target position it will move to.
%pathCamera.setTarget(%position);
@endtsexample</desc>
</method>
<field>
<name>onNode( string node )</name>
<desc>Informs the script level that this path camera has arrived at a specific node in its path.
@param Node Unique ID assigned to this node.
@see PathCameraData</desc>
</field>
</class>
<class>
<name>PathCameraClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PathCameraData</name>
<base>ShapeBaseData</base>
</class>
<class>
<name>PathCameraDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PathClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PathedInterior</name>
<base>GameBase</base>
<method>
<name>setPathPosition</name>
</method>
<method>
<name>setTargetPosition</name>
</method>
<field>
<name>basePosition</name>
<desc>MatrixPosition basePosition</desc>
</field>
<field>
<name>baseRotation</name>
<desc>MatrixRotation baseRotation</desc>
</field>
<field>
<name>baseScale</name>
<desc>Point3F baseScale</desc>
</field>
<field>
<name>interiorIndex</name>
<desc>int interiorIndex</desc>
</field>
<field>
<name>interiorResource</name>
<desc>filename interiorResource</desc>
</field>
</class>
<class>
<name>PathedInteriorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PathedInteriorData</name>
<base>GameBaseData</base>
<field>
<name>StartSound</name>
<desc>SFXProfile StartSound</desc>
</field>
<field>
<name>StopSound</name>
<desc>SFXProfile StopSound</desc>
</field>
<field>
<name>SustainSound</name>
<desc>SFXProfile SustainSound</desc>
</field>
</class>
<class>
<name>PathedInteriorDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PathManagerEvent</name>
</class>
<class>
<name>PathManagerEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PersistenceManager</name>
<base>SimObject</base>
<method>
<name>clearAll</name>
<args>()</args>
<desc>Clears all the tracked objects without saving them.</desc>
</method>
<method>
<name>deleteObjectsFromFile</name>
<args>( fileName )</args>
<desc>Delete all of the objects that are created from the given file.</desc>
</method>
<method>
<name>getDirtyObject</name>
<args>( index )</args>
<desc>Returns the ith dirty object.</desc>
</method>
<method>
<name>getDirtyObjectCount</name>
<args>()</args>
<desc>Returns the number of dirty objects.</desc>
</method>
<method>
<name>hasDirty</name>
<args>()</args>
<desc>Returns true if the manager has dirty objects to save.</desc>
</method>
<method>
<name>isDirty</name>
<args>(SimObject object)</args>
<desc>Returns true if the SimObject is on the dirty list.</desc>
</method>
<method>
<name>listDirty</name>
<args>()</args>
<desc>Prints the dirty list to the console.</desc>
</method>
<method>
<name>removeDirty</name>
<args>(SimObject object)</args>
<desc>Remove a SimObject from the dirty list.</desc>
</method>
<method>
<name>removeField</name>
<args>(SimObject object, string fieldName)</args>
<desc>Remove a specific field from an object declaration.</desc>
</method>
<method>
<name>removeObjectFromFile</name>
<args>(SimObject object, [filename])</args>
<desc>Remove an existing SimObject from a file (can optionally specify a different file than                the one it was created in.</desc>
</method>
<method>
<name>saveDirty</name>
<args>()</args>
<desc>Saves all of the SimObject's on the dirty list to their respective files.</desc>
</method>
<method>
<name>saveDirtyObject</name>
<args>(SimObject object)</args>
<desc>Save a dirty SimObject to it's file.</desc>
</method>
<method>
<name>setDirty</name>
<args>(SimObject object, [filename])</args>
<desc>Mark an existing SimObject as dirty (will be written out when saveDirty() is called).</desc>
</method>
</class>
<class>
<name>PersistenceManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PfxVis</name>
<method>
<name>clear</name>
<args>()</args>
<desc>@hide</desc>
</method>
<method>
<name>hide</name>
<args>()</args>
<desc>@hide</desc>
</method>
<method>
<name>onWindowClosed</name>
<args>( GuiWindowCtrl )</args>
<desc>@hide</desc>
</method>
<method>
<name>open</name>
<args>( PostEffect, [bool clear = false] )</args>
<desc>@hide</desc>
</method>
<method>
<name>show</name>
<args>()</args>
<desc>@hide</desc>
</method>
</class>
<class>
<name>physGroundSequenceData</name>
<base>GameBaseData</base>
<field>
<name>DeltaVector</name>
<desc>Point3F DeltaVector</desc>
</field>
<field>
<name>FlexBodyData</name>
<desc>fxFlexBodyData FlexBodyData</desc>
</field>
<field>
<name>GroundNode1</name>
<desc>int GroundNode1</desc>
</field>
<field>
<name>GroundNode2</name>
<desc>int GroundNode2</desc>
</field>
<field>
<name>GroundNode3</name>
<desc>int GroundNode3</desc>
</field>
<field>
<name>GroundNode4</name>
<desc>int GroundNode4</desc>
</field>
<field>
<name>GroundNode5</name>
<desc>int GroundNode5</desc>
</field>
<field>
<name>GroundNode6</name>
<desc>int GroundNode6</desc>
</field>
<field>
<name>GroundNode7</name>
<desc>int GroundNode7</desc>
</field>
<field>
<name>GroundNode8</name>
<desc>int GroundNode8</desc>
</field>
<field>
<name>SequenceName</name>
<desc>string SequenceName</desc>
</field>
<field>
<name>SequenceNum</name>
<desc>int SequenceNum</desc>
</field>
<field>
<name>Time1</name>
<desc>float Time1</desc>
</field>
<field>
<name>Time2</name>
<desc>float Time2</desc>
</field>
<field>
<name>Time3</name>
<desc>float Time3</desc>
</field>
<field>
<name>Time4</name>
<desc>float Time4</desc>
</field>
<field>
<name>Time5</name>
<desc>float Time5</desc>
</field>
<field>
<name>Time6</name>
<desc>float Time6</desc>
</field>
<field>
<name>Time7</name>
<desc>float Time7</desc>
</field>
<field>
<name>Time8</name>
<desc>float Time8</desc>
</field>
<field>
<name>TimeScale</name>
<desc>float TimeScale</desc>
</field>
</class>
<class>
<name>physGroundSequenceDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PhysicalZone</name>
<base>SceneObject</base>
<method>
<name>activate</name>
<args>()</args>
<desc>Activate the physical zone's effects.
@tsexample
// Activate effects for a specific physical zone.
%thisPhysicalZone.activate();
@endtsexample
@ingroup Datablocks</desc>
</method>
<method>
<name>deactivate</name>
<args>()</args>
<desc>Deactivate the physical zone's effects.
@tsexample
// Deactivate effects for a specific physical zone.
%thisPhysicalZone.deactivate();
@endtsexample
@ingroup Datablocks</desc>
</method>
<field>
<name>appliedForce</name>
<desc>Three-element floating point value representing forces in three axes to apply to objects entering PhysicalZone.</desc>
</field>
<field>
<name>gravityMod</name>
<desc>Gravity in PhysicalZone. Multiplies against standard gravity.</desc>
</field>
<field>
<name>polyhedron</name>
<desc>The polyhedron type is really a quadrilateral and consists of a cornerpoint followed by three vectors representing the edges extending from the corner.</desc>
</field>
<field>
<name>velocityMod</name>
<desc>Multiply velocity of objects entering zone by this value every tick.</desc>
</field>
</class>
<class>
<name>PhysicalZoneClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PhysicsDebris</name>
<base>GameBase</base>
</class>
<class>
<name>PhysicsDebrisClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PhysicsDebrisData</name>
<base>GameBaseData</base>
<method>
<name>preload</name>
</method>
<field>
<name>angularDamping</name>
<desc>Larger values cause rotational velocity to decay over time more quickly.</desc>
</field>
<field>
<name>angularSleepThreshold</name>
<desc>Angular velocity threshold below which the shape may be put to sleep to save simulation time.</desc>
</field>
<field>
<name>buoyancyDensity</name>
<desc>The density of this shape for purposes of calculating buoyancy forces. The result of a particular value is relative to the density of the WaterObject it is within.</desc>
</field>
<field>
<name>castShadows</name>
<desc>Enable/Disable rendering into shadows.</desc>
</field>
<field>
<name>friction</name>
<desc>Friction of each physical body, slowing motion when in contact with a surface.</desc>
</field>
<field>
<name>Lifetime</name>
<desc>Base time in seconds that debris persists after time of creation.</desc>
</field>
<field>
<name>lifetimeVariance</name>
<desc>Range of variation randomly applied to lifetime when debris is created.</desc>
</field>
<field>
<name>linearDamping</name>
<desc>Larger values cause linear velocity to decay over time more quickly</desc>
</field>
<field>
<name>linearSleepThreshold</name>
<desc>Linear velocity threshold below which the shape may be put to sleep to save simulation time.</desc>
</field>
<field>
<name>mass</name>
<desc>Mass of each physical body.</desc>
</field>
<field>
<name>Restitution</name>
<desc>Bounciness of each physical body in response to collisions.  Normal range is zero to one.</desc>
</field>
<field>
<name>shapeFile</name>
<desc>Path to the shape file.</desc>
</field>
<field>
<name>StaticFriction</name>
<desc>Friction of each physical body, resisting motion when starting at rest.</desc>
</field>
<field>
<name>waterDampingScale</name>
<desc>While the shape is in water linear and angular dampening will be scaled by this value. It is expected that this value will usually be greater than one.</desc>
</field>
</class>
<class>
<name>PhysicsDebrisDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PhysicsForce</name>
<base>SceneObject</base>
<method>
<name>attach</name>
<args>( Point3F start, Point3F direction, float maxDist )</args>
<desc>Performs a physics ray cast and attracts the hit dynamic physics body to the force position.
@ingroup Physics</desc>
</method>
<method>
<name>detach</name>
<args>( Point3F force=Point3F::Zero )</args>
<desc>Releases the attached physics body with an optional push force.
@ingroup Physics</desc>
</method>
<method>
<name>isAttached</name>
<args>()</args>
<desc>Returns true if there is a physics body attached.
@ingroup Physics</desc>
</method>
</class>
<class>
<name>PhysicsForceClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PhysicsShape</name>
<base>GameBase</base>
<method>
<name>destroy</name>
<args>()</args>
<desc>Disables rendering and physical simulation of the shape and spawns the explosion, debri, and destroyedShape if any are specified. Note that this does not actually delete the PhysicsShape.</desc>
</method>
<method>
<name>isDestroyed</name>
<args>()</args>
<desc>Returns true if the shape is currently destroyed.</desc>
</method>
<method>
<name>restore</name>
<args>()</args>
<desc>Restore to un-destroyed state: enables rendering and physical simulation.</desc>
</method>
<field>
<name>playAmbient</name>
<desc>Enables automatic playing of the animation named "ambient" (if it exists) when the PhysicsShape is loaded.</desc>
</field>
</class>
<class>
<name>PhysicsShapeClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PhysicsShapeData</name>
<base>GameBaseData</base>
<field>
<name>angularDamping</name>
<desc>Larger values cause rotational velocity to decay over time more quickly.</desc>
</field>
<field>
<name>angularSleepThreshold</name>
<desc>Angular velocity threshold below which the shape may be put to sleep to save simulation time.</desc>
</field>
<field>
<name>buoyancyDensity</name>
<desc>The density of this shape for purposes of calculating buoyancy forces. The result of a particular value is relative to the density of the WaterObject it is within.</desc>
</field>
<field>
<name>Debris</name>
<desc>Name of a PhysicsDebrisData to spawn when destroyed (optional).</desc>
</field>
<field>
<name>destroyedShape</name>
<desc>Name of a PhysicsShapeData to spawn when destroyed (optional).</desc>
</field>
<field>
<name>Explosion</name>
<desc>Name of a ExplosionData to spawn when destroyed (optional).</desc>
</field>
<field>
<name>friction</name>
<desc>Friction of the shape slowing motion when in contact with a surface.</desc>
</field>
<field>
<name>linearDamping</name>
<desc>Larger values cause linear velocity to decay over time more quickly</desc>
</field>
<field>
<name>linearSleepThreshold</name>
<desc>Linear velocity threshold below which the shape may be put to sleep to save simulation time.</desc>
</field>
<field>
<name>mass</name>
<desc>Mass of the shape. Set mass to zero to create as a kinematic.</desc>
</field>
<field>
<name>Restitution</name>
<desc>Bounciness of the shape in response to collisions.  Normal range is zero to one.</desc>
</field>
<field>
<name>shapeName</name>
<desc>Path to the shape file.</desc>
</field>
<field>
<name>simType</name>
<desc>Controls whether this shape is simulated on the server, client, or both physics simulations.</desc>
</field>
<field>
<name>StaticFriction</name>
<desc>Friction of the shape resisting motion when starting at rest.</desc>
</field>
<field>
<name>waterDampingScale</name>
<desc>While the shape is in water linear and angular dampening will be scaled by this value. It is expected that this value will usually be greater than one.</desc>
</field>
</class>
<class>
<name>PhysicsShapeDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>physInteriorInstance</name>
<base>InteriorInstance</base>
</class>
<class>
<name>physInteriorInstanceClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>physTerrainBlock</name>
<base>TerrainBlock</base>
<field>
<name>physExtent</name>
<desc>Point2I physExtent</desc>
</field>
<field>
<name>physStart</name>
<desc>Point2I physStart</desc>
</field>
</class>
<class>
<name>physTerrainBlockClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Player</name>
<base>fxFlexBody</base>
<method>
<name>checkDismountPoint</name>
<args>( Point3F oldPos, Point3F pos )</args>
<desc>Check if it is safe (space is free) to dismount at this position.
@param oldPos the player's current position
@param pos the dismount position to check
@return true if the dismount position is clear, false if not</desc>
</method>
<method>
<name>clearControlObject</name>
<args>()</args>
<desc>Release the object we are controlling.</desc>
</method>
<method>
<name>getControlObject</name>
<args>()</args>
<desc>Get the current object we are controlling.
@return ID of the ShapeBase object we control, or 0 if not controlling an object.</desc>
</method>
<method>
<name>getDamageLocation</name>
<args>( Point3F pos )</args>
<desc>Get the named damage location and modifier for a given position.
The player object can differentiate 'hit' locations based on a pre-defined set of datablock settings. You may modify these settings, to vary the percentage of area given over to any body region.
&lt;img src="images/player_damageloc.png"&gt;
@note Input positions do not need to be on or even near the player. The engine will calculate which body location and modifier best fit any position relative to the player.
@note This method will not return an accurate location when the player is prone.
@param pos a position for which to retrieve a body region on this player.
@return a string containing two words (space separated strings), where the first is a location and the second is a modifier.

Posible locations:&lt;ul&gt;&lt;li&gt;legs&lt;/li&gt;&lt;li&gt;torso&lt;/li&gt;&lt;li&gt;head&lt;/li&gt;&lt;/ul&gt;
Head modifiers:&lt;ul&gt;&lt;li&gt;left_back&lt;/li&gt;&lt;li&gt;middle_back&lt;/li&gt;&lt;li&gt;right_back&lt;/li&gt;&lt;li&gt;left_middle&lt;/li&gt;&lt;li&gt;middle_middle&lt;/li&gt;&lt;li&gt;right_middle&lt;/li&gt;&lt;li&gt;left_front&lt;/li&gt;&lt;li&gt;middle_front&lt;/li&gt;&lt;li&gt;right_front&lt;/li&gt;&lt;/ul&gt;
Legs/Torso modifiers:&lt;ul&gt;&lt;li&gt;front_left&lt;/li&gt;&lt;li&gt;front_right&lt;/li&gt;&lt;li&gt;back_left&lt;/li&gt;&lt;li&gt;back_right&lt;/li&gt;&lt;/ul&gt;
@see PlayerData::boxHeadPercentage
@see PlayerData::boxTorsoPercentage</desc>
</method>
<method>
<name>getState</name>
<args>()</args>
<desc>Get the name of the current state.
@return the current state; one of: "Move", "Recover", "Mounted", "Dead"</desc>
</method>
<method>
<name>setActionThread</name>
<args>( string name, bool hold=false, bool fsp=true )</args>
<desc>Set the main action sequence to play for this player.
@param name name of the action sequence to set
@param hold false to get a callback at the end of the sequence (animationDone) or true to prevent the callback
@param fsp true if first person, false otherwise
@return true if succesful, false if failed</desc>
</method>
<method>
<name>setArmThread</name>
<args>( string name )</args>
<desc>Set the sequence that controls the player's arms (dynamically adjusted to match look direction).
@param name name of the sequence to play on the player's arms.
@param true if successful, false if failed.</desc>
</method>
<method>
<name>setControlObject</name>
<args>( ShapeBase obj )</args>
<desc>Set the object to be controlled by this player
@param ShapeBase object to control with this player
@return true if the object is valid, false if not</desc>
</method>
</class>
<class>
<name>PlayerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PlayerData</name>
<base>fxFlexBodyData</base>
<field>
<name>airControl</name>
<desc>Amount of movement control the player has when in the air.</desc>
</field>
<field>
<name>animationDone( Player obj )</name>
<desc>Called on the server when a scripted animation completes.
@param obj the Player object</desc>
</field>
<field>
<name>boundingBox</name>
<desc>Size of the bounding box used by the player for collision.
Dimensions are given as "width depth height".</desc>
</field>
<field>
<name>boxHeadBackPercentage</name>
<desc>Percentage of the player's bounding box depth that represents the back side of the head.
Used when computing the damage location.
@see Player::getDamageLocation</desc>
</field>
<field>
<name>boxHeadFrontPercentage</name>
<desc>Percentage of the player's bounding box depth that represents the front side of the head.
Used when computing the damage location.
@see Player::getDamageLocation</desc>
</field>
<field>
<name>boxHeadLeftPercentage</name>
<desc>Percentage of the player's bounding box width that represents the left side of the head.
Used when computing the damage location.
@see Player::getDamageLocation</desc>
</field>
<field>
<name>boxHeadPercentage</name>
<desc>Percentage of the player's bounding box height that represents the head.
Used when computing the damage location.
@see Player::getDamageLocation</desc>
</field>
<field>
<name>boxHeadRightPercentage</name>
<desc>Percentage of the player's bounding box width that represents the right side of the head.
Used when computing the damage location.
@see Player::getDamageLocation</desc>
</field>
<field>
<name>boxTorsoPercentage</name>
<desc>Percentage of the player's bounding box height that represents the torso.
Used when computing the damage location.
@see Player::getDamageLocation</desc>
</field>
<field>
<name>bubbleEmitTime</name>
<desc>Time in seconds to generate bubble particles after entering the water.</desc>
</field>
<field>
<name>crouchBoundingBox</name>
<desc>Collision bounding box used when the player is crouching.
@see boundingBox</desc>
</field>
<field>
<name>crouchForce</name>
<desc>Force used to accelerate the player when crouching.</desc>
</field>
<field>
<name>DecalData</name>
<desc>Decal to place on the ground for player footsteps.</desc>
</field>
<field>
<name>decalOffset</name>
<desc>Distance from the center of the model to the right foot (used to place footstep decals either side of the player center.</desc>
</field>
<field>
<name>doDismount( Player obj )</name>
<desc>Called to dismount the player from a vehicle.
@param obj the Player object</desc>
</field>
<field>
<name>dustEmitter</name>
<desc>Emitter used to generate dust particles.
Currently unused.</desc>
</field>
<field>
<name>exitingWater</name>
<desc>Sound to play when exiting the water with velocity &gt;= exitSplashSoundVelocity.</desc>
</field>
<field>
<name>exitSplashSoundVelocity</name>
<desc>Minimum velocity when leaving the water for the exitingWater sound to play.</desc>
</field>
<field>
<name>FootBubblesSound</name>
<desc>Sound to play when walking in water and coverage equals 1.0 (fully underwater).</desc>
</field>
<field>
<name>FootHardSound</name>
<desc>Sound to play when walking on a surface with Material footstepSoundId 1.</desc>
</field>
<field>
<name>FootMetalSound</name>
<desc>Sound to play when walking on a surface with Material footstepSoundId 2.</desc>
</field>
<field>
<name>footPuffEmitter</name>
<desc>Emitter used to generate footpuffs (particles created as the player walks along the ground).</desc>
</field>
<field>
<name>footPuffNumParts</name>
<desc>Number of footpuff particles to generate each step.</desc>
</field>
<field>
<name>footPuffRadius</name>
<desc>Particle creation radius for footpuff particles.</desc>
</field>
<field>
<name>FootShallowSound</name>
<desc>Sound to play when walking in water and coverage is less than footSplashHeight.</desc>
</field>
<field>
<name>FootSnowSound</name>
<desc>Sound to play when walking on a surface with Material footstepSoundId 3.</desc>
</field>
<field>
<name>FootSoftSound</name>
<desc>Sound to play when walking on a surface with Material footstepSoundId 0.</desc>
</field>
<field>
<name>footstepSplashHeight</name>
<desc>Water coverage level to choose between FootShallowSound and FootWadingSound.</desc>
</field>
<field>
<name>FootUnderwaterSound</name>
<desc>Sound to play when walking in water and coverage equals 1.0 (fully underwater).</desc>
</field>
<field>
<name>FootWadingSound</name>
<desc>Sound to play when walking in water and coverage is less than 1, but &gt; footSplashHeight.</desc>
</field>
<field>
<name>groundImpactMinSpeed</name>
<desc>Minimum falling impact speed to apply damage and initiate the camera shaking effect.</desc>
</field>
<field>
<name>groundImpactShakeAmp</name>
<desc>Amplitude of the camera shake effect after falling.</desc>
</field>
<field>
<name>groundImpactShakeDuration</name>
<desc>Duration (in seconds) of the camera shake effect after falling.</desc>
</field>
<field>
<name>groundImpactShakeFalloff</name>
<desc>Falloff factor of the camera shake effect after falling.</desc>
</field>
<field>
<name>groundImpactShakeFreq</name>
<desc>Frequency of the camera shake effect after falling.</desc>
</field>
<field>
<name>hardSplashSoundVelocity</name>
<desc>Minimum velocity when entering the water for the impactWaterHard sound to play.
@see impactWaterHard</desc>
</field>
<field>
<name>horizMaxSpeed</name>
<desc>Maximum horizontal speed.
@note This limit is only enforced if the player's horizontal speed exceeds horizResistSpeed.</desc>
</field>
<field>
<name>horizResistFactor</name>
<desc>Factor of resistence once horizResistSpeed has been reached.</desc>
</field>
<field>
<name>horizResistSpeed</name>
<desc>Horizontal speed at which resistence will take place.</desc>
</field>
<field>
<name>impactHardSound</name>
<desc>Sound to play after falling on a surface with Material footstepSoundId 1.</desc>
</field>
<field>
<name>impactMetalSound</name>
<desc>Sound to play after falling on a surface with Material footstepSoundId 2.</desc>
</field>
<field>
<name>impactSnowSound</name>
<desc>Sound to play after falling on a surface with Material footstepSoundId 3.</desc>
</field>
<field>
<name>impactSoftSound</name>
<desc>Sound to play after falling on a surface with Material footstepSoundId 0.</desc>
</field>
<field>
<name>impactWaterEasy</name>
<desc>Sound to play when entering the water with velocity &lt; mediumSplashSoundVelocity.</desc>
</field>
<field>
<name>impactWaterHard</name>
<desc>Sound to play when entering the water with velocity &gt;= hardSplashSoundVelocity.</desc>
</field>
<field>
<name>impactWaterMedium</name>
<desc>Sound to play when entering the water with velocity &gt;= mediumSplashSoundVelocity and &lt; hardSplashSoundVelocity.</desc>
</field>
<field>
<name>jetJumpEnergyDrain</name>
<desc>Energy level drained each time the player jet jumps.</desc>
</field>
<field>
<name>jetJumpForce</name>
<desc>Force used to accelerate the player when a jet jump is initiated.</desc>
</field>
<field>
<name>jetJumpSurfaceAngle</name>
<desc>Angle from vertical in degrees where the player can jet jump.</desc>
</field>
<field>
<name>jetMaxJumpSpeed</name>
<desc>Maximum vertical speed before the player can no longer jet jump.</desc>
</field>
<field>
<name>jetMinJumpEnergy</name>
<desc>Minimum energy level required to jet jump.</desc>
</field>
<field>
<name>jetMinJumpSpeed</name>
<desc>Minimum speed needed to jet jump.</desc>
</field>
<field>
<name>jumpDelay</name>
<desc>Delay time in ticks between jumps.</desc>
</field>
<field>
<name>jumpEnergyDrain</name>
<desc>Energy level drained each time the player jumps.</desc>
</field>
<field>
<name>jumpForce</name>
<desc>Force used to accelerate the player when a jump is initiated.</desc>
</field>
<field>
<name>jumpSurfaceAngle</name>
<desc>Angle from vertical in degrees where the player can jump.</desc>
</field>
<field>
<name>jumpTowardsNormal</name>
<desc>Controls the direction of the jump impulse.
When false, jumps are always in the vertical (+Z) direction. When true jumps are in the direction of the ground normal.</desc>
</field>
<field>
<name>maxBackwardSpeed</name>
<desc>Maximum backward speed when running.</desc>
</field>
<field>
<name>maxCrouchBackwardSpeed</name>
<desc>Maximum backward speed when crouching.</desc>
</field>
<field>
<name>maxCrouchForwardSpeed</name>
<desc>Maximum forward speed when crouching.</desc>
</field>
<field>
<name>maxCrouchSideSpeed</name>
<desc>Maximum sideways speed when crouching.</desc>
</field>
<field>
<name>maxForwardSpeed</name>
<desc>Maximum forward speed when running.</desc>
</field>
<field>
<name>maxFreelookAngle</name>
<desc>Minimum (-ve) and maximum (+ve) left/right angle (in radians) the player can look in freelook mode.</desc>
</field>
<field>
<name>maxJumpSpeed</name>
<desc>Maximum vertical speed before the player can no longer jump.</desc>
</field>
<field>
<name>maxLookAngle</name>
<desc>Highest angle (in radians) the player can look.</desc>
</field>
<field>
<name>maxProneBackwardSpeed</name>
<desc>Maximum backward speed when prone (laying down).</desc>
</field>
<field>
<name>maxProneForwardSpeed</name>
<desc>Maximum forward speed when prone (laying down).</desc>
</field>
<field>
<name>maxProneSideSpeed</name>
<desc>Maximum sideways speed when prone (laying down).</desc>
</field>
<field>
<name>maxSideSpeed</name>
<desc>Maximum sideways speed when running.</desc>
</field>
<field>
<name>maxStepHeight</name>
<desc>Maximum height the player can step up.
The player will automatically step onto changes in ground height less than maxStepHeight. The player will collide with ground height changes greater than this.</desc>
</field>
<field>
<name>maxTimeScale</name>
<desc>Maximum time scale for action animations.
Action animations are automatically scaled to match the ground velocity; this field limits the maximum time scale.</desc>
</field>
<field>
<name>maxUnderwaterBackwardSpeed</name>
<desc>Maximum backward speed when underwater.</desc>
</field>
<field>
<name>maxUnderwaterForwardSpeed</name>
<desc>Maximum forward speed when underwater.</desc>
</field>
<field>
<name>maxUnderwaterSideSpeed</name>
<desc>Maximum sideways speed when underwater.</desc>
</field>
<field>
<name>mediumSplashSoundVelocity</name>
<desc>Minimum velocity when entering the water for the impactWaterMedium sound to play.
@see impactWaterMedium</desc>
</field>
<field>
<name>minImpactSpeed</name>
<desc>Minimum impact speed to apply falling damage.
This field also sets the minimum speed for the onImpact callback to be invoked.</desc>
</field>
<field>
<name>minJumpEnergy</name>
<desc>Minimum energy level required to jump.</desc>
</field>
<field>
<name>minJumpSpeed</name>
<desc>Minimum speed needed to jump.</desc>
</field>
<field>
<name>minLookAngle</name>
<desc>Lowest angle (in radians) the player can look.</desc>
</field>
<field>
<name>minRunEnergy</name>
<desc>Minimum energy level required to run or swim.</desc>
</field>
<field>
<name>movingBubblesSound</name>
<desc>Sound to play when in water and coverage equals 1.0 (fully underwater).
Note that unlike FootUnderwaterSound, this sound plays even if the player is not moving around in the water.</desc>
</field>
<field>
<name>onEnterLiquid( Player obj, float coverage, string type )</name>
<desc>Called when the player enters liquid.
@param obj the Player object
@param coverage percentage of the player's bounding box covered by the liquid
@param type type of liquid the player has entered</desc>
</field>
<field>
<name>onEnterMissionArea( Player obj )</name>
<desc>Called when the player enters the mission area.
@param obj the Player object</desc>
</field>
<field>
<name>onLeaveLiquid( Player obj, string type )</name>
<desc>Called when the player leaves liquid.
@param obj the Player object
@param type type of liquid the player has left</desc>
</field>
<field>
<name>onLeaveMissionArea( Player obj )</name>
<desc>Called when the player leaves the mission area.
@param obj the Player object</desc>
</field>
<field>
<name>onStartSwim( Player obj )</name>
<desc>Called when the player starts swimming.
@param obj the Player object</desc>
</field>
<field>
<name>onStopSwim( Player obj )</name>
<desc>Called when the player stops swimming.
@param obj the Player object</desc>
</field>
<field>
<name>physicsPlayerType</name>
<desc>Specifies the type of physics used by the player.</desc>
</field>
<field>
<name>pickupRadius</name>
<desc>Radius around the player to collide with Items in the scene (on server).</desc>
</field>
<field>
<name>proneBoundingBox</name>
<desc>Collision bounding box used when the player is prone (laying down).
@see boundingBox</desc>
</field>
<field>
<name>proneForce</name>
<desc>Force used to accelerate the player when prone (laying down).</desc>
</field>
<field>
<name>recoverDelay</name>
<desc>Number of ticks for the player to recover from falling.</desc>
</field>
<field>
<name>recoverRunForceScale</name>
<desc>Scale factor applied to runForce while in the recover state.
This can be used to temporarily slow the player's movement after a fall.</desc>
</field>
<field>
<name>renderFirstPerson</name>
<desc>Flag controlling whether to render the player shape in first person view.</desc>
</field>
<field>
<name>runEnergyDrain</name>
<desc>Energy value drained each tick that the player is moving.
The player will not be able to move when his energy falls below minRunEnergy.</desc>
</field>
<field>
<name>runForce</name>
<desc>Force used to accelerate the player when running.</desc>
</field>
<field>
<name>runSurfaceAngle</name>
<desc>Maximum angle from vertical in degrees the player can run up.</desc>
</field>
<field>
<name>Splash</name>
<desc>SplashData datablock used to create splashes when the player moves through water.</desc>
</field>
<field>
<name>splashAngle</name>
<desc>Maximum angle (in degrees) from pure vertical movement in water to generate splashes.</desc>
</field>
<field>
<name>splashEmitter</name>
<desc>Emitters used to generate splash particles.</desc>
</field>
<field>
<name>splashFreqMod</name>
<desc>Multipled by speed to determine the number of splash particles to generate.</desc>
</field>
<field>
<name>splashVelEpsilon</name>
<desc>Minimum speed to generate splash particles.</desc>
</field>
<field>
<name>splashVelocity</name>
<desc>Minimum velocity when moving through water to generate splashes.</desc>
</field>
<field>
<name>swimBoundingBox</name>
<desc>Collision bounding box used when the player is swimming.
@see boundingBox</desc>
</field>
<field>
<name>swimForce</name>
<desc>Force used to accelerate the player when swimming.</desc>
</field>
<field>
<name>upMaxSpeed</name>
<desc>Maximum upwards speed.
@note This limit is only enforced if the player's upward speed exceeds upResistSpeed.</desc>
</field>
<field>
<name>upResistFactor</name>
<desc>Factor of resistence once upResistSpeed has been reached.</desc>
</field>
<field>
<name>upResistSpeed</name>
<desc>Upwards speed at which resistence will take place.</desc>
</field>
<field>
<name>waterBreathSound</name>
<desc>Sound to play when in water and coverage equals 1.0 (fully underwater).
Note that unlike FootUnderwaterSound, this sound plays even if the player is not moving around in the water.</desc>
</field>
</class>
<class>
<name>PlayerDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PointLight</name>
<base>LightBase</base>
<field>
<name>radius</name>
<desc>Controls the falloff of the light emission</desc>
</field>
</class>
<class>
<name>PointLightClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PopupMenu</name>
<base>SimObject</base>
<method>
<name>attachToMenuBar</name>
<args>(GuiCanvas, pos, title)</args>
</method>
<method>
<name>checkItem</name>
<args>(pos, checked)</args>
</method>
<method>
<name>checkRadioItem</name>
<args>(firstPos, lastPos, checkPos)</args>
</method>
<method>
<name>enableItem</name>
<args>(pos, enabled)</args>
</method>
<method>
<name>getItemCount</name>
<args>()</args>
</method>
<method>
<name>insertItem</name>
<args>(pos[, title][, accelerator])</args>
</method>
<method>
<name>insertSubMenu</name>
<args>(pos, title, subMenu)</args>
</method>
<method>
<name>isItemChecked</name>
<args>(pos)</args>
</method>
<method>
<name>removeFromMenuBar</name>
<args>()</args>
</method>
<method>
<name>removeItem</name>
<args>(pos)</args>
</method>
<method>
<name>setItem</name>
<args>(pos, title[, accelerator])</args>
</method>
<method>
<name>showPopup</name>
<args>(Canvas,[x, y])</args>
</method>
<field>
<name>barTitle</name>
<desc>the title of this menu when attached to a menu bar</desc>
</field>
<field>
<name>isPopup</name>
<desc>true if this is a pop-up/context menu. defaults to false.</desc>
</field>
</class>
<class>
<name>PopupMenuClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Portal</name>
<base>Zone</base>
</class>
<class>
<name>PortalClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PostEffect</name>
<base>SimGroup</base>
<method>
<name>clearShaderMacros</name>
<args>()</args>
<desc>Remove all shader macros.</desc>
</method>
<method>
<name>disable</name>
<args>()</args>
<desc>Disables the effect.</desc>
</method>
<method>
<name>dumpShaderDisassembly</name>
<args>()</args>
<desc>Dumps this PostEffect shader's disassembly to a temporary text file.
@return Full path to the dumped file or an empty string if failed.</desc>
</method>
<method>
<name>enable</name>
<args>()</args>
<desc>Enables the effect.</desc>
</method>
<method>
<name>getAspectRatio</name>
<args>()</args>
<desc>@return Width over height of the backbuffer.</desc>
</method>
<method>
<name>isEnabled</name>
<args>()</args>
<desc>@return True if the effect is enabled.</desc>
</method>
<method>
<name>reload</name>
<args>()</args>
<desc>Reloads the effect shader and textures.</desc>
</method>
<method>
<name>removeShaderMacro</name>
<args>( string key )</args>
<desc>Remove a shader macro. This will usually be called within the preProcess callback.
@param key Macro to remove.</desc>
</method>
<method>
<name>setShaderConst</name>
<args>( string name, string value )</args>
<desc>Sets the value of a uniform defined in the shader. This will usually be called within the setShaderConsts callback. Array type constants are not supported.
@param name Name of the constanst, prefixed with '$'.
@param value Value to set, space seperate values with more than one element.
@tsexample
function MyPfx::setShaderConsts( %this )
{
// example float4 uniform
%this.setShaderConst( "$colorMod", "1.0 0.9 1.0 1.0" );
// example float1 uniform
%this.setShaderConst( "$strength", "3.0" );
// example integer uniform
%this.setShaderConst( "$loops", "5" );}
@endtsexample</desc>
</method>
<method>
<name>setShaderMacro</name>
<args>( string key, string value="" )</args>
<desc>Adds a macro to the effect's shader or sets an existing one's value. This will usually be called within the onAdd or preProcess callback.
@param key lval of the macro.@param value rval of the macro, or may be empty.@tsexample
function MyPfx::onAdd( %this )
{
%this.setShaderMacro( "NUM_SAMPLES", "10" );
%this.setShaderMacro( "HIGH_QUALITY_MODE" );

// In the shader looks like...
// #define NUM_SAMPLES 10
// #define HIGH_QUALITY_MODE
}
@endtsexample</desc>
</method>
<method>
<name>toggle</name>
<args>()</args>
<desc>Toggles the effect between enabled / disabled.
@return True if effect is enabled.</desc>
</method>
<field>
<name>allowReflectPass</name>
<desc>Is this effect processed during reflection render passes.</desc>
</field>
<field>
<name>isEnabled</name>
<desc>Is the effect on.</desc>
</field>
<field>
<name>onAdd()</name>
<desc>Called when this object is first created and registered.</desc>
</field>
<field>
<name>onDisabled()</name>
<desc>Called when this effect becomes disabled.</desc>
</field>
<field>
<name>oneFrameOnly</name>
<desc>Allows you to turn on a PostEffect for only a single frame.</desc>
</field>
<field>
<name>onEnabled()</name>
<desc>Called when this effect becomes enabled. If the user returns false from this callback the effect will not be enabled.
@return True to allow this effect to be enabled.</desc>
</field>
<field>
<name>onThisFrame</name>
<desc>Allows you to turn on a PostEffect for only a single frame.</desc>
</field>
<field>
<name>preProcess()</name>
<desc>Called when an effect is processed but before textures are bound. This allows the user to change texture related paramaters or macros at runtime.
@tsexample
function SSAOPostFx::preProcess( %this )
{
if ( $SSAOPostFx::quality !$= %this.quality )
{
%this.quality = mClamp( mRound( $SSAOPostFx::quality ), 0, 2 );

%this.setShaderMacro( "QUALITY", %this.quality );
}
%this.targetScale = $SSAOPostFx::targetScale;
}
@endtsexample
@see setShaderConst
@see setShaderMacro</desc>
</field>
<field>
<name>renderBin</name>
<desc>Name of a renderBin, used if renderTime is PFXBeforeBin or PFXAfterBin.</desc>
</field>
<field>
<name>renderPriority</name>
<desc>PostEffects are processed in DESCENDING order of renderPriority if more than one has the same renderBin/Time.</desc>
</field>
<field>
<name>renderTime</name>
<desc>When to process this effect during the frame.</desc>
</field>
<field>
<name>setShaderConsts()</name>
<desc>Called immediate before processing this effect. This is the user's chance to set the value of shader uniforms (constants).
@see setShaderConst</desc>
</field>
<field>
<name>shader</name>
<desc>Name of a GFXShaderData for this effect.</desc>
</field>
<field>
<name>skip</name>
<desc>Skip processing of this PostEffect and its children even if its parent is enabled. Parent and sibling PostEffects in the chain are still processed.</desc>
</field>
<field>
<name>stateBlock</name>
<desc>Name of a GFXStateBlockData for this effect.</desc>
</field>
<field>
<name>target</name>
<desc>String identifier of this effect's target texture.
@see PFXTextureIdentifiers</desc>
</field>
<field>
<name>targetClear</name>
<desc>Describes when the target texture should be cleared.</desc>
</field>
<field>
<name>targetClearColor</name>
<desc>Color to which the target texture is cleared before rendering.</desc>
</field>
<field>
<name>targetFormat</name>
<desc>Format of the target texture, not applicable if writing to the backbuffer.</desc>
</field>
<field>
<name>targetScale</name>
<desc>If targetSize is zero this is used to set a relative size from the current target.</desc>
</field>
<field>
<name>targetSize</name>
<desc>If non-zero this is used as the absolute target size.</desc>
</field>
<field>
<name>texture</name>
<desc>Input textures to this effect ( samplers ).
@see PFXTextureIdentifiers</desc>
</field>
</class>
<class>
<name>PostEffectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Precipitation</name>
<base>GameBase</base>
<method>
<name>modifyStorm</name>
<args>( float percentage=1.0f, float length=5.0f )</args>
<desc>Adjusts the droplet count and overall length of the Precipitation effect.
@tsexample
// The percentage, from 0.0f to 1.0f, of the drops to display at once.
%percentage = 0.5;

// The length of time for the Precipitation effect to last. Will be multiplied by 1000 to get the milliseconds.
%length = 5.0;

// Set the percentage and time by calling the method.
%Precipitation.modifyStorm(%percentage , %length);
@endtsexample</desc>
</method>
<method>
<name>setPercentage</name>
<args>( float percentage=1.0f )</args>
<desc>Sets how many drops are present at once.
@tsexample
// The percentage, from 0.0f to 1.0f, of the drops to display at once.
%percentage = 0.5f;

// Set the percentage by calling the method.
%Precipitation.setPercentage(%percentage);
@endtsexample</desc>
</method>
<method>
<name>setTurbulence</name>
<args>( float max=1.0f, float speed=5.0f, float seconds=5.0 )</args>
<desc>This is used to smoothly change the turbulence
over a desired time period. Setting ms to zero
will cause the change to be instantaneous. Setting
max zero will disable turbulence.
@tsexample
//Set the turbulence value. Set to 0 to disable turbulence.
%turbulence = 0.5;

// The speed of the turbulance effect.
%speed = 5.0;

// The length of time for the turbulence to last. Will be multiplied by 1000 to get the milliseconds.
%seconds = 5.0;

// Set the percentage and time by calling the method.
%Precipitation.setTurbulence(%turbulence , %speed , %seconds);
@endtsexample</desc>
</method>
<field>
<name>animateSplashes</name>
<desc>Check to enable splash animation on collision.</desc>
</field>
<field>
<name>boxHeight</name>
<desc>Height of precipitation box.</desc>
</field>
<field>
<name>boxWidth</name>
<desc>Width of precipitation box.</desc>
</field>
<field>
<name>doCollision</name>
<desc>Allow collision with world objects.</desc>
</field>
<field>
<name>dropAnimateMS</name>
<desc>If greater than zero, will animate the drops from the frames in the texture.</desc>
</field>
<field>
<name>dropSize</name>
<desc>Size of each drop of precipitation. This will scale the texture.</desc>
</field>
<field>
<name>fadeDist</name>
<desc>The distance at which fading of the drops begins.</desc>
</field>
<field>
<name>fadeDistEnd</name>
<desc>The distance at which fading of the particles ends.</desc>
</field>
<field>
<name>followCam</name>
<desc>Enables system to follow the camera or stay where it is placed.</desc>
</field>
<field>
<name>glowIntensity</name>
<desc>Set to 0 to disable the glow or or use it to control the intensity of each channel.</desc>
</field>
<field>
<name>hitPlayers</name>
<desc>Allow collision on player objects.</desc>
</field>
<field>
<name>hitVehicles</name>
<desc>Allow collision on vechiles.</desc>
</field>
<field>
<name>maxMass</name>
<desc>Maximum mass of a drop.</desc>
</field>
<field>
<name>maxSpeed</name>
<desc>Maximum speed that a drop will fall.</desc>
</field>
<field>
<name>maxTurbulence</name>
<desc>Radius at which precipitation drops spiral when turbulence is enabled.</desc>
</field>
<field>
<name>minMass</name>
<desc>Minimum mass of a drop.</desc>
</field>
<field>
<name>minSpeed</name>
<desc>Minimum speed that a drop will fall.</desc>
</field>
<field>
<name>numDrops</name>
<desc>Number of drops allowed to exists in the precipitation box at any one time.</desc>
</field>
<field>
<name>reflect</name>
<desc>This enables the precipitation to be rendered during reflection passes. This is expensive.</desc>
</field>
<field>
<name>rotateWithCamVel</name>
<desc>Enables drops to rotate to face camera.</desc>
</field>
<field>
<name>splashMS</name>
<desc>Life of splashes in millisecons.</desc>
</field>
<field>
<name>splashSize</name>
<desc>Size of each splash animation for when a drop collides.</desc>
</field>
<field>
<name>turbulenceSpeed</name>
<desc>Speed at which precipitation drops spiral when turbulence is enabled.</desc>
</field>
<field>
<name>useLighting</name>
<desc>Check to enable shading of the drops and splashes by the sun color.</desc>
</field>
<field>
<name>useTrueBillboards</name>
<desc>Check to make drops true (non axis-aligned) billboards.</desc>
</field>
<field>
<name>useTurbulence</name>
<desc>Check to enable turubulence. This causes precipitation drops to spiral while falling.</desc>
</field>
<field>
<name>useWind</name>
<desc>Check to have the Sky property windSpeed affect precipitation.</desc>
</field>
</class>
<class>
<name>PrecipitationClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>PrecipitationData</name>
<base>GameBaseData</base>
<field>
<name>dropShader</name>
<desc>The name of the shader used for raindrops.</desc>
</field>
<field>
<name>dropsPerSide</name>
<desc>How many drops are on a side of the raindrop texture.</desc>
</field>
<field>
<name>dropTexture</name>
<desc>Texture filename for drop particles.</desc>
</field>
<field>
<name>soundProfile</name>
<desc>SFXProfile effect to play.</desc>
</field>
<field>
<name>splashesPerSide</name>
<desc>How many splash are on a side of the splash texture.</desc>
</field>
<field>
<name>splashShader</name>
<desc>The name of the shader used for raindrops.</desc>
</field>
<field>
<name>splashTexture</name>
<desc>Texture filename for splash particles.</desc>
</field>
</class>
<class>
<name>PrecipitationDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Prefab</name>
<base>SceneObject</base>
<field>
<name>fileName</name>
<desc>(.prefab) File describing objects within this prefab.</desc>
</field>
<field>
<name>onLoad( SimGroup  children )</name>
<desc>Called when the prefab file is loaded and children objects are created.
@param children SimGroup containing all children objects.</desc>
</field>
</class>
<class>
<name>PrefabClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Projectile</name>
<base>GameBase</base>
<method>
<name>presimulate</name>
<args>( float seconds=1.0f )</args>
<desc>Updates velocity and position, and performs collision testing.
@param seconds Amount of time, in seconds, since the simulation began, to start the simulation at.
@tsexample
// Tell the projectile object to process a simulation event, and provide the amount of time
in seconds that has passed since the simulation began.
%seconds = 2000;
%projectile.presimulate(%seconds);
@endtsexample</desc>
</method>
<field>
<name>initialPosition</name>
<desc>Initial starting position for this projectile.</desc>
</field>
<field>
<name>InitialVelocity</name>
<desc>Initial starting velocity for this projectile.</desc>
</field>
<field>
<name>sourceObject</name>
<desc>The object that fires this projectile. If this projectile was fired by a WeaponImage, it will be the object that owns the WeaponImage, usually the player.</desc>
</field>
<field>
<name>sourceSlot</name>
<desc>Which weapon slot on the sourceObject that this projectile originates from.</desc>
</field>
</class>
<class>
<name>ProjectileClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ProjectileData</name>
<base>GameBaseData</base>
<field>
<name>armingDelay</name>
<desc>The time in milliseconds before the projectile is armed and will cause damage or explode on impact.</desc>
</field>
<field>
<name>bounceElasticity</name>
<desc>float bounceElasticity</desc>
</field>
<field>
<name>bounceFriction</name>
<desc>float bounceFriction</desc>
</field>
<field>
<name>decal</name>
<desc>DecalData decal</desc>
</field>
<field>
<name>Explosion</name>
<desc>ExplosionData Explosion</desc>
</field>
<field>
<name>fadeDelay</name>
<desc>The time in milliseconds when the projectile begins to fade out.  Must be less than the lifetime to have an effect.</desc>
</field>
<field>
<name>gravityMod</name>
<desc>float gravityMod</desc>
</field>
<field>
<name>impactForce</name>
<desc>float impactForce</desc>
</field>
<field>
<name>isBallistic</name>
<desc>bool isBallistic</desc>
</field>
<field>
<name>Lifetime</name>
<desc>The time in milliseconds before the projectile is removed from the simulation.</desc>
</field>
<field>
<name>lightDesc</name>
<desc>LightDescription lightDesc</desc>
</field>
<field>
<name>muzzleVelocity</name>
<desc>float muzzleVelocity</desc>
</field>
<field>
<name>onCollision( Projectile proj, SceneObject col, float fade, Point3F pos, Point3F normal )</name>
<desc>Called when a projectile collides with another object.
@param proj The projectile colliding.
@param col The object hit by the projectile.
@param fade The current fadeValue of the projectile, affects its visibility.
@param pos The collision position.
@param normal The collision normal.
@see Projectile, ProjectileData</desc>
</field>
<field>
<name>onExplode( Projectile proj, Point3F pos, float fade )</name>
<desc>Called when a projectile explodes.
@param proj The projectile exploding.
@param pos The position of the explosion.
@param fade The currently fadeValue of the projectile, affects its visibility.
@see Projectile, ProjectileData</desc>
</field>
<field>
<name>ParticleEmitter</name>
<desc>ParticleEmitterData ParticleEmitter</desc>
</field>
<field>
<name>particleWaterEmitter</name>
<desc>ParticleEmitterData particleWaterEmitter</desc>
</field>
<field>
<name>projectileShapeName</name>
<desc>filename projectileShapeName</desc>
</field>
<field>
<name>scale</name>
<desc>Point3F scale</desc>
</field>
<field>
<name>sound</name>
<desc>SFXTrack sound</desc>
</field>
<field>
<name>Splash</name>
<desc>SplashData Splash</desc>
</field>
<field>
<name>velInheritFactor</name>
<desc>float velInheritFactor</desc>
</field>
<field>
<name>waterExplosion</name>
<desc>ExplosionData waterExplosion</desc>
</field>
</class>
<class>
<name>ProjectileDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RadialImpulseEvent</name>
<method>
<name>send</name>
<args>( string inPosition="1.0 1.0 1.0", float radius=10.0f, float magnitude=20.0f )</args>
<desc>Apply a radial impulse to any SceneObjects in the area of effect.
This event is performed server-side AND client-side.

@param position Center point for this radial impulse.
@param radius Distance from the position for this radial impulse to affect.
@param magnitude The force applied to objects within the radius from the position of this radial impulse effect.

@tsexample
// Define the Position
%position = "10.0 15.0 10.0";

// Define the Radius
%radius = "25.0";

// Define the Magnitude
%magnitude = "30.0"

// Create a globalRadialImpulse physics effect.
RadialImpulseEvent::send(%position,%radius,%magnitude);
@endtsexample</desc>
</method>
</class>
<class>
<name>RadialImpulseEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ReflectorDesc</name>
<base>SimDataBlock</base>
<field>
<name>detailAdjust</name>
<desc>Scale applied to lod calculation of objects rendering into this reflection ( modulates $pref::TS::detailAdjust ).</desc>
</field>
<field>
<name>farDist</name>
<desc>Far plane distance to use when rendering reflections.</desc>
</field>
<field>
<name>maxRateMs</name>
<desc>If less than maxRateMs has elapsed since this relfection was last updated, then do not update it again. This 'skip' can be disabled by setting maxRateMs to zero.</desc>
</field>
<field>
<name>nearDist</name>
<desc>Near plane distance to use when rendering this reflection. Adjust this to limit self-occlusion artifacts.</desc>
</field>
<field>
<name>objectTypeMask</name>
<desc>Object types which render into this reflection.</desc>
</field>
<field>
<name>priority</name>
<desc>Priority for updating this reflection, relative to others.</desc>
</field>
<field>
<name>texSize</name>
<desc>Size in pixels of the (square) reflection texture. For a cubemap this value is interpreted as size of each face.</desc>
</field>
<field>
<name>useOcclusionQuery</name>
<desc>If available on the device use HOQs to determine if the reflective object is visible before updating its reflection.</desc>
</field>
</class>
<class>
<name>ReflectorDescClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RemoteCommandEvent</name>
</class>
<class>
<name>RemoteCommandEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderBinManager</name>
<base>SimObject</base>
<method>
<name>getBinType</name>
<args>()</args>
<desc>Returns the bin type string.</desc>
</method>
<field>
<name>binType</name>
<desc>Sets the render bin type which limits what render instances are added to this bin.</desc>
</field>
<field>
<name>processAddOrder</name>
<desc>Defines the order for adding instances in relation to other bins.</desc>
</field>
<field>
<name>renderOrder</name>
<desc>Defines the order for rendering in relation to other bins.</desc>
</field>
</class>
<class>
<name>RenderBinManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderClothExample</name>
<base>SceneObject</base>
<method>
<name>clearShowVerts</name>
</method>
<method>
<name>postApply</name>
</method>
<method>
<name>setShowVerts</name>
</method>
<method>
<name>updateMaterial</name>
</method>
<field>
<name>ClothAttachmentResponseCoefficient</name>
<desc>float ClothAttachmentResponseCoefficient</desc>
</field>
<field>
<name>ClothAttachmentTearFactor</name>
<desc>float ClothAttachmentTearFactor</desc>
</field>
<field>
<name>ClothBending</name>
<desc>bool ClothBending</desc>
</field>
<field>
<name>ClothBendingStiffness</name>
<desc>float ClothBendingStiffness</desc>
</field>
<field>
<name>ClothCollisionResponseCoefficient</name>
<desc>float ClothCollisionResponseCoefficient</desc>
</field>
<field>
<name>ClothCollisionTwoWay</name>
<desc>bool ClothCollisionTwoWay</desc>
</field>
<field>
<name>ClothDamping</name>
<desc>bool ClothDamping</desc>
</field>
<field>
<name>ClothDampingCoefficient</name>
<desc>float ClothDampingCoefficient</desc>
</field>
<field>
<name>ClothDensity</name>
<desc>float ClothDensity</desc>
</field>
<field>
<name>ClothDisableCollision</name>
<desc>bool ClothDisableCollision</desc>
</field>
<field>
<name>ClothFriction</name>
<desc>float ClothFriction</desc>
</field>
<field>
<name>ClothFromFluidResponseCoefficient</name>
<desc>float ClothFromFluidResponseCoefficient</desc>
</field>
<field>
<name>ClothGravity</name>
<desc>bool ClothGravity</desc>
</field>
<field>
<name>ClothMinAdhereVelocity</name>
<desc>float ClothMinAdhereVelocity</desc>
</field>
<field>
<name>ClothPressure</name>
<desc>float ClothPressure</desc>
</field>
<field>
<name>ClothRelativeGridSpacing</name>
<desc>float ClothRelativeGridSpacing</desc>
</field>
<field>
<name>ClothSleepLinearVelocity</name>
<desc>float ClothSleepLinearVelocity</desc>
</field>
<field>
<name>ClothSolverIterations</name>
<desc>int ClothSolverIterations</desc>
</field>
<field>
<name>ClothStatic</name>
<desc>bool ClothStatic</desc>
</field>
<field>
<name>ClothStretchingStiffness</name>
<desc>float ClothStretchingStiffness</desc>
</field>
<field>
<name>ClothTearFactor</name>
<desc>float ClothTearFactor</desc>
</field>
<field>
<name>ClothThickness</name>
<desc>float ClothThickness</desc>
</field>
<field>
<name>ClothToFluidResponseCoefficient</name>
<desc>float ClothToFluidResponseCoefficient</desc>
</field>
<field>
<name>ClothVisualization</name>
<desc>bool ClothVisualization</desc>
</field>
<field>
<name>ClothWakeUpCounter</name>
<desc>float ClothWakeUpCounter</desc>
</field>
<field>
<name>height</name>
<desc>float height</desc>
</field>
<field>
<name>LockBottom</name>
<desc>bool LockBottom</desc>
</field>
<field>
<name>LockLeft</name>
<desc>bool LockLeft</desc>
</field>
<field>
<name>LockLowerLeft</name>
<desc>bool LockLowerLeft</desc>
</field>
<field>
<name>LockLowerRight</name>
<desc>bool LockLowerRight</desc>
</field>
<field>
<name>LockRight</name>
<desc>bool LockRight</desc>
</field>
<field>
<name>LockTop</name>
<desc>bool LockTop</desc>
</field>
<field>
<name>LockUpperLeft</name>
<desc>bool LockUpperLeft</desc>
</field>
<field>
<name>LockUpperRight</name>
<desc>bool LockUpperRight</desc>
</field>
<field>
<name>Material</name>
<desc>string Material</desc>
</field>
<field>
<name>NumParticlesX</name>
<desc>int NumParticlesX</desc>
</field>
<field>
<name>NumParticlesY</name>
<desc>int NumParticlesY</desc>
</field>
<field>
<name>Width</name>
<desc>float Width</desc>
</field>
</class>
<class>
<name>RenderClothExampleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderFormatToken</name>
<base>RenderPassStateToken</base>
<field>
<name>aaLevel</name>
<desc>Anti-ailiasing level for the this token. 0 disables, -1 uses adapter default.</desc>
</field>
<field>
<name>copyEffect</name>
<desc>This PostEffect will be run when the render target is changed to the format specified by this token. It is used to copy/format data into the token rendertarget</desc>
</field>
<field>
<name>depthFormat</name>
<desc>Sets the depth/stencil buffer format for this token.</desc>
</field>
<field>
<name>format</name>
<desc>Sets the color buffer format for this token.</desc>
</field>
<field>
<name>resolveEffect</name>
<desc>This PostEffect will be run when the render target is changed back to the format active prior to this token. It is used to copy/format data from the token rendertarget to the backbuffer.</desc>
</field>
</class>
<class>
<name>RenderFormatTokenClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderGlowMgr</name>
<base>RenderTexTargetBinManager</base>
</class>
<class>
<name>RenderGlowMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderImposterMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderImposterMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderMeshExample</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
<args>()</args>
<desc>A utility method for forcing a network update.</desc>
</method>
<field>
<name>Material</name>
<desc>The name of the material used to render the mesh.</desc>
</field>
</class>
<class>
<name>RenderMeshExampleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderMeshMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderMeshMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderObjectExample</name>
<base>SceneObject</base>
</class>
<class>
<name>RenderObjectExampleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderObjectMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderObjectMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderOcclusionMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderOcclusionMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderParticleMgr</name>
<base>RenderTexTargetBinManager</base>
</class>
<class>
<name>RenderParticleMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderPassManager</name>
<base>SimObject</base>
<method>
<name>addManager</name>
<args>( RenderBinManager  renderBin )</args>
<desc>Add as a render bin manager to the pass.</desc>
</method>
<method>
<name>getManager</name>
<args>( int index )</args>
<desc>Returns the render bin manager at the index or null if the index is out of range.</desc>
</method>
<method>
<name>getManagerCount</name>
<args>()</args>
<desc>Returns the total number of bin managers.</desc>
</method>
<method>
<name>removeManager</name>
<args>( RenderBinManager  renderBin )</args>
<desc>Removes a render bin manager.</desc>
</method>
</class>
<class>
<name>RenderPassManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderPassStateBin</name>
<base>RenderBinManager</base>
<field>
<name>stateToken</name>
<desc>RenderPassStateToken stateToken</desc>
</field>
</class>
<class>
<name>RenderPassStateBinClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderPassStateToken</name>
<base>SimObject</base>
<method>
<name>disable</name>
<args>()</args>
<desc>@brief Disables the token.</desc>
</method>
<method>
<name>enable</name>
<args>()</args>
<desc>@brief Enables the token.</desc>
</method>
<method>
<name>toggle</name>
<args>()</args>
<desc>@brief Toggles the token from enabled to disabled or vice versa.</desc>
</method>
<field>
<name>enabled</name>
<desc>Enables or disables this token.</desc>
</field>
</class>
<class>
<name>RenderPassStateTokenClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderPrePassMgr</name>
<base>RenderTexTargetBinManager</base>
</class>
<class>
<name>RenderPrePassMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderShapeExample</name>
<base>SceneObject</base>
<field>
<name>shapeFile</name>
<desc>The path to the DTS shape file.</desc>
</field>
</class>
<class>
<name>RenderShapeExampleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderTerrainMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderTerrainMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderTexTargetBinManager</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderTexTargetBinManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RenderTranslucentMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderTranslucentMgrClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RigidShape</name>
<base>ShapeBase</base>
<method>
<name>freezeSim</name>
<args>( bool isFrozen )</args>
<desc>@brief Enables or disables the physics simulation on the RigidShape object.

@param isFrozen Boolean frozen state to set the object.
@tsexample
// Define the frozen state.
%isFrozen = "true";

// Inform the object of the defined frozen state
%thisRigidShape.freezeSim(%isFrozen);
@endtsexample

@see ShapeBaseData</desc>
</method>
<method>
<name>reset</name>
<args>()</args>
<desc>@brief Clears physic forces from the shape and sets it at rest.

@tsexample
// Inform the RigidShape object to reset.
%thisRigidShape.reset();
@endtsexample

@see ShapeBaseData</desc>
</method>
<field>
<name>onEnterLiquid( string objId, string waterCoverage, string liquidType )</name>
<desc>@brief Called whenever this RigidShape object enters liquid.

@param objId The ID of the rigidShape object.
@param waterCoverage Amount of water coverage the RigidShape has.
@param liquidType Type of liquid that was entered.

@tsexample
// The RigidShape object falls in a body of liquid, causing the callback to occur.
RigidShape::onEnterLiquid(%this,%objId,%waterCoverage,%liquidType)
^{
^^// Code to run whenever this callback occurs.
^}
@endtsexample

@see ShapeBase</desc>
</field>
<field>
<name>onLeaveLiquid( string objId, string liquidType )</name>
<desc>@brief Called whenever the RigidShape object exits liquid.

@param objId The ID of the RigidShape object.
@param liquidType Type if liquid that was exited.

@tsexample
// The RigidShape object exits in a body of liquid, causing the callback to occur.
RigidShape::onLeaveLiquid(%this,%objId,%liquidType)
^{
^^// Code to run whenever this callback occurs.
^}
@endtsexample

@see ShapeBase</desc>
</field>
</class>
<class>
<name>RigidShapeClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RigidShapeData</name>
<base>ShapeBaseData</base>
<field>
<name>bodyFriction</name>
<desc>How much friction this object has. Lower values will cause the object to appear to be more slippery.</desc>
</field>
<field>
<name>bodyRestitution</name>
<desc>The percentage of kinetic energy kept by this object in a collision.</desc>
</field>
<field>
<name>cameraDecay</name>
<desc>Scalar rate at which the third person camera offset decays, per tick.</desc>
</field>
<field>
<name>cameraLag</name>
<desc>Scalar amount by which the third person camera lags the object, relative to the object's linear velocity.</desc>
</field>
<field>
<name>cameraOffset</name>
<desc>The vertical offset of the object's camera.</desc>
</field>
<field>
<name>cameraRoll</name>
<desc>Specifies whether the camera's rotation matrix, and the render eye transform are multiplied during camera updates.</desc>
</field>
<field>
<name>collisionTol</name>
<desc>Collision distance tolerance.</desc>
</field>
<field>
<name>contactTol</name>
<desc>Contact velocity tolerance.</desc>
</field>
<field>
<name>dragForce</name>
<desc>Used to simulate the constant drag acting on the object</desc>
</field>
<field>
<name>dustEmitter</name>
<desc>Array of pointers to ParticleEmitterData datablocks which will be used to emit particles at object/terrain contact point.</desc>
</field>
<field>
<name>dustHeight</name>
<desc>Height of dust effects.</desc>
</field>
<field>
<name>dustTrailEmitter</name>
<desc>Particle emitter used to create a dust trail for the moving object.</desc>
</field>
<field>
<name>exitingWater</name>
<desc>The AudioProfile will be used to produce sounds when emerging from water.</desc>
</field>
<field>
<name>exitSplashSoundVelocity</name>
<desc>The minimum velocity at which the exit splash sound will be played when emerging from water.</desc>
</field>
<field>
<name>hardImpactSound</name>
<desc>Sound to play when body impacts with at least hardImpactSpeed.</desc>
</field>
<field>
<name>hardImpactSpeed</name>
<desc>Minimum speed at which the object must be travelling for the hard impact sound to be played.</desc>
</field>
<field>
<name>hardSplashSoundVelocity</name>
<desc>The minimum velocity at which the hard splash sound will be played when impacting water.</desc>
</field>
<field>
<name>impactWaterEasy</name>
<desc>The AudioProfile will be used to produce sounds when a soft impact with water occurs.</desc>
</field>
<field>
<name>impactWaterHard</name>
<desc>The AudioProfile will be used to produce sounds when a hard impact with water occurs.</desc>
</field>
<field>
<name>impactWaterMedium</name>
<desc>The AudioProfile will be used to produce sounds when a medium impact with water occurs.</desc>
</field>
<field>
<name>integration</name>
<desc>Number of physics steps to process per tick.</desc>
</field>
<field>
<name>massBox</name>
<desc>Size of inertial box.</desc>
</field>
<field>
<name>massCenter</name>
<desc>Center of mass for rigid body.</desc>
</field>
<field>
<name>maxDrag</name>
<desc>Maximum drag available to this object.</desc>
</field>
<field>
<name>mediumSplashSoundVelocity</name>
<desc>The minimum velocity at which the medium splash sound will be played when impacting water.</desc>
</field>
<field>
<name>minDrag</name>
<desc>Minimum drag available to this object.</desc>
</field>
<field>
<name>minImpactSpeed</name>
<desc>Minimum collision speed to classify collision as impact (triggers onImpact on server object).</desc>
</field>
<field>
<name>minRollSpeed</name>
<desc>float minRollSpeed</desc>
</field>
<field>
<name>softImpactSound</name>
<desc>Sound to play when body impacts with at least softImageSpeed but less than hardImpactSpeed.</desc>
</field>
<field>
<name>softImpactSpeed</name>
<desc>Minimum speed at which this object must be travelling for the soft impact sound to be played.</desc>
</field>
<field>
<name>softSplashSoundVelocity</name>
<desc>The minimum velocity at which the soft splash sound will be played when impacting water.</desc>
</field>
<field>
<name>splashEmitter</name>
<desc>Array of pointers to ParticleEmitterData datablocks which will generate splash effects.</desc>
</field>
<field>
<name>splashFreqMod</name>
<desc>The simulated frequency modulation of a splash generated by this object. Multiplied along with speed and time elapsed when determining splash emition rate.</desc>
</field>
<field>
<name>splashVelEpsilon</name>
<desc>The threshold speed at which we consider the object's movement to have stopped when updating splash effects.</desc>
</field>
<field>
<name>triggerDustHeight</name>
<desc>Maximum height from the ground at which the object will generate dust.</desc>
</field>
<field>
<name>vertFactor</name>
<desc>The scalar applied to the vertical portion of the velocity drag acting on a object.</desc>
</field>
<field>
<name>waterWakeSound</name>
<desc>The AudioProfile will be used to produce sounds when a water wake is displayed.</desc>
</field>
</class>
<class>
<name>RigidShapeDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>River</name>
<base>WaterObject</base>
<method>
<name>regenerate</name>
<args>()</args>
<desc>Intended as a helper to developers and editor scripts.
Force River to recreate its geometry.</desc>
</method>
<method>
<name>setBatchSize</name>
<args>( float meters )</args>
<desc>Intended as a helper to developers and editor scripts.
BatchSize is not currently used.</desc>
</method>
<method>
<name>setMaxDivisionSize</name>
<args>( float meters )</args>
<desc>Intended as a helper to developers and editor scripts.
@see SubdivideLength field.</desc>
</method>
<method>
<name>setMetersPerSegment</name>
<args>( float meters )</args>
<desc>Intended as a helper to developers and editor scripts.
@see SegmentLength field.</desc>
</method>
<method>
<name>setNodeDepth</name>
<args>( int idx, float meters )</args>
<desc>Intended as a helper to developers and editor scripts.
Sets the depth in meters of a particular node.</desc>
</method>
<field>
<name>FlowMagnitude</name>
<desc>Magnitude of the force vector applied to dynamic objects within the River.</desc>
</field>
<field>
<name>LowLODDistance</name>
<desc>Segments of the river at this distance in meters or greater will render as a single unsubdivided without undulation effects.</desc>
</field>
<field>
<name>Node</name>
<desc>For internal use, do not modify.</desc>
</field>
<field>
<name>SegmentLength</name>
<desc>Divide the River lengthwise into segments of this length in meters. These geometric volumes are used for spacial queries like determining containment.</desc>
</field>
<field>
<name>SubdivideLength</name>
<desc>For purposes of generating the renderable geometry River segments are further subdivided such that no quad is of greater width or length than this distance in meters.</desc>
</field>
</class>
<class>
<name>RiverClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>RootGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>SaveFileDialog</name>
<base>FileDialog</base>
<field>
<name>OverwritePrompt</name>
<desc>True/False whether the dialog should prompt before accepting an existing file name</desc>
</field>
</class>
<class>
<name>SaveFileDialogClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ScatterSky</name>
<base>SceneObject</base>
<method>
<name>applyChanges</name>
<args>()</args>
<desc>Apply a full network update of all fields to all clients.</desc>
</method>
<field>
<name>ambientScale</name>
<desc>Modulates the ambient color of sunlight.</desc>
</field>
<field>
<name>attenuationRatio</name>
<desc>The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.</desc>
</field>
<field>
<name>azimuth</name>
<desc>The horizontal angle of the sun measured clockwise from the positive Y world axis. This field is networked.</desc>
</field>
<field>
<name>brightness</name>
<desc>The brightness of the ScatterSky's light object.</desc>
</field>
<field>
<name>castShadows</name>
<desc>Enables/disables shadows cast by objects due to ScatterSky light.</desc>
</field>
<field>
<name>cookie</name>
<desc>A custom pattern texture which is projected from the light.</desc>
</field>
<field>
<name>elevation</name>
<desc>The elevation angle of the sun above or below the horizon. This field is networked.</desc>
</field>
<field>
<name>exposure</name>
<desc>Controls the contrast of the sky and sun during daytime.</desc>
</field>
<field>
<name>fadeStartDistance</name>
<desc>Start fading shadows out at this distance.  0 = auto calculate this distance.</desc>
</field>
<field>
<name>flareScale</name>
<desc>Changes the size and intensity of the flare.</desc>
</field>
<field>
<name>flareType</name>
<desc>Datablock for the flare produced by the ScatterSky.</desc>
</field>
<field>
<name>fogScale</name>
<desc>Modulates the fog color. Note that this overrides the LevelInfo.fogColor property, so you should not use LevelInfo.fogColor if the level contains a ScatterSky object.</desc>
</field>
<field>
<name>includeLightmappedGeometryInShadow</name>
<desc>This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>lastSplitTerrainOnly</name>
<desc>This toggles only terrain being rendered to the last split of a PSSM shadow map.</desc>
</field>
<field>
<name>logWeight</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>mieScattering</name>
<desc>Affects the size and intensity of light scattering around the sun.</desc>
</field>
<field>
<name>moonAzimuth</name>
<desc>The horizontal angle of the moon measured clockwise from the positive Y world axis. This is not animated by time or networked.</desc>
</field>
<field>
<name>moonElevation</name>
<desc>The elevation angle of the moon above or below the horizon. This is not animated by time or networked.</desc>
</field>
<field>
<name>moonEnabled</name>
<desc>Enable or disable rendering of the moon sprite during night.</desc>
</field>
<field>
<name>moonLightColor</name>
<desc>Color of light cast by the directional light during night.</desc>
</field>
<field>
<name>moonMat</name>
<desc>Material for the moon sprite.</desc>
</field>
<field>
<name>moonScale</name>
<desc>Controls size the moon sprite renders, specified as a fractional amount of the screen height.</desc>
</field>
<field>
<name>nightColor</name>
<desc>The ambient color during night. Also used for the sky color if useNightCubemap is false.</desc>
</field>
<field>
<name>nightCubemap</name>
<desc>Cubemap visible during night.</desc>
</field>
<field>
<name>nightFogColor</name>
<desc>The fog color during night.</desc>
</field>
<field>
<name>numSplits</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>overDarkFactor</name>
<desc>The ESM shadow darkening factor</desc>
</field>
<field>
<name>rayleighScattering</name>
<desc>Controls how blue the atmosphere is during the day.</desc>
</field>
<field>
<name>representedInLightmap</name>
<desc>This light is represented in lightmaps (static light, default: false)</desc>
</field>
<field>
<name>shadowDarkenColor</name>
<desc>The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>shadowDistance</name>
<desc>The distance from the camera to extend the PSSM shadow.</desc>
</field>
<field>
<name>shadowSoftness</name>
<desc>float shadowSoftness</desc>
</field>
<field>
<name>shadowType</name>
<desc>The type of shadow to use on this light.</desc>
</field>
<field>
<name>skyBrightness</name>
<desc>Global brightness and intensity applied to the sky and objects in the level.</desc>
</field>
<field>
<name>sunScale</name>
<desc>Modulates the directional color of sunlight.</desc>
</field>
<field>
<name>texSize</name>
<desc>The texture size of the shadow map.</desc>
</field>
<field>
<name>useNightCubemap</name>
<desc>Transition to the nightCubemap during night. If false we use nightColor.</desc>
</field>
</class>
<class>
<name>ScatterSkyClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SceneObject</name>
<base>NetObject</base>
<method>
<name>getEulerRotation</name>
<args>()</args>
<desc>Get Euler rotation of object.
@return the orientation of the object in the form of rotations around the X, Y and Z axes in degrees.</desc>
</method>
<method>
<name>getForwardVector</name>
<args>()</args>
<desc>Get the direction this object is facing.
@return a vector indicating the direction this object is facing.
@note This is the object's y axis.</desc>
</method>
<method>
<name>getMountedObject</name>
<args>( int slot )</args>
<desc>Get the object mounted at a particular slot.
@param slot mount slot index to query
@return ID of the object mounted in the slot, or 0 if no object.</desc>
</method>
<method>
<name>getMountedObjectCount</name>
<args>()</args>
<desc>Get the number of objects mounted to us.
@return the number of mounted objects.</desc>
</method>
<method>
<name>getMountedObjectNode</name>
<args>( int slot )</args>
<desc>Get the mount node index of the object mounted at a particular slot.
@param slot mount slot index to query
@return index of the mount node used by the object mounted in this slot.</desc>
</method>
<method>
<name>getMountNodeObject</name>
<args>( int node )</args>
<desc>Get the object mounted at a particular node.
@param node mount node to query
@return ID of the first object mounted at the node, or 0 if none found.</desc>
</method>
<method>
<name>getObjectBox</name>
<args>()</args>
<desc>Get the object's bounding box (relative to the object's origin).
@return six fields, two Point3Fs, containing the min and max points of the objectbox.</desc>
</method>
<method>
<name>getObjectMount</name>
<args>()</args>
<desc>Get the object we are mounted to.
@return the SceneObject ID of the object we're mounted to, or 0 if not mounted.</desc>
</method>
<method>
<name>getPosition</name>
<args>()</args>
<desc>Get the object's world position.
@return the current world position of the object</desc>
</method>
<method>
<name>getRightVector</name>
<args>()</args>
<desc>Get the right vector of the object.
@return a vector indicating the right direction of this object.@note This is the object's x axis.</desc>
</method>
<method>
<name>getScale</name>
<args>()</args>
<desc>Get the object's scale.
@return object scale as a Point3F</desc>
</method>
<method>
<name>getTransform</name>
<args>()</args>
<desc>Get the object's transform.
@return the current transform of the object</desc>
</method>
<method>
<name>getUpVector</name>
<args>()</args>
<desc>Get the up vector of the object.
@return a vector indicating the up direction of this object.@note This is the object's z axis.</desc>
</method>
<method>
<name>getWorldBox</name>
<args>()</args>
<desc>Get the object's world bounding box.
@return six fields, two Point3Fs, containing the min and max points of the worldbox.</desc>
</method>
<method>
<name>getWorldBoxCenter</name>
<args>()</args>
<desc>Get the center of the object's world bounding box.
@return the center of the world bounding box for this object.</desc>
</method>
<method>
<name>isGlobalBounds</name>
<args>()</args>
<desc>Check if this object has a global bounds set.
If global bounds are set to be true, then the object is assumed to have an infinitely large bounding box for collision and rendering purposes.
@return true if the object has a global bounds.</desc>
</method>
<method>
<name>isMounted</name>
<args>()</args>
<desc>Check if we are mounted to another object.
@return true if mounted to another object, false if not mounted.</desc>
</method>
<method>
<name>mountObject</name>
<args>( SceneObject objB, int slot, TransformF txfm=MatrixF::Identity )</args>
<desc>Mount objB to this object at the desired slot with optional transform.
@param objB  Object to mount onto us
@param slot  Mount slot ID
@param txfm (optional) mount offset transform
@return true if successful, false if failed (objB is not valid)</desc>
</method>
<method>
<name>setScale</name>
<args>( Point3F scale )</args>
<desc>Set the object's scale.
@param scale object scale to set</desc>
</method>
<method>
<name>setTransform</name>
<args>( TransformF txfm )</args>
<desc>Set the object's transform (orientation and position).@param txfm object transform to set</desc>
</method>
<method>
<name>unmount</name>
<args>()</args>
<desc>Unmount from the currently mounted object if any.</desc>
</method>
<method>
<name>unmountObject</name>
<args>( SceneObject target )</args>
<desc>Unmount an object from ourselves.
@param target object to unmount
@return true if successful, false if failed</desc>
</method>
<field>
<name>isRenderEnabled</name>
<desc>Disables rendering on this instance.
@see isRenderable</desc>
</field>
<field>
<name>isSelectionEnabled</name>
<desc>Disables editor selection of this instance.
@see isSelectable</desc>
</field>
<field>
<name>mountNode</name>
<desc>Node we are mounted to.</desc>
</field>
<field>
<name>mountPID</name>
<desc>PersistentID of object we are mounted to.</desc>
</field>
<field>
<name>mountPos</name>
<desc>Position we are mounted at ( object space of our mount object ).</desc>
</field>
<field>
<name>mountRot</name>
<desc>Rotation we are mounted at ( object space of our mount object ).</desc>
</field>
<field>
<name>position</name>
<desc>Object world position.</desc>
</field>
<field>
<name>rotation</name>
<desc>Object world orientation.</desc>
</field>
<field>
<name>scale</name>
<desc>Object world scale.</desc>
</field>
</class>
<class>
<name>SceneObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ScopeAlwaysShape</name>
<base>StaticShape</base>
</class>
<class>
<name>ScopeAlwaysShapeClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ScriptGroup</name>
<base>SimGroup</base>
<field>
<name>onAdd( SimObjectId ID )</name>
<desc>Called when this ScriptGroup is added to the system.
@param ID Unique object ID assigned when created (%this in script).</desc>
</field>
<field>
<name>onRemove( SimObjectId ID )</name>
<desc>Called when this ScriptObject is removed from the system.
@param ID Unique object ID assigned when created (%this in script).</desc>
</field>
</class>
<class>
<name>ScriptGroupClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ScriptMsgListener</name>
<base>SimObject</base>
<field>
<name>onAdd()</name>
<desc>Script callback when a listener is first created and registered.

@tsexample
function ScriptMsgListener::onAdd(%this)
{
^// Perform on add code here
}
@endtsexample</desc>
</field>
<field>
<name>onAddToQueue( string queue )</name>
<desc>@brief Callback for when the listener is added to a queue

The default implementation of onAddToQueue() and onRemoveFromQueue() provide tracking of the queues this listener is added to through the mQueues member. Overrides of onAddToQueue() or onRemoveFromQueue() should ensure they call the parent implementation in any overrides.
@param queue The name of the queue that the listener added to
@see onRemoveFromQueue()</desc>
</field>
<field>
<name>onMessageObjectReceived( string queue, Message  msg )</name>
<desc>Called when a message object (not just the message data) is passed to a listener.
@param queue The name of the queue the message was dispatched to
@param msg The message object
@return false to prevent other listeners receiving this message, true otherwise
@see Message
@see onMessageReceived</desc>
</field>
<field>
<name>onMessageReceived( string queue, string event, string data )</name>
<desc>Called when the listener has received a message.
@param queue The name of the queue the message was dispatched to
@param event The name of the event (function) that was triggered
@param data The data (parameters) for the message

@return false to prevent other listeners receiving this message, true otherwise</desc>
</field>
<field>
<name>onRemove()</name>
<desc>Script callback when a listener is deleted.

@tsexample
function ScriptMsgListener::onRemove(%this)
{
^// Perform on remove code here
}
@endtsexample</desc>
</field>
<field>
<name>onRemoveFromQueue( string queue )</name>
<desc>@brief Callback for when the listener is removed from a queue

The default implementation of onAddToQueue() and onRemoveFromQueue() provide tracking of the queues this listener is added to through the mQueues member. Overrides of onAddToQueue() or onRemoveFromQueue() should ensure they call the parent implementation in any overrides.
@param queue The name of the queue that the listener was removed from
@see onAddToQueue()</desc>
</field>
</class>
<class>
<name>ScriptMsgListenerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ScriptObject</name>
<base>SimObject</base>
<field>
<name>onAdd( SimObjectId ID )</name>
<desc>Called when this ScriptObject is added to the system.
@param ID Unique object ID assigned when created (%this in script).</desc>
</field>
<field>
<name>onRemove( SimObjectId ID )</name>
<desc>Called when this ScriptObject is removed from the system.
@param ID Unique object ID assigned when created (%this in script).</desc>
</field>
</class>
<class>
<name>ScriptObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SetMissionCRCEvent</name>
</class>
<class>
<name>SetMissionCRCEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Settings</name>
<base>SimObject</base>
<method>
<name>beginGroup</name>
<desc>settingObj.beginGroup(groupName, fromStart = false);</desc>
</method>
<method>
<name>clearGroups</name>
<desc>settingObj.clearGroups();</desc>
</method>
<method>
<name>endGroup</name>
<desc>settingObj.endGroup();</desc>
</method>
<method>
<name>findFirstValue</name>
<desc>settingObj.findFirstValue();</desc>
</method>
<method>
<name>findNextValue</name>
<desc>settingObj.findNextValue();</desc>
</method>
<method>
<name>getCurrentGroups</name>
<desc>settingObj.getCurrentGroups();</desc>
</method>
<method>
<name>read</name>
<desc>%success = settingObj.read();</desc>
</method>
<method>
<name>remove</name>
<desc>settingObj.remove(settingName, includeDefaults = false);</desc>
</method>
<method>
<name>setDefaultValue</name>
<desc>settingObj.setDefaultValue(settingName, value);</desc>
</method>
<method>
<name>setValue</name>
<desc>settingObj.setValue(settingName, value);</desc>
</method>
<method>
<name>value</name>
<desc>settingObj.value(settingName, defaultValue);</desc>
</method>
<method>
<name>write</name>
<desc>%success = settingObj.write();</desc>
</method>
<field>
<name>file</name>
<desc>The file path and name to be saved to and loaded from.</desc>
</field>
</class>
<class>
<name>SettingsClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXAmbience</name>
<base>SimDataBlock</base>
<field>
<name>dopplerFactor</name>
<desc>The factor to apply to the doppler affect in this space.
Defaults to 0.5.

@ref SFXSource_doppler</desc>
</field>
<field>
<name>environment</name>
<desc>Reverb environment active in the ambience zone.
@ref SFX_reverb</desc>
</field>
<field>
<name>rolloffFactor</name>
<desc>The rolloff factor to apply to distance-based volume attenuation in this space.
Defaults to 1.0.

@note This applies to the logarithmic distance model only.

@ref SFXSource_volume</desc>
</field>
<field>
<name>soundTrack</name>
<desc>Sound track to play in the ambience zone.</desc>
</field>
<field>
<name>states</name>
<desc>States to activate when the ambient zone is entered.
When the ambient sound state is entered, all states associated with the state will be activated (given that they are not disabled) and deactivated when the space is exited again.</desc>
</field>
</class>
<class>
<name>SFXAmbienceClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXAmbienceSet</name>
<base>SimSet</base>
</class>
<class>
<name>SFXController</name>
<base>SFXSource</base>
<method>
<name>getCurrentSlot</name>
<args>()</args>
<desc>Get the index of the playlist slot currently processed by the controller.
@return The slot index currently being played.
@see SFXPlayList</desc>
</method>
<method>
<name>setCurrentSlot</name>
<args>( int index )</args>
<desc>Set the index of the playlist slot to play by the controller.  This can be used to seek in the playlist.
@param index Index of the playlist slot.</desc>
</method>
<field>
<name>trace</name>
<desc>If true, the controller logs its operation to the console.
This is a non-networked field that will work locally only.</desc>
</field>
</class>
<class>
<name>SFXControllerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXDescription</name>
<base>SimDataBlock</base>
<field>
<name>coneInsideAngle</name>
<desc>Inner sound cone angle in degrees.
This value determines the angle of the inner volume cone that protrudes out in the direction of a sound.  Within this cone, the sound source retains full volume that is unaffected by sound cone settings (though still affected by distance attenuation.)

Valid values are from 0 to 360. Must be less than coneOutsideAngle. Default is 360. Only for 3D sounds.

@ref SFXSource_cones</desc>
</field>
<field>
<name>coneOutsideAngle</name>
<desc>Outer sound cone angle in degrees.
This value determines the angle of the outer volume cone that protrudes out in the direction of a sound and surrounds the inner volume cone.  Within this cone, volume will linearly interpolate from the outer cone hull inwards to the inner coner hull starting with the base volume scaled by coneOutsideVolume and ramping up/down to the full base volume.

Valid values are from 0 to 360.  Must be &gt;= coneInsideAngle.  Default is 360.  Only for 3D sounds.

@ref SFXSource_cones</desc>
</field>
<field>
<name>coneOutsideVolume</name>
<desc>Determines the volume scale factor applied the a source's base volume level outside of the outer cone.
In the outer cone, starting from outside the inner cone, the scale factor smoothly interpolates from 1.0 (within the inner cone) to this value.  At the moment, the allowed range is 0.0 (silence) to 1.0 (no attenuation) as amplification is only supported on XAudio2 but not on the other devices.

Only for 3D sound.

@ref SFXSource_cones</desc>
</field>
<field>
<name>fadeInEase</name>
<desc>Easing curve for fade-in transition.
Volume fade-ins will interpolate volume along this curve.

@ref SFXSource_fades</desc>
</field>
<field>
<name>fadeInTime</name>
<desc>Number of seconds to gradually fade in volume from zero when playback starts.
Must be &gt;= 0.

@ref SFXSource_fades</desc>
</field>
<field>
<name>fadeLoops</name>
<desc>Fade each cycle of a loop in and/or out; otherwise only fade-in first cycle.
By default, volume fading is applied to the beginning and end of the playback range, i.e. a fade-in segment is placed at the beginning of the sound and a fade-out segment is paced at the end of a sound.  However, when looping playback, this may be undesirable as each iteration of the sound will then have a fade-in and fade-out effect.

To set up looping sounds such that a fade-in is applied only when the sound is first started (or playback resumed) and a fade-out is only applied when the sound is explicitly paused or stopped, set this field to true.

Default is false.

@ref SFXSource_fades</desc>
</field>
<field>
<name>fadeOutEase</name>
<desc>Easing curve for fade-out transition.
Volume fade-outs will interpolate volume along this curve.

@ref SFXSource_fades</desc>
</field>
<field>
<name>fadeOutTime</name>
<desc>Number of seconds to gradually fade out volume down to zero when playback is stopped or paused.
Must be &gt;=0.

@ref SFXSource_fades</desc>
</field>
<field>
<name>is3D</name>
<desc>If true, sounds played with this description will have a position and orientation in space.
Unlike a non-positional sound, a 3D sound will have its volume attenuated depending on the distance to the listener in space.  The farther the sound moves away from the listener, the less audible it will be.

Non-positional sounds, in contrast, will remain at their original volume regardless of where the listener is.

@note Whether a sound is positional or non-positional cannot be changed once the sound was created so this field determines up front which is the case for a given sound.

@ref SFX_3d
@ref SFXSource_volume</desc>
</field>
<field>
<name>isLooping</name>
<desc>If true, the sound will be played in an endless loop.

Default is false.</desc>
</field>
<field>
<name>isStreaming</name>
<desc>If true, incrementally stream sounds; otherwise sounds are loaded in full.

@ref SFX_streaming</desc>
</field>
<field>
<name>maxDistance</name>
<desc>The distance at which attenuation stops.
In the linear distance model, the attenuated volume will be zero at this distance.

In the logarithmic model, attenuation will simply stop at this distance and the sound will keep its attenuated volume from there on out.  As such, it primarily functions as a cutoff factor to exponential distance attentuation to limit the number of voices relevant to updates.

Only applies to 3D sounds.
@see LevelInfo::soundDistanceModel

@ref SFX_3d
@ref SFXSource_volume</desc>
</field>
<field>
<name>parameters</name>
<desc>Names of the parameters to which sources using this description will automatically be linked.

Individual parameters are identified by their #internalName.

@ref SFX_interactive</desc>
</field>
<field>
<name>pitch</name>
<desc>Pitch shift to apply to playback.

The pitch assigned to a sound determines the speed at which it is played back.  A pitch shift of 1 plays the sound at its default speed.  A greater shift factor speeds up playback and a smaller shift factor slows it down.

Must be &gt;0.  Default is 1.</desc>
</field>
<field>
<name>priority</name>
<desc>Priority level for virtualization of sounds (1 = base level).
When there are more concurrently active sounds than supported by the audio mixer, some of the sounds need to be culled.  Which sounds are culled first depends primarily on total audibility of individual sounds. However, the priority of invidual sounds may be decreased or decreased through this field.

@ref SFXSound_virtualization</desc>
</field>
<field>
<name>referenceDistance</name>
<desc>Distance at which volume attenuation begins.
Up to this distance, the sound retains its base volume.

In the linear distance model, the volume will linearly from this distance onwards up to maxDistance where it reaches zero.

In the logarithmic distance model, the reference distance determine how fast the sound volume decreases with distance.  Each referenceDistance steps (scaled by the rolloff factor), the volume halves.

A rule of thumb is that for sounds that require you to be close to hear them in the real world, set the reference distance to small values whereas for sounds that are widely audible set it to larger values.

Only applies to 3D sounds.
@see LevelInfo::soundDistanceModel

@ref SFX_3d
@ref SFXSource_volume</desc>
</field>
<field>
<name>reverbAirAbsorptionFactor</name>
<desc>Multiplies SFXEnvironment::airAbsorptionHR.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbDirect</name>
<desc>Direct path level (at low and mid frequencies).
@note SUPPORTED: EAX/I3DL2/FMODSFX

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbDirectHF</name>
<desc>Relative direct path level at high frequencies.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbDopplerFactor</name>
<desc>Per-source doppler factor.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbExclusion</name>
<desc>Main exclusion control (attenuation at high frequencies).
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbExclusionLFRatio</name>
<desc>Exclusion low-frequency level re. main control.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbFlags</name>
<desc>Bitfield combination of per-sound reverb flags.
@see REVERB_DIRECTHFAUTO
@see REVERB_ROOMAUTO
@see REVERB_ROOMHFAUTO
@see REVERB_INSTANCE0
@see REVERB_INSTANCE1
@see REVERB_INSTANCE2
@see REVERB_INSTANCE3</desc>
</field>
<field>
<name>reverbObstruction</name>
<desc>Main obstruction control (attenuation at high frequencies).
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbObstructionLFRatio</name>
<desc>Obstruction low-frequency level re. main control.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbOcclusion</name>
<desc>Main occlusion control (attenuation at high frequencies).@note SUPPORTED: EAX/I3DL2


@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbOcclusionDirectRatio</name>
<desc>Relative occlusion control for direct path.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbOcclusionLFRatio</name>
<desc>Occlusion low-frequency level re. main control.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbOcclusionRoomRatio</name>
<desc>Relative occlusion control for room effect.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbOutsideVolumeHF</name>
<desc>Outside sound cone level at high frequencies.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbReverbRolloffFactor</name>
<desc>Per-source logarithmic falloff factor.
@note SUPPORTED: EAX Only

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbRoom</name>
<desc>Room effect level (at low and mid frequencies).
@note SUPPORTED: EAX/I3DL2/FMODSFX

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbRoomHF</name>
<desc>Relative room effect level at high frequencies.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>reverbRoomRolloffFactor</name>
<desc>Room effect falloff factor.
@note SUPPORTED: EAX/I3DL2

@see http://www.atc.creative.com/algorithms/eax20.pdf</desc>
</field>
<field>
<name>rolloffFactor</name>
<desc>Scale factor to apply to logarithmic distance attenuation curve.  If -1, the global rolloff setting is used.

@note Per-sound rolloff is only supported on OpenAL and FMOD at the moment.  With other divices, the global rolloff setting is used for all sounds.
@see LevelInfo::soundDistanceModel</desc>
</field>
<field>
<name>scatterDistance</name>
<desc>Bounds on random displacement of 3D sound positions.
When a 3D sound is created and given its initial position in space, this field is used to determine the amount of randomization applied to the actual position given to the sound system.

The randomization uses the following scheme:@verbatim
x += rand( - scatterDistance[ 0 ], scatterDistance[ 0 ] );
y += rand( - scatterDistance[ 1 ], scatterDistance[ 1 ] );
z += rand( - scatterDistance[ 2 ], scatterDistance[ 2 ] );
@endverbatim</desc>
</field>
<field>
<name>sourceGroup</name>
<desc>Group that sources playing with this description should be put into.

When a sound source is allocated, it will be made a child of the source group that is listed in its
description.  This group will then modulate several properties of the sound as it is played.

For example, one use of groups is to segregate sounds so that volume levels of different sound groups such as interface audio and game audio can be controlled independently.

@ref SFXSource_hierarchies</desc>
</field>
<field>
<name>streamPacketSize</name>
<desc>Number of seconds of sample data per single streaming packet.
This field allows to fine-tune streaming for individual sounds.  The streaming system processes streamed sounds in batches called packets.  Each packet will contain a set amount of sample data determined by this field.  The greater its value, the more sample data each packet contains, the more work is done per packet.

@note This field only takes effect when Torque's own sound system performs the streaming. When FMOD is used, this field is ignored and streaming is performed by FMOD.

@ref SFX_streaming</desc>
</field>
<field>
<name>streamReadAhead</name>
<desc>Number of sample packets to read and buffer in advance.
This field determines the number of packets that the streaming system will try to keep buffered in advance.  As such it determines the number of packets that can be consumed by the sound device before the playback queue is running dry.  Greater values thus allow for more lag in the streaming pipeline.

@note This field only takes effect when Torque's own sound system performs the streaming. When FMOD is used, this field is ignored and streaming is performed by FMOD.

@ref SFX_streaming</desc>
</field>
<field>
<name>useCustomReverb</name>
<desc>If true, use the reverb properties defined here on sounds.
By default, sounds will be assigned a generic reverb profile.  By setting this flag to true, a custom reverb setup can be defined using the "Reverb" properties that will then be assigned to sounds playing with the description.

@ref SFX_reverb</desc>
</field>
<field>
<name>useHardware</name>
<desc>Whether the sound is allowed to be mixed in hardware.
If true, the sound system will try to allocate the voice for the sound directly on the sound hardware for mixing by the hardware mixer.  Be aware that a hardware mixer may not provide all features available to sounds mixed in software.

@note This flag currently only takes effect when using FMOD.

@note Generally, it is preferable to let sounds be mixed in software.</desc>
</field>
<field>
<name>volume</name>
<desc>Base volume level for the sound.

This will be the starting point for volume attenuation on the sound.  The final effective volume of a sound will be dependent on a number of parameters.

Must be between 0 (mute) and 1 (full volume).  Default is 1.

@ref SFXSource_volume</desc>
</field>
</class>
<class>
<name>SFXDescriptionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXDescriptionSet</name>
<base>SimSet</base>
</class>
<class>
<name>SFXEmitter</name>
<base>SceneObject</base>
<method>
<name>getSource</name>
<args>()</args>
<desc>Get the sound source object from the emitter.

@return The sound source used by the emitter or null.@note This method will return null when called on the server-side SFXEmitter object.  Only client-side ghosts actually hold on to %SFXSources.</desc>
</method>
<method>
<name>play</name>
<args>()</args>
<desc>Manually start playback of the emitter's sound.
If this is called on the server-side object, the play command will be related to all client-side ghosts.</desc>
</method>
<method>
<name>stop</name>
<args>()</args>
<desc>Manually stop playback of the emitter's sound.
If this is called on the server-side object, the stop command will be related to all client-side ghosts.</desc>
</method>
<field>
<name>coneInsideAngle</name>
<desc>Angle of inner volume cone of 3D sound in degrees.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::coneInsideAngle</desc>
</field>
<field>
<name>coneOutsideAngle</name>
<desc>Angle of outer volume cone of 3D sound in degrees
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::coneOutsideAngle</desc>
</field>
<field>
<name>coneOutsideVolume</name>
<desc>Volume scale factor of outside of outer volume 3D sound cone.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::coneOutsideVolume</desc>
</field>
<field>
<name>fadeInTime</name>
<desc>Number of seconds to gradually fade in volume from zero when playback starts.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::fadeInTime</desc>
</field>
<field>
<name>fadeOutTime</name>
<desc>Number of seconds to gradually fade out volume down to zero when playback is stopped or paused.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::fadeOutTime</desc>
</field>
<field>
<name>fileName</name>
<desc>The sound file to play.
Use @b either this property @b or #track.  If both are assigned, #track takes precendence.  The primary purpose of this field is to avoid the need for the user to define SFXTrack datablocks for all sounds used in a level.</desc>
</field>
<field>
<name>is3D</name>
<desc>Whether to play #fileName as a positional (3D) sound or not.
If a #track is assigned, the value of this field is ignored.

@see SFXDescription::is3D</desc>
</field>
<field>
<name>isLooping</name>
<desc>Whether to play #fileName in an infinite loop.
If a #track is assigned, the value of this field is ignored.
@see SFXDescription::isLooping</desc>
</field>
<field>
<name>isStreaming</name>
<desc>Whether to use streamed playback for #fileName.
If a #track is assigned, the value of this field is ignored.
@see SFXDescription::isStreaming

@ref SFX_streaming</desc>
</field>
<field>
<name>maxDistance</name>
<desc>Distance at which to stop volume attenuation of the 3D sound.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::maxDistance</desc>
</field>
<field>
<name>pitch</name>
<desc>Pitch shift to apply to the sound.  Default is 1 = play at normal speed.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::pitch</desc>
</field>
<field>
<name>playOnAdd</name>
<desc>Whether playback of the emitter's sound should start as soon as the emitter object is added to the level.
If this is true, the emitter will immediately start to play when the level is loaded.</desc>
</field>
<field>
<name>referenceDistance</name>
<desc>Distance at which to start volume attenuation of the 3D sound.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::referenceDistance</desc>
</field>
<field>
<name>scatterDistance</name>
<desc>Bounds on random offset to apply to initial 3D sound position.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::scatterDistance</desc>
</field>
<field>
<name>sourceGroup</name>
<desc>The SFXSource to which to assign the sound of this emitter as a child.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::sourceGroup</desc>
</field>
<field>
<name>track</name>
<desc>The track which the emitter should play.
@note If assigned, this field will take precedence over a #fileName that may also be assigned to the emitter.</desc>
</field>
<field>
<name>useTrackDescriptionOnly</name>
<desc>If this is true, all fields except for #playOnAdd and #track are ignored on the emitter object.
This is useful to prevent fields in the #track's description from being overridden by emitter fields.</desc>
</field>
<field>
<name>volume</name>
<desc>Volume level to apply to the sound.
@note This field is ignored if #useTrackDescriptionOnly is true.

@see SFXDescription::volume</desc>
</field>
</class>
<class>
<name>SFXEmitterClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXEnvironment</name>
<base>SimDataBlock</base>
<field>
<name>airAbsorptionHF</name>
<desc>Change in level per meter at high frequencies.</desc>
</field>
<field>
<name>decayHFRatio</name>
<desc>High-frequency to mid-frequency decay time ratio.</desc>
</field>
<field>
<name>decayLFRatio</name>
<desc>Low-frequency to mid-frequency decay time ratio.</desc>
</field>
<field>
<name>decayTime</name>
<desc>Reverberation decay time at mid frequencies.</desc>
</field>
<field>
<name>density</name>
<desc>Value that controls the modal density in the late reverberation decay.</desc>
</field>
<field>
<name>diffusion</name>
<desc>Value that controls the echo density in the late reverberation decay.</desc>
</field>
<field>
<name>echoDepth</name>
<desc>Echo depth.</desc>
</field>
<field>
<name>echoTime</name>
<desc>Echo time.</desc>
</field>
<field>
<name>envDiffusion</name>
<desc>Environment diffusion.</desc>
</field>
<field>
<name>envSize</name>
<desc>Environment size in meters.</desc>
</field>
<field>
<name>flags</name>
<desc>A bitfield of reverb flags.
@see REVERB_DECAYTIMESCALE
@see REVERB_REFLECTIONSSCALE
@see REVERB_REFLECTIONSDELAYSCALE
@see REVERB_REVERBSCALE
@see REVERB_REVERBDELAYSCALE
@see REVERB_DECAYHFLIMIT
@see REVERB_ECHOTIMESCALE
@see REVERB_MODULATIONTIMESCALE
@see REVERB_CORE0
@see REVERB_CORE1
@see REVERB_HIGHQUALITYREVERB
@see REVERB_HIGHQUALITYDPL2REVERB</desc>
</field>
<field>
<name>HFReference</name>
<desc>Reference high frequency in Hertz.</desc>
</field>
<field>
<name>LFReference</name>
<desc>Reference low frequency in Hertz.</desc>
</field>
<field>
<name>modulationDepth</name>
<desc>Modulation depth.</desc>
</field>
<field>
<name>modulationTime</name>
<desc>Modulation time.</desc>
</field>
<field>
<name>reflections</name>
<desc>Early reflections level relative to room effect.</desc>
</field>
<field>
<name>reflectionsDelay</name>
<desc>Initial reflection delay time.</desc>
</field>
<field>
<name>reflectionsPan</name>
<desc>Early reflections panning vector.</desc>
</field>
<field>
<name>reverb</name>
<desc>Late reverberation level relative to room effect.</desc>
</field>
<field>
<name>reverbDelay</name>
<desc>Late reverberation delay time relative to initial reflection.</desc>
</field>
<field>
<name>reverbPan</name>
<desc>Late reverberation panning vector.</desc>
</field>
<field>
<name>room</name>
<desc>Room effect level at mid-frequencies.</desc>
</field>
<field>
<name>roomHF</name>
<desc>Relative room effect level at high frequencies.</desc>
</field>
<field>
<name>roomLF</name>
<desc>Relative room effect level at low frequencies.</desc>
</field>
<field>
<name>roomRolloffFactor</name>
<desc>Logarithmic distance attenuation rolloff scale factor for reverb room size effect.</desc>
</field>
</class>
<class>
<name>SFXEnvironmentClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXEnvironmentSet</name>
<base>SimSet</base>
</class>
<class>
<name>SFXFMODEvent</name>
<base>SFXTrack</base>
<field>
<name>fmodGroup</name>
<desc>DO NOT MODIFY!!</desc>
</field>
<field>
<name>fmodName</name>
<desc>DO NOT MODIFY!!</desc>
</field>
<field>
<name>fmodParameterRanges</name>
<desc>DO NOT MODIFY!!</desc>
</field>
<field>
<name>fmodParameterValues</name>
<desc>DO NOT MODIFY!!</desc>
</field>
</class>
<class>
<name>SFXFMODEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXFMODEventGroup</name>
<base>SimDataBlock</base>
<method>
<name>freeData</name>
<args>()</args>
<desc>Release the resource data for this group and its subgroups.

@see SFXFMODProject_resources</desc>
</method>
<method>
<name>isDataLoaded</name>
<args>()</args>
<desc>Test whether the resource data for this group has been loaded.

@return True if the resource data for this group is currently loaded.</desc>
</method>
<method>
<name>loadData</name>
<args>( bool loadStreams=true, bool loadSamples=true )</args>
<desc>Load the resource data for this group, if it has not already been loaded (either directly or indirectly through a parent group).
This method works recursively and thus data for direct and indirect child groups to this group will be loaded as well.

@param loadStreams Whether to open streams.
@param loadSamples Whether to load sample banks.
@return True if the data has been successfully loaded; false otherwise.

@see SFXFMODProject_resources</desc>
</method>
<field>
<name>fmodGroup</name>
<desc>DO NOT MODIFY!!</desc>
</field>
<field>
<name>fmodName</name>
<desc>DO NOT MODIFY!!</desc>
</field>
<field>
<name>fmodProject</name>
<desc>DO NOT MODIFY!!</desc>
</field>
</class>
<class>
<name>SFXFMODEventGroupClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXFMODEventSource</name>
<base>SFXSource</base>
</class>
<class>
<name>SFXFMODEventSourceClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXFMODProject</name>
<base>SimDataBlock</base>
<field>
<name>fileName</name>
<desc>The compiled .fev file from FMOD Designer.</desc>
</field>
<field>
<name>mediaPath</name>
<desc>Path to the media files; if unset, defaults to project directory.</desc>
</field>
</class>
<class>
<name>SFXFMODProjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXParameter</name>
<base>SimObject</base>
<method>
<name>getParameterName</name>
<args>()</args>
<desc>Get the name of the parameter.
@return The paramete name.</desc>
</method>
<method>
<name>reset</name>
<args>()</args>
<desc>Reset the parameter's value to its default.
@see SFXParameter::defaultValue</desc>
</method>
<field>
<name>channel</name>
<desc>Channel that the parameter controls.
This controls which property of the sources it is attached to the parameter controls.</desc>
</field>
<field>
<name>defaultValue</name>
<desc>Value to which the parameter is initially set.
When the parameter is first added to the system, #value will be set to #defaultValue.</desc>
</field>
<field>
<name>description</name>
<desc>Textual description of the parameter.
Primarily for use in the Audio Parameters dialog of the editor to allow for easier identification of parameters.</desc>
</field>
<field>
<name>onUpdate()</name>
<desc>Called when the sound system triggers an update on the parameter.
This occurs periodically during system operation.</desc>
</field>
<field>
<name>range</name>
<desc>Permitted range for #value.
Minimum and maximum allowed value for the parameter.  Both inclusive.

For all but the User0-3 channels, this property is automatically set up by SFXParameter.</desc>
</field>
<field>
<name>value</name>
<desc>Current value of the audio parameter.
All attached sources are notified when this value changes.</desc>
</field>
</class>
<class>
<name>SFXParameterClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXParameterGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>SFXPlayList</name>
<base>SFXTrack</base>
<field>
<name>delayTimeIn</name>
<desc>Seconds to wait after moving into slot before #transitionIn.</desc>
</field>
<field>
<name>delayTimeInVariance</name>
<desc>Bounds on randomization of #delayTimeIn.

@ref SFXPlayList_randomization</desc>
</field>
<field>
<name>delayTimeOut</name>
<desc>Seconds to wait before moving out of slot after #transitionOut.</desc>
</field>
<field>
<name>delayTimeOutVariance</name>
<desc>Bounds on randomization of #delayTimeOut.

@ref SFXPlayList_randomization</desc>
</field>
<field>
<name>fadeTimeIn</name>
<desc>Seconds to fade sound in (-1 to use the track's own fadeInTime.)
@see SFXDescription::fadeTimeIn</desc>
</field>
<field>
<name>fadeTimeInVariance</name>
<desc>Bounds on randomization of #fadeInTime.

@ref SFXPlayList_randomization</desc>
</field>
<field>
<name>fadeTimeOut</name>
<desc>Seconds to fade sound out (-1 to use the track's own fadeOutTime.)
@see SFXDescription::fadeTimeOut</desc>
</field>
<field>
<name>fadeTimeOutVariance</name>
<desc>Bounds on randomization of #fadeOutTime

@ref SFXPlayList_randomization</desc>
</field>
<field>
<name>loopMode</name>
<desc>Behavior when description has looping enabled.
The loop mode determines whether the list will loop over a single slot or loop over all the entire list of slots being played.

@see SFXDescription::isLooping</desc>
</field>
<field>
<name>maxDistance</name>
<desc>@c maxDistance to apply to 3D sounds in this slot (&lt;1 to use @c maxDistance of track's own description).
@see SFXDescription::maxDistance</desc>
</field>
<field>
<name>maxDistanceVariance</name>
<desc>Bounds on randomization of #maxDistance.

@ref SFXPlayList_randomization</desc>
</field>
<field>
<name>numSlotsToPlay</name>
<desc>Number of slots to play.
Up to a maximum of 16, this field determines the number of slots that are taken from the list for playback.  Only slots that have a valid #track assigned will be considered for this.</desc>
</field>
<field>
<name>pitchScale</name>
<desc>Scale factor to apply to pitch of sounds played on this list slot.
This value will scale the actual pitch set on the track assigned to the slot, i.e. a value of 0.5 will cause the track to play at half its assigned speed.</desc>
</field>
<field>
<name>pitchScaleVariance</name>
<desc>Bounds on randomization of #pitchScale.

@ref SFXPlayList_randomization</desc>
</field>
<field>
<name>random</name>
<desc>Slot playback order randomization pattern.
By setting this field to something other than "NotRandom" to order in which slots of the playlist are processed can be changed from sequential to a random pattern.  This allows to to create more varied playback patterns.
Defaults to "NotRandom".</desc>
</field>
<field>
<name>referenceDistance</name>
<desc>@c referenceDistance to set for 3D sounds in this slot (&lt;1 to use @c referenceDistance of track's own description).
@see SFXDescription::referenceDistance</desc>
</field>
<field>
<name>referenceDistanceVariance</name>
<desc>Bounds on randomization of #referenceDistance.

@ref SFXPlayList_randomization</desc>
</field>
<field>
<name>repeatCount</name>
<desc>Number of times to loop this slot.</desc>
</field>
<field>
<name>replay</name>
<desc>Behavior when an already playing sound is encountered on this slot from a previous cycle.
Each slot can have an arbitrary number of sounds playing on it from previous cycles.  This field determines how SFXController will handle these sources.</desc>
</field>
<field>
<name>state</name>
<desc>State that must be active for this slot to play.

@ref SFXPlayList_states</desc>
</field>
<field>
<name>stateMode</name>
<desc>Behavior when assigned state is deactivated while slot is playing.

@ref SFXPlayList_states</desc>
</field>
<field>
<name>trace</name>
<desc>Enable/disable execution tracing for this playlist (local only).
If this is true, SFXControllers attached to the list will automatically run in trace mode.</desc>
</field>
<field>
<name>track</name>
<desc>Track to play in this slot.
This must be set for the slot to be considered for playback.  Other settings for a slot will not take effect except this field is set.</desc>
</field>
<field>
<name>transitionIn</name>
<desc>Behavior when moving into this slot.
After the delayIn time has expired (if any), this slot determines what the controller will do before actually playing the slot.</desc>
</field>
<field>
<name>transitionOut</name>
<desc>Behavior when moving out of this slot.
After the #detailTimeOut has expired (if any), this slot determines what the controller will do before moving on to the next slot.</desc>
</field>
<field>
<name>volumeScale</name>
<desc>Scale factor to apply to volume of sounds played on this list slot.
This value will scale the actual volume level set on the track assigned to the slot, i.e. a value of 0.5 will cause the track to play at half-volume.</desc>
</field>
<field>
<name>volumeScaleVariance</name>
<desc>Bounds on randomization of #volumeScale.

@ref SFXPlayList_randomization</desc>
</field>
</class>
<class>
<name>SFXPlayListClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXProfile</name>
<base>SFXTrack</base>
<method>
<name>getSoundDuration</name>
<args>()</args>
<desc>Return the length of the sound data in seconds.

@return The length of the sound data in seconds or 0 if the sound referenced by the profile could not be found.</desc>
</method>
<field>
<name>fileName</name>
<desc>%Path to the sound file.
If the extension is left out, it will be inferred by the sound system.  This allows to easily switch the sound format without having to go through the profiles and change the filenames there, too.</desc>
</field>
<field>
<name>preload</name>
<desc>Whether to preload sound data when the profile is added to system.
@note This flag is ignored by streamed sounds.

@ref SFXProfile_loading</desc>
</field>
</class>
<class>
<name>SFXProfileClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXSound</name>
<base>SFXSource</base>
<method>
<name>getDuration</name>
<args>()</args>
<desc>Get the total play time (in seconds) of the sound data attached to the sound.
@return

@note Be aware that for looped sounds, this will not return the total playback time of the sound.</desc>
</method>
<method>
<name>getPosition</name>
<args>()</args>
<desc>Get the current playback position in seconds.
@return The current play cursor offset.</desc>
</method>
<method>
<name>isReady</name>
<args>()</args>
<desc>Test whether the sound data associated with the sound has been fully loaded and is ready for playback.
For streamed sounds, this will be false during playback when the stream queue for the sound is starved and waiting for data.  For buffered sounds, only an initial loading phase will potentially cause isReady to return false.

@return True if the sound is ready for playback.</desc>
</method>
<method>
<name>setPosition</name>
<args>( float position )</args>
<desc>Set the current playback position in seconds.
If the source is currently playing, playback will jump to the new position.  If playback is stopped or paused, playback will resume at the given position when play() is called.

@param position The new position of the play cursor (in seconds).</desc>
</method>
</class>
<class>
<name>SFXSoundClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXSource</name>
<base>SimGroup</base>
<method>
<name>addMarker</name>
<args>( String name, float pos )</args>
<desc>Add a notification marker called @a name at @a pos seconds of playback.

@param name Symbolic name for the marker that will be passed to the onMarkerPassed() callback.
@param pos Playback position in seconds when the notification should trigger.  Note that this is a soft limit and there may be a delay between the play cursor actually passing the position and the callback being triggered.

@note For looped sounds, the marker will trigger on each iteration.

@tsexample
// Create a new source.
$source = sfxCreateSource( AudioMusicLoop2D, "art/sound/backgroundMusic" );

// Assign a class to the source.
$source.class = "BackgroundMusic";

// Add a playback marker at one minute into playback.
$source.addMarker( "first", 60 );

// Define the callback function.  This function will be called when the playback position passes the one minute mark.
function BackgroundMusic::onMarkerPassed( %this, %markerName )
{
if( %markerName $= "first" )
echo( "Playback has passed the 60 seconds mark." );
}

// Play the sound.
$source.play();
@endtsexample</desc>
</method>
<method>
<name>addParameter</name>
<args>( SFXParameter parameter )</args>
<desc>Attach @a parameter to the source,

Once attached, the source will react to value changes of the given @a parameter.  Attaching a parameter will also trigger an initial read-out of the parameter's current value.

@param parameter The parameter to attach to the source.</desc>
</method>
<method>
<name>getAttenuatedVolume</name>
<args>()</args>
<desc>Get the final effective volume level of the source.

This method returns the volume level as it is after source group volume modulation, fades, and distance-based volume attenuation have been applied to the base volume level.

@return The effective volume of the source.

@ref SFXSource_volume</desc>
</method>
<method>
<name>getFadeInTime</name>
<args>()</args>
<desc>Get the fade-in time set on the source.
This will initially be SFXDescription::fadeInTime.

@return The fade-in time set on the source in seconds.

@see SFXDescription::fadeInTime

@ref SFXSource_fades</desc>
</method>
<method>
<name>getFadeOutTime</name>
<args>()</args>
<desc>Get the fade-out time set on the source.
This will initially be SFXDescription::fadeOutTime.

@return The fade-out time set on the source in seconds.

@see SFXDescription::fadeOutTime

@ref SFXSource_fades</desc>
</method>
<method>
<name>getParameter</name>
<args>( int index )</args>
<desc>Get the parameter at the given index.
@param index Index of the parameter to fetch.  Must be 0&lt;=index&lt;=getParameterCount().
@return The parameter at the given @a index or null if @a index is out of range.

@tsexample
// Print the name ofo each parameter attached to %source.
%numParams = %source.getParameterCount();
for( %i = 0; %i &lt; %numParams; %i ++ )
echo( %source.getParameter( %i ).getParameterName() );
@endtsexample

@see getParameterCount</desc>
</method>
<method>
<name>getParameterCount</name>
<args>()</args>
<desc>Get the number of SFXParameters that are attached to the source.
@return The number of parameters attached to the source.

@tsexample
// Print the name ofo each parameter attached to %source.
%numParams = %source.getParameterCount();
for( %i = 0; %i &lt; %numParams; %i ++ )
echo( %source.getParameter( %i ).getParameterName() );
@endtsexample

@see getParameter
@see addParameter</desc>
</method>
<method>
<name>getPitch</name>
<args>()</args>
<desc>Get the pitch scale of the source.
Pitch determines the playback speed of the source (default: 1).

@return The current pitch scale factor of the source.

@see setPitch
@see SFXDescription::pitch</desc>
</method>
<method>
<name>getStatus</name>
<args>()</args>
<desc>Get the current playback status.
@return Te current playback status</desc>
</method>
<method>
<name>getVolume</name>
<args>()</args>
<desc>Get the current base volume level of the source.
This is not the final effective volume that the source is playing at but rather the starting volume level before source group modulation, fades, or distance-based volume attenuation are applied.

@return The current base volume level.

@see setVolume
@see SFXDescription::volume

@ref SFXSource_volume</desc>
</method>
<method>
<name>isPaused</name>
<args>()</args>
<desc>Test whether the source is currently paused.
@return True if the source is in paused state, false otherwise.

@see pause
@see getStatus
@see SFXStatus</desc>
</method>
<method>
<name>isPlaying</name>
<args>()</args>
<desc>Test whether the source is currently playing.
@return True if the source is in playing state, false otherwise.

@see play
@see getStatus
@see SFXStatus</desc>
</method>
<method>
<name>isStopped</name>
<args>()</args>
<desc>Test whether the source is currently stopped.
@return True if the source is in stopped state, false otherwise.

@see stop
@see getStatus
@see SFXStatus</desc>
</method>
<method>
<name>pause</name>
<args>( float fadeOutTime=-1.f )</args>
<desc>Pause playback of the source.
@param fadeOutTime Seconds for the sound to fade down to zero volume.  If -1, the SFXDescription::fadeOutTime set in the source's associated description is used.  Pass 0 to disable a fade-out effect that may be configured on the description.
Be aware that if a fade-out effect is used, the source will not immediately to paused state but will rather remain in playing state until the fade-out time has expired..</desc>
</method>
<method>
<name>play</name>
<args>( float fadeInTime=-1.f )</args>
<desc>Start playback of the source.
If the sound data for the source has not yet been fully loaded, there will be a delay after calling play and playback will start after the data has become available.

@param fadeInTime Seconds for the sound to reach full volume.  If -1, the SFXDescription::fadeInTime set in the source's associated description is used.  Pass 0 to disable a fade-in effect that may be configured on the description.</desc>
</method>
<method>
<name>removeParameter</name>
<args>( SFXParameter parameter )</args>
<desc>Detach @a parameter from the source.

Once detached, the source will no longer react to value changes of the given @a parameter.

If the parameter is not attached to the source, the method will do nothing.

@param parameter The parameter to detach from the source.</desc>
</method>
<method>
<name>setCone</name>
<args>( float innerAngle, float outerAngle, float outsideVolume )</args>
<desc>Set up the 3D volume cone for the source.

@param innerAngle Angle of the inner sound cone in degrees (@ref SFXDescription::coneInsideAngle).  Must be 0&lt;=innerAngle&lt;=360.
@param outerAngle Angle of the outer sound cone in degrees (@ref SFXDescription::coneOutsideAngle).  Must be 0&lt;=outerAngle&lt;=360.
@param outsideVolume Volume scale factor outside of outer cone (@ref SFXDescription::coneOutsideVolume).  Must be 0&lt;=outsideVolume&lt;=1.
@note This method has no effect on the source if the source is not 3D.</desc>
</method>
<method>
<name>setFadeTimes</name>
<args>( float fadeInTime, float fadeOutTime )</args>
<desc>Set the fade time parameters of the source.
@param fadeInTime The new fade-in time in seconds.
@param fadeOutTime The new fade-out time in seconds.

@see SFXDescription::fadeInTime
@see SFXDescription::fadeOutTime

@ref SFXSource_fades</desc>
</method>
<method>
<name>setPitch</name>
<args>( float pitch )</args>
<desc>Set the pitch scale of the source.
Pitch determines the playback speed of the source (default: 1).

@param pitch The new pitch scale factor.

@see getPitch
@see SFXDescription::pitch</desc>
</method>
<method>
<name>setTransform</name>
<args>( vector position [, vector direction ] )</args>
<desc>Set the position and orientation of a 3D sound source.
@hide</desc>
</method>
<method>
<name>setVolume</name>
<args>( float volume )</args>
<desc>Set the base volume level for the source.
This volume will be the starting point for source group volume modulation, fades, and distance-based volume attenuation.

@param volume The new base volume level for the source.  Must be 0&gt;=volume&lt;=1.

@see getVolume

@ref SFXSource_volume</desc>
</method>
<method>
<name>stop</name>
<args>( float fadeOutTime=-1.f )</args>
<desc>Stop playback of the source.
@param fadeOutTime Seconds for the sound to fade down to zero volume.  If -1, the SFXDescription::fadeOutTime set in the source's associated description is used.  Pass 0 to disable a fade-out effect that may be configured on the description.
Be aware that if a fade-out effect is used, the source will not immediately transtion to stopped state but will rather remain in playing state until the fade-out time has expired.</desc>
</method>
<field>
<name>description</name>
<desc>The playback configuration that determines the initial sound properties and setup.
Any SFXSource must have an associated SFXDescription.</desc>
</field>
<field>
<name>onParameterValueChange( SFXParameter parameter )</name>
<desc>Called when a parameter attached to the source changes value.
This callback will be triggered before the value change has actually been applied to the source.
@param parameter The parameter that has changed value.
@note This is also triggered when the parameter is first attached to the source.</desc>
</field>
<field>
<name>onStatusChange( SFXStatus newStatus )</name>
<desc>Called when the playback status of the source changes.
@param newStatus The new playback status.</desc>
</field>
<field>
<name>statusCallback</name>
<desc>Name of function to call when the status of the source changes.

The source that had its status changed is passed as the first argument to the function and the new status of the source is passed as the second argument.</desc>
</field>
</class>
<class>
<name>SFXSourceClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXSourceSet</name>
<base>SimSet</base>
</class>
<class>
<name>SFXState</name>
<base>SimDataBlock</base>
<method>
<name>activate</name>
<args>()</args>
<desc>Increase the activation count on the state.
If the state isn't already active and it is not disabled, the state will be activated.
@see isActive
@see deactivate</desc>
</method>
<method>
<name>deactivate</name>
<args>()</args>
<desc>Decrease the activation count on the state.
If the count reaches zero and the state was not disabled, the state will be deactivated.
@see isActive
@see activate</desc>
</method>
<method>
<name>disable</name>
<args>()</args>
<desc>Increase the disabling count of the state.
If the state is currently active, it will be deactivated.
@see isDisabled</desc>
</method>
<method>
<name>enable</name>
<args>()</args>
<desc>Decrease the disabling count of the state.
If the disabling count reaches zero while the activation count is still non-zero, the state will be reactivated again.
@see isDisabled</desc>
</method>
<method>
<name>isActive</name>
<args>()</args>
<desc>Test whether the state is currently active.
This is true when the activation count is &gt;0 and the disabling count is =0.
@return True if the state is currently active.
@see activate</desc>
</method>
<method>
<name>isDisabled</name>
<args>()</args>
<desc>Test whether the state is currently disabled.
This is true when the disabling count of the state is non-zero.
@return True if the state is disabled.

@see disable</desc>
</method>
<field>
<name>excludedStates</name>
<desc>States that will automatically be disabled when this state is activated.

@ref SFXState_activation</desc>
</field>
<field>
<name>includedStates</name>
<desc>States that will automatically be activated when this state is activated.

@ref SFXState_activation</desc>
</field>
<field>
<name>onActivate()</name>
<desc>Called when the state goes from inactive to active.</desc>
</field>
<field>
<name>onDeactivate()</name>
<desc>called when the state goes from active to deactive.</desc>
</field>
</class>
<class>
<name>SFXStateClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXStateSet</name>
<base>SimSet</base>
</class>
<class>
<name>SFXTrack</name>
<base>SimDataBlock</base>
<field>
<name>description</name>
<desc>Playback setup description for this track.

If unassigned, the description named "AudioEffects" will automatically be assigned to the track.  If this description is not defined, track creation will fail.</desc>
</field>
<field>
<name>parameters</name>
<desc>Parameters to automatically attach to SFXSources created from this track.
Individual parameters are identified by their #internalName.</desc>
</field>
</class>
<class>
<name>SFXTrackClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SFXTrackSet</name>
<base>SimSet</base>
</class>
<class>
<name>sgMissionLightingFilterSet</name>
<base>SimSet</base>
</class>
<class>
<name>ShaderData</name>
<base>SimObject</base>
<method>
<name>reload</name>
<args>()</args>
<desc>@brief Rebuilds all the vertex and pixel shaders instances created from this ShaderData.

@tsexample
// Rebuild the shader instances from ShaderData CloudLayerShader
CloudLayerShader.reload();
@endtsexample</desc>
</method>
<field>
<name>defines</name>
<desc>A semicolon, tab, or newline delimited string of case sensitive defines that are passed to the shader compiler</desc>
</field>
<field>
<name>DXPixelShaderFile</name>
<desc>Indicates a filename that contains a DirectX pixel shader program.

It must contain only one program and no vertex shader, just the pixel shader. It can be either an HLSL or assembly level shader. The former must have a filename extension of .hlsl, otherwise it assumes it is an assembly file.</desc>
</field>
<field>
<name>DXVertexShaderFile</name>
<desc>Indicates a filename that contains a DirectX vertex shader program.

It must contain only one program and no pixel shader, just the vertex shader.It can be either an HLSL or assembly level shader. The former must have a filename extension of .hlsl, otherwise it assumes it is an assembly file.</desc>
</field>
<field>
<name>OGLPixelShaderFile</name>
<desc>Indicates a filename that contains a DirectX pixel shader program.

It must contain only one program and no vertex shader, just the pixel shader.</desc>
</field>
<field>
<name>OGLVertexShaderFile</name>
<desc>Indicates a filename that contains an OpenGL vertex shader program.

It must contain only one program and no pixel shader, just the vertex shader.</desc>
</field>
<field>
<name>pixVersion</name>
<desc>This indicates what target level of shader should be compiled.

Valid numbers at the time of this writing are 1.1, 1.4, 2.0, and 3.0. The shader will not run properly if your hardware does not support the level of shader you have compiled.</desc>
</field>
<field>
<name>useDevicePixVersion</name>
<desc>True to use the maximum pixel shader version offered by the graphics card, rather than manually specifying the version in script.</desc>
</field>
</class>
<class>
<name>ShaderDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ShapeBase</name>
<base>GameBase</base>
<method>
<name>applyDamage</name>
<args>( float amount )</args>
<desc>Increment the current damage level by the specified amount.
@param amount value to add to current damage level</desc>
</method>
<method>
<name>applyImpulse</name>
<args>( Point3F pos, Point3F vec )</args>
<desc>Apply an impulse to the object.
@param pos world position of the impulse
@param vec impulse momentum (velocity * mass)
@return true</desc>
</method>
<method>
<name>applyRepair</name>
<args>( float amount )</args>
<desc>Repair damage by the specified amount.
Note that the damage level is only reduced by repairRate per tick, so it may take several ticks for the total repair to complete.
@param amount total repair value (subtracted from damage level over time)</desc>
</method>
<method>
<name>canCloak</name>
<args>()</args>
<desc>Check if this object can cloak.
@return true</desc>
</method>
<method>
<name>changeMaterial</name>
<args>( string mapTo, Material oldMat, Material newMat )</args>
<desc>Change one of the materials on the shape.
This method changes materials per mapTo with others. The material that is being replaced is mapped to unmapped_mat as a part of this transition.
@note Warning, right now this only sort of works. It doesn't do a live update like it should.
@param mapTo the name of the material target to remap (from getTargetName)
@param oldMat the old Material that was mapped
@param newMat the new Material to map

@tsexample
// remap the first material in the shape
%mapTo = %obj.getTargetName( 0 );
%obj.changeMaterial( %mapTo, 0, MyMaterial );
@endtsexample</desc>
</method>
<method>
<name>dumpMeshVisibility</name>
<args>()</args>
<desc>Print a list of visible and hidden meshes in the shape to the console for debugging purposes.</desc>
</method>
<method>
<name>getAIRepairPoint</name>
<args>()</args>
<desc>Get the position at which the AI should stand to repair things.
If the shape defines a node called "AIRepairNode", this method will return the current world position of that node, otherwise "0 0 0".
@return the AI repair position</desc>
</method>
<method>
<name>getCameraFov</name>
<args>()</args>
<desc>Returns the vertical field of view in degrees for this object if used as a camera.
@return current FOV</desc>
</method>
<method>
<name>getControllingClient</name>
<args>()</args>
<desc>Get the client (if any) that controls this object.
@return the ID of the controlling GameConnection, or 0 if this object is not controlled by any client.</desc>
</method>
<method>
<name>getControllingObject</name>
<args>()</args>
<desc>Get the object (if any) that controls this object.
@return the ID of the controlling ShapeBase object, or 0 if this object is not controlled by another object.</desc>
</method>
<method>
<name>getDamageFlash</name>
<args>()</args>
<desc>Get the damage flash level.
@return flash level
@see setDamageFlash</desc>
</method>
<method>
<name>getDamageLevel</name>
<args>()</args>
<desc>Get the object's current damage level.
@return damage level</desc>
</method>
<method>
<name>getDamagePercent</name>
<args>()</args>
<desc>Get the object's current damage level as a percentage of maxDamage.
@return damageLevel / datablock.maxDamage</desc>
</method>
<method>
<name>getDamageState</name>
<args>()</args>
<desc>Get the object's damage state.
@return the damage state; one of "Enabled", "Disabled", "Destroyed"</desc>
</method>
<method>
<name>getEnergyLevel</name>
<args>()</args>
<desc>Get the object's current energy level.
@return energy level</desc>
</method>
<method>
<name>getEnergyPercent</name>
<args>()</args>
<desc>Get the object's current energy level as a percentage of maxEnergy.
@return energyLevel / datablock.maxEnergy</desc>
</method>
<method>
<name>getEyePoint</name>
<args>()</args>
<desc>Get the position of the 'eye' for this object.
If the object model has a node called 'eye', this method will return that node's current world position, otherwise it will return the object's current world position.
@return the eye position for this object
@see getEyeVector
@see getEyeTransform</desc>
</method>
<method>
<name>getEyeTransform</name>
<args>()</args>
<desc>Get the 'eye' transform for this object.
If the object model has a node called 'eye', this method will return that node's current transform, otherwise it will return the object's current transform.
@return the eye transform for this object
@see getEyeVector
@see getEyePoint</desc>
</method>
<method>
<name>getEyeVector</name>
<args>()</args>
<desc>Get the forward direction of the 'eye' for this object.
If the object model has a node called 'eye', this method will return that node's current forward direction vector, otherwise it will return the object's current forward direction vector.
@return the eye vector for this object
@see getEyePoint
@see getEyeTransform</desc>
</method>
<method>
<name>getImageAltTrigger</name>
<args>( int slot )</args>
<desc>Get the alt trigger state of the Image mounted in the specified slot.
@param slot Image slot to query
@return the Image's current alt trigger state</desc>
</method>
<method>
<name>getImageAmmo</name>
<args>( int slot )</args>
<desc>Get the ammo state of the Image mounted in the specified slot.
@param slot Image slot to query
@return the Image's current ammo state</desc>
</method>
<method>
<name>getImageLoaded</name>
<args>( int slot )</args>
<desc>Get the loaded state of the Image mounted in the specified slot.
@param slot Image slot to query
@return the Image's current loaded state</desc>
</method>
<method>
<name>getImageSkinTag</name>
<args>( int slot )</args>
<desc>Get the skin tag ID for the Image mounted in the specified slot.
@param slot Image slot to query
@return the skinTag value passed to mountImage when the image was mounted)</desc>
</method>
<method>
<name>getImageState</name>
<args>( int slot )</args>
<desc>Get the name of the current state of the Image in the specified slot.
@param slot Image slot to query
@return name of the current Image state, or "Error" if slot is invalid</desc>
</method>
<method>
<name>getImageTrigger</name>
<args>( int slot )</args>
<desc>Get the trigger state of the Image mounted in the specified slot.
@param slot Image slot to query
@return the Image's current trigger state</desc>
</method>
<method>
<name>getLookAtPoint</name>
<args>( float distance=2000, int typeMask=0xFFFFFFFF )</args>
<desc>Get the world position this object is looking at.
Casts a ray from the eye and returns information about what the ray hits.
@param distance maximum distance of the raycast
@param typeMask typeMask of objects to include for raycast collision testing
@return look-at information as "Object HitX HitY HitZ [Material]" or empty string for no hit

@tsexample
%lookat = %obj.getLookAtPoint();
echo( "Looking at: " @ getWords( %lookat, 1, 3 ) );
@endtsexample</desc>
</method>
<method>
<name>getModelFile</name>
<args>()</args>
<desc>Get the model filename used by this shape.
@return the shape filename</desc>
</method>
<method>
<name>getMountedImage</name>
<args>( int slot )</args>
<desc>Get the Image mounted in the specified slot.
@param slot Image slot to query
@return ID of the ShapeBaseImageData datablock mounted in the slot, or 0 if no Image is mounted there.</desc>
</method>
<method>
<name>getMountSlot</name>
<args>( ShapeBaseImageData image )</args>
<desc>Get the first slot the given datablock is mounted to on this object.
@param image ShapeBaseImageData datablock to query
@return index of the first slot the Image is mounted in, or -1 if the Image is not mounted in any slot on this object.</desc>
</method>
<method>
<name>getMuzzlePoint</name>
<args>( int slot )</args>
<desc>Get the muzzle position of the Image mounted in the specified slot.
If the Image shape contains a node called 'muzzlePoint', then the muzzle position is the position of that node in world space. If no such node is specified, the slot's mount node is used instead.
@param slot Image slot to query
@return the muzzle position, or "0 0 0" if the slot is invalid</desc>
</method>
<method>
<name>getMuzzleVector</name>
<args>( int slot )</args>
<desc>Get the muzzle vector of the Image mounted in the specified slot.
If the Image shape contains a node called 'muzzlePoint', then the muzzle vector is the forward direction vector of that node's transform in world space. If no such node is specified, the slot's mount node is used instead.

If the correctMuzzleVector and firstPerson flags are set in the Image, the muzzle vector is computed to point at whatever object is right in front of the object's 'eye' node.
@param slot Image slot to query
@return the muzzle vector, or "0 1 0" if the slot is invalid</desc>
</method>
<method>
<name>getPendingImage</name>
<args>( int slot )</args>
<desc>Get the Image that will be mounted next in the specified slot.
Calling mountImage when an Image is already mounted does one of two things: &lt;ol&gt;&lt;li&gt;Mount the new Image immediately, the old Image is discarded and whatever state it was in is ignored.&lt;/li&gt;&lt;li&gt;If the current Image state does not allow Image changes, the new Image is marked as pending, and will not be mounted until the current state completes. eg. if the user changes weapons, you may wish to ensure that the current weapon firing state plays to completion first.&lt;/li&gt;&lt;/ol&gt;
This command retrieves the ID of the pending Image (2nd case above).
@param slot Image slot to query
@return ID of the pending ShapeBaseImageData datablock, or 0 if none.</desc>
</method>
<method>
<name>getRechargeRate</name>
<args>()</args>
<desc>Get the current recharge rate.
@return the recharge rate (per tick)</desc>
</method>
<method>
<name>getRepairRate</name>
<args>()</args>
<desc>Get the per-tick repair amount.
@return the current value to be subtracted from damage level each tick
@see setRepairRate</desc>
</method>
<method>
<name>getShapeName</name>
<args>()</args>
<desc>Get the name of the shape.
@note This is the name of the shape object that is sent to the client, not the DTS or DAE model filename.
@return the name of the shape</desc>
</method>
<method>
<name>getSkinName</name>
<args>()</args>
<desc>Get the name of the skin applied to this shape.
@return the name of the skin</desc>
</method>
<method>
<name>getSlotTransform</name>
<args>( int slot )</args>
<desc>Get the transform of the specified mount slot.
@param slot Image slot to query
@return the mount transform</desc>
</method>
<method>
<name>getStopThreadPos</name>
<args>(int slot)</args>
</method>
<method>
<name>getTargetCount</name>
<args>()</args>
<desc>Get the number of materials in the shape.
@return the number of materials in the shape.</desc>
</method>
<method>
<name>getTargetName</name>
<args>( int index )</args>
<desc>Get the name of the indexed shape material.
@param index index of the material to get (valid range is 0 - getTargetCount()-1).
@return the name of the indexed material.</desc>
</method>
<method>
<name>getThreadDir</name>
<args>(int slot)</args>
</method>
<method>
<name>getThreadPos</name>
<args>(int slot)</args>
</method>
<method>
<name>getThreadSequence</name>
<args>(int slot)</args>
</method>
<method>
<name>getThreadSequenceName</name>
<args>(int slot)</args>
</method>
<method>
<name>getThreadSpeed</name>
<args>(int slot)</args>
</method>
<method>
<name>getThreadStartPos</name>
<args>(int slot)</args>
</method>
<method>
<name>getThreadState</name>
<args>(int slot)</args>
</method>
<method>
<name>getVelocity</name>
<args>()</args>
<desc>Get the object's current velocity.
@return the current velocity</desc>
</method>
<method>
<name>getWhiteOut</name>
<args>()</args>
<desc>Get the white-out level.
@return white-out level
@see setWhiteOut</desc>
</method>
<method>
<name>isCloaked</name>
<args>()</args>
<desc>Check if this object is cloaked.
@return true if cloaked, false if not</desc>
</method>
<method>
<name>isDestroyed</name>
<args>()</args>
<desc>Check if the object is in the Destroyed damage state.
@return true if damage state is "Destroyed", false if not</desc>
</method>
<method>
<name>isDisabled</name>
<args>()</args>
<desc>Check if the object is in the Disabled or Destroyed damage state.
@return true if damage state is not "Enabled", false if it is</desc>
</method>
<method>
<name>isEnabled</name>
<args>()</args>
<desc>Check if the object is in the Enabled damage state.
@return true if damage state is "Enabled", false if not</desc>
</method>
<method>
<name>isHidden</name>
<args>()</args>
<desc>Check if the object is hidden.
@return true if the object is hidden, false if visible.</desc>
</method>
<method>
<name>isImageFiring</name>
<args>( int slot )</args>
<desc>Check if the current Image state is firing.
@param slot Image slot to query
@return true if the current Image state in this slot has the 'stateFire' flag set.</desc>
</method>
<method>
<name>isImageMounted</name>
<args>( ShapeBaseImageData image )</args>
<desc>Check if the given datablock is mounted to any slot on this object.
@param image ShapeBaseImageData datablock to query
@return true if the Image is mounted to any slot, false otherwise.</desc>
</method>
<method>
<name>mountImage</name>
<args>( ShapeBaseImageData image, int slot, bool loaded=true, string skinTag="" )</args>
<desc>Mount a new Image.
@param image the Image to mount
@param slot Image slot to mount into (valid range is 0 - 3)
@param loaded initial loaded state for the Image
@param skinTag tagged string to reskin the mounted Image
@return true if successful, false if failed

@tsexample
%player.mountImage( PistolImage, 1 );
%player.mountImage( CrossbowImage, 0, false );
%player.mountImage( RocketLauncherImage, 0, true, 'blue' );
@endtsexample</desc>
</method>
<method>
<name>pauseThread</name>
<args>( int slot )</args>
<desc>Pause an animation thread.
If restarted using playThread, the animation will resume from the paused position.
@param slot thread slot to stop
@return true if successful, false if failed

@see playThread</desc>
</method>
<method>
<name>playAudio</name>
<args>( int slot, SFXTrack track )</args>
<desc>Attach a sound to this shape and start playing it.
@param slot audio slot index for the sound (valid range is 0 - 3)
@param track SFXTrack to play
@return true if the sound was attached successfully, false if failed</desc>
</method>
<method>
<name>playThread</name>
<args>( int slot, string name="" )</args>
<desc>Start a new animation thread, or restart one that has been paused or stopped.
@param slot thread slot to play. Valid range is 0 - 3)
@param name name of the animation sequence to play in this slot. If not specified, the paused or stopped thread in this slot will be resumed.
@return true if successful, false if failed

@tsexample
%obj.playThread( 0, "ambient" );      // Play the ambient sequence in slot 0
%obj.setThreadTimeScale( 0, 0.5 );    // Play at half-speed
%obj.pauseThread( 0 );                // Pause the sequence
%obj.playThread( 0 );                 // Resume playback
%obj.playThread( 0, "spin" );         // Replace the sequence in slot 0
@endtsexample</desc>
</method>
<method>
<name>replayThread</name>
<args>(int slot, [float forcePos] )</args>
</method>
<method>
<name>setAllMeshesHidden</name>
<args>( bool hide )</args>
<desc>Set the hidden state on all the shape meshes.
@param hide new hidden state for all meshes</desc>
</method>
<method>
<name>setCameraFov</name>
<args>( float fov )</args>
<desc>Set the vertical field of view in degrees for this object if used as a camera.
@param fov new FOV value</desc>
</method>
<method>
<name>setCloaked</name>
<args>( bool cloak )</args>
<desc>Set the cloaked state of this object.
When an object is cloaked it is not rendered.
@param cloak true to cloak the object, false to uncloak</desc>
</method>
<method>
<name>setDamageFlash</name>
<args>( float level )</args>
<desc>Set the damage flash level.
Damage flash may be used as a postfx effect to flash the screen when the client is damaged.
@note Currently not implemented.
@param level flash level (0-1)</desc>
</method>
<method>
<name>setDamageLevel</name>
<args>( float level )</args>
<desc>Set the object's current damage level.
@param level new damage level</desc>
</method>
<method>
<name>setDamageState</name>
<args>( string state )</args>
<desc>Set the object's damage state.
@param state should be one of "Enabled", "Disabled", "Destroyed"
@return true if successful, false if failed</desc>
</method>
<method>
<name>setDamageVector</name>
<args>( Point3F vec )</args>
<desc>Set the damage direction vector.
Currently this is only used to initialise the explosion if this object is blown up.
@param vec damage direction vector

@tsexample
%obj.setDamageVector( "0 0 1" );
@endtsexample</desc>
</method>
<method>
<name>setEnergyLevel</name>
<args>( float level )</args>
<desc>Set this object's current energy level.
@param level new energy level</desc>
</method>
<method>
<name>setHidden</name>
<args>( bool show )</args>
<desc>Add or remove this object from the scene.
When removed from the scene, the object will not be processed or rendered.
@param show false to hide the object, true to re-show it</desc>
</method>
<method>
<name>setImageAltTrigger</name>
<args>( int slot, bool state )</args>
<desc>Set the alt trigger state of the Image mounted in the specified slot.
@param slot Image slot to modify
@param state new alt trigger state for the Image
@return the Image's new alt trigger state</desc>
</method>
<method>
<name>setImageAmmo</name>
<args>( int slot, bool state )</args>
<desc>Set the ammo state of the Image mounted in the specified slot.
@param slot Image slot to modify
@param state new ammo state for the Image
@return the Image's new ammo state</desc>
</method>
<method>
<name>setImageLoaded</name>
<args>( int slot, bool state )</args>
<desc>Set the loaded state of the Image mounted in the specified slot.
@param slot Image slot to modify
@param state new loaded state for the Image
@return the Image's new loaded state</desc>
</method>
<method>
<name>setImageTrigger</name>
<args>( int slot, bool state )</args>
<desc>Set the trigger state of the Image mounted in the specified slot.
@param slot Image slot to modify
@param state new trigger state for the Image
@return the Image's new trigger state</desc>
</method>
<method>
<name>setInvincibleMode</name>
<args>( float time, float speed )</args>
<desc>Setup the invincible effect.
This effect is used for HUD feedback to the user that they are invincible.
@note Currently not implemented
@param time duration in seconds for the invincible effect
@param speed speed at which the invincible effect progresses</desc>
</method>
<method>
<name>setMeshHidden</name>
<args>( string name, bool hide )</args>
<desc>Set the hidden state on the named shape mesh.
@param name name of the mesh to hide/show
@param hide new hidden state for the mesh</desc>
</method>
<method>
<name>setRechargeRate</name>
<args>( float rate )</args>
<desc>Set the recharge rate.
The recharge rate is added to the object's current energy level each tick, up to the maxEnergy level set in the ShapeBaseData datablock.
@param rate the recharge rate (per tick)</desc>
</method>
<method>
<name>setRepairRate</name>
<args>( float rate )</args>
<desc>Set amount to repair damage by each tick.
Note that this value is separate to the repairRate field in ShapeBaseData. This value will be subtracted from the damage level each tick, whereas the ShapeBaseData field limits how much of the applyRepair value is subtracted each tick. Both repair types can be active at the same time.
@param rate value to subtract from damage level each tick (must be &gt; 0)</desc>
</method>
<method>
<name>setShapeName</name>
<args>( string name )</args>
<desc>Set the name of this shape.
@note This is the name of the shape object that is sent to the client, not the DTS or DAE model filename.
@param name new name for the shape</desc>
</method>
<method>
<name>setSkinName</name>
<args>( string name )</args>
<desc>Apply a new skin to this shape.
@param name name of the skin to apply</desc>
</method>
<method>
<name>setThreadDir</name>
<args>( int slot, bool fwd )</args>
<desc>Set the playback direction of an animation thread.
@param slot thread slot to modify
@param fwd true to play the animation forwards, false to play backwards
@return true if successful, false if failed

@see playThread</desc>
</method>
<method>
<name>setThreadPos</name>
<args>(int slot, float Position)</args>
</method>
<method>
<name>setThreadSequence</name>
<args>(int slot, int sequence)</args>
</method>
<method>
<name>setThreadSpeed</name>
<args>(int slot, int Speed)</args>
</method>
<method>
<name>setThreadStartPos</name>
<args>(int slot, float startPos)</args>
</method>
<method>
<name>setThreadState</name>
<args>(int slot, int state)</args>
</method>
<method>
<name>setThreadStopPos</name>
<args>(int slot, float stopPos)</args>
</method>
<method>
<name>setThreadTimeScale</name>
<args>( int slot, float scale )</args>
<desc>Set the playback time scale of an animation thread.
@param slot thread slot to modify
@param scale new thread time scale (1=normal speed, 0.5=half speed etc)
@return true if successful, false if failed

@see playThread</desc>
</method>
<method>
<name>setVelocity</name>
<args>( Point3F vel )</args>
<desc>Set the object's velocity.
@param vel new velocity for the object
@return true</desc>
</method>
<method>
<name>setWhiteOut</name>
<args>( float level )</args>
<desc>Set the white-out level.
White-out may be used as a postfx effect to brighten the screen in response to a game event.
@note Currently not implemented.
@param level flash level (0-1)</desc>
</method>
<method>
<name>startFade</name>
<args>( int time, int delay, bool fadeOut )</args>
<desc>Fade the object in or out without removing it from the scene.
A faded out object is still in the scene and can still be collided with, so if you want to disable collisions for this shape after it fades out use setHidden to temporarily remove this shape from the scene.
@note Items have the ability to light their surroundings. When an Item with an active light is fading out, the light it emits is correspondingly reduced until it goes out. Likewise, when the item fades in, the light is turned-up till it reaches it's normal brightntess.
@param time duration of the fade effect in ms
@param delay delay in ms before the fade effect begins
@param fadeOut true to fade-out to invisible, false to fade-in to full visibility</desc>
</method>
<method>
<name>stopAudio</name>
<args>( int slot )</args>
<desc>Stop a sound started with playAudio.
@param slot audio slot index (started with playAudio)
@return true if the sound was stopped successfully, false if failed</desc>
</method>
<method>
<name>stopThread</name>
<args>( int slot )</args>
<desc>Stop an animation thread.
If restarted using playThread, the animation will start from the beginning again.
@param slot thread slot to stop
@return true if successful, false if failed

@see playThread</desc>
</method>
<method>
<name>unmountImage</name>
<args>( int slot )</args>
<desc>Unmount the mounted Image in the specified slot.
@param slot Image slot to unmount
@return true if successful, false if failed</desc>
</method>
</class>
<class>
<name>ShapeBaseClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ShapeBaseData</name>
<base>GameBaseData</base>
<method>
<name>checkDeployPos</name>
<args>( TransformF txfm )</args>
<desc>Check if there is the space at the given transform is free to spawn into.
@param txfm deploy transform to check
@return true if the space is free, false if there is already something in the way.</desc>
</method>
<method>
<name>getDeployTransform</name>
<args>( Point3F pos, Point3F normal )</args>
<desc>Get a transform (suitable for use with setTransform).
@param pos desired transform position
@param dir desired UP direction
@return the deploy transform</desc>
</method>
<field>
<name>aiAvoidThis</name>
<desc>If set, AI's will try to walk around this object.
@note There is currently no AI code that takes advantage of this.</desc>
</field>
<field>
<name>cameraDefaultFov</name>
<desc>The default camera vertical FOV in degrees.</desc>
</field>
<field>
<name>cameraMaxDist</name>
<desc>The maximum distance from the camera to the object.
Used when computing a custom camera transform for this object.

@see observeThroughObject</desc>
</field>
<field>
<name>cameraMaxFov</name>
<desc>The maximum camera vertical FOV allowed in degrees.</desc>
</field>
<field>
<name>cameraMinDist</name>
<desc>The minimum distance from the camera to the object.
Used when computing a custom camera transform for this object.

@see observeThroughObject</desc>
</field>
<field>
<name>cameraMinFov</name>
<desc>The minimum camera vertical FOV allowed in degrees.</desc>
</field>
<field>
<name>computeCRC</name>
<desc>If true, verify that the CRC of the client's shape model matches the server's CRC for the shape model when loaded by the client.</desc>
</field>
<field>
<name>cubeReflectorDesc</name>
<desc>string cubeReflectorDesc</desc>
</field>
<field>
<name>Debris</name>
<desc>%Debris to generate when this shape is blown up.</desc>
</field>
<field>
<name>debrisShapeName</name>
<desc>The DTS or DAE model to use for auto-generated breakups. @note may not be functional.</desc>
</field>
<field>
<name>density</name>
<desc>Shape density.
Used when computing buoyancy when in water.</desc>
</field>
<field>
<name>destroyedLevel</name>
<desc>Damage level above which the object is destroyed.
When the damage level increases above this value, the object damage state is set to "Destroyed".</desc>
</field>
<field>
<name>disabledLevel</name>
<desc>Damage level above which the object is disabled.
Currently unused.</desc>
</field>
<field>
<name>drag</name>
<desc>Drag factor.
Reduces velocity of moving objects.</desc>
</field>
<field>
<name>Explosion</name>
<desc>%Explosion to generate when this shape is blown up.</desc>
</field>
<field>
<name>firstPersonOnly</name>
<desc>Flag controlling whether the view from this object is first person only.</desc>
</field>
<field>
<name>inheritEnergyFromMount</name>
<desc>Flag controlling whether to manage our own energy level, or to use the energy level of the object we are mounted to.</desc>
</field>
<field>
<name>isInvincible</name>
<desc>Invincible flag; when invincible, the object cannot be damaged or repaired.</desc>
</field>
<field>
<name>mass</name>
<desc>Shape mass.
Used in simulation of moving objects.</desc>
</field>
<field>
<name>maxDamage</name>
<desc>Maximum damage level for this object.</desc>
</field>
<field>
<name>maxEnergy</name>
<desc>Maximum energy level for this object.</desc>
</field>
<field>
<name>observeThroughObject</name>
<desc>Observe this object through its camera transform and default fov.
If true, when this object is the camera it can provide a custom camera transform and FOV (instead of the default eye transform).</desc>
</field>
<field>
<name>onCollision( ShapeBase obj, SceneObject  collObj, VectorF vec, float len )</name>
<desc>Called when we collide with another object.
@param obj the ShapeBase object
@param collObj the object we collided with
@param vec collision impact vector
@param len length of the impact vector</desc>
</field>
<field>
<name>onDamage( ShapeBase obj, float delta )</name>
<desc>Called when the object is damaged.
@param obj the ShapeBase object
@param obj the ShapeBase object
@param delta the amount of damage received.</desc>
</field>
<field>
<name>onDestroyed( ShapeBase obj, string lastState )</name>
<desc>Called when the object damage state changes to Destroyed.
@param obj the ShapeBase object
@param lastState the previous damage state</desc>
</field>
<field>
<name>onDisabled( ShapeBase obj, string lastState )</name>
<desc>Called when the object damage state changes to Disabled.
@param obj the ShapeBase object
@param lastState the previous damage state</desc>
</field>
<field>
<name>onEnabled( ShapeBase obj, string lastState )</name>
<desc>Called when the object damage state changes to Enabled.
@param obj the ShapeBase object
@param lastState the previous damage state</desc>
</field>
<field>
<name>onEndSequence( ShapeBase obj, int slot )</name>
<desc>Called when a thread playing a non-cyclic sequence reaches the end of the sequence.
@param obj the ShapeBase object
@param slot thread slot that finished playing</desc>
</field>
<field>
<name>onForceUncloak( ShapeBase obj, string reason )</name>
<desc>Called when the object is forced to uncloak.
@param obj the ShapeBase object
@param reason string describing why the object was uncloaked</desc>
</field>
<field>
<name>onImpact( ShapeBase obj, SceneObject  collObj, VectorF vec, float len )</name>
<desc>Called when we collide with another object.
@param obj the ShapeBase object
@param collObj the object we collided with
@param vec collision impact vector
@param len length of the impact vector</desc>
</field>
<field>
<name>onTrigger( ShapeBase obj, int index, bool state )</name>
<desc>Called when a trigger input changes state.
@param obj the ShapeBase object
@param index index of the trigger that changed
@param state new state of the trigger</desc>
</field>
<field>
<name>renderWhenDestroyed</name>
<desc>Whether to render the shape when it is in the "Destroyed" damage state.</desc>
</field>
<field>
<name>repairRate</name>
<desc>Rate at which damage is repaired in damage units/sec.
This value is subtracted from the damage level until it reaches 0.</desc>
</field>
<field>
<name>shadowEnable</name>
<desc>Enable shadows for this shape (currently unused, shadows are always enabled).</desc>
</field>
<field>
<name>shadowMaxVisibleDistance</name>
<desc>Maximum distance at which shadow is visible (currently unused).</desc>
</field>
<field>
<name>shadowProjectionDistance</name>
<desc>Maximum height above ground to project shadow. If the object is higher than this no shadow will be rendered.</desc>
</field>
<field>
<name>shadowSize</name>
<desc>Size of the shadow texture (must be power of 2).</desc>
</field>
<field>
<name>shadowSphereAdjust</name>
<desc>Scalar applied to the radius of spot shadows (initial radius is based on the shape bounds but can be adjusted with this field).</desc>
</field>
<field>
<name>shapeFile</name>
<desc>The DTS or DAE model to use for this object.</desc>
</field>
<field>
<name>underwaterExplosion</name>
<desc>%Explosion to generate when this shape is blown up underwater.</desc>
</field>
<field>
<name>useEyePoint</name>
<desc>Flag controlling whether the client uses this object's eye point to view from.</desc>
</field>
</class>
<class>
<name>ShapeBaseDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ShapeBaseImageData</name>
<base>GameBaseData</base>
<field>
<name>accuFire</name>
<desc>Flag to control whether the Image's aim is automatically converged with the crosshair.
Currently unused.</desc>
</field>
<field>
<name>camShakeAmp</name>
<desc>Amplitude of the camera shaking effect.

@see shakeCamera</desc>
</field>
<field>
<name>camShakeFreq</name>
<desc>Frequency of the camera shaking effect.

@see shakeCamera</desc>
</field>
<field>
<name>casing</name>
<desc>DebrisData datablock to use for ejected casings.

@see stateEjectShell</desc>
</field>
<field>
<name>cloakable</name>
<desc>Whether this Image can be cloaked.
Currently unused.</desc>
</field>
<field>
<name>computeCRC</name>
<desc>If true, verify that the CRC of the client's Image matches the server's CRC for the Image when loaded by the client.</desc>
</field>
<field>
<name>correctMuzzleVector</name>
<desc>Flag to adjust the aiming vector to the eye's LOS point.

@see getMuzzleVector</desc>
</field>
<field>
<name>emap</name>
<desc>Whether to enable environment mapping on this Image.</desc>
</field>
<field>
<name>eyeOffset</name>
<desc>"X Y Z" translation offset from the ShapeBase model's eye node.
Only affects 1st person POV.</desc>
</field>
<field>
<name>eyeRotation</name>
<desc>"X Y Z ANGLE" rotation offset from the ShapeBase model's eye node.
Only affects 1st person POV.</desc>
</field>
<field>
<name>firstPerson</name>
<desc>This flag must be set for the adjusted LOS muzzle vector to be computed.

@see getMuzzleVector</desc>
</field>
<field>
<name>lightBrightness</name>
<desc>Brightness of the light this Image emits.
Only valid for WeaponFireLight.</desc>
</field>
<field>
<name>lightColor</name>
<desc>The color of light this Image emits.</desc>
</field>
<field>
<name>lightDuration</name>
<desc>Duration in SimTime of Pulsing and WeaponFire type lights.</desc>
</field>
<field>
<name>lightRadius</name>
<desc>Radius of the light this Image emits.</desc>
</field>
<field>
<name>lightType</name>
<desc>The type of light this Image emits.</desc>
</field>
<field>
<name>mass</name>
<desc>Mass of this Image.
This is added to the total mass of the ShapeBase object.</desc>
</field>
<field>
<name>maxConcurrentSounds</name>
<desc>Maximum number of sounds this Image can play at a time.
Any value &lt;= 0 indicates that it can play an infinite number of sounds.</desc>
</field>
<field>
<name>minEnergy</name>
<desc>Minimum Image energy for it to be operable.</desc>
</field>
<field>
<name>mountPoint</name>
<desc>Mount node # to mount this Image to.
This should correspond to a mount# node on the ShapeBase derived object we are mounting to.</desc>
</field>
<field>
<name>offset</name>
<desc>"X Y Z" translation offset from this Image's &lt;i&gt;mountPoint&lt;/i&gt; node to attach to.
Defaults to "0 0 0". ie. attach this Image's &lt;i&gt;mountPoint&lt;/i&gt; node to the ShapeBase model's mount# node.</desc>
</field>
<field>
<name>onMount( ShapeBase obj, int slot, float dt )</name>
<desc>Called when the Image is first mounted to the object.
@param obj object that this Image has been mounted to
@param slot Image mount slot
@param dt time remaining in this Image update</desc>
</field>
<field>
<name>onUnmount( ShapeBase obj, int slot, float dt )</name>
<desc>Called when the Image is unmounted from the object.
@param obj object that this Image has been unmounted from
@param slot Image mount slot
@param dt time remaining in this Image update</desc>
</field>
<field>
<name>Projectile</name>
<desc>The projectile fired by this Image</desc>
</field>
<field>
<name>rotation</name>
<desc>"X Y Z ANGLE" rotation offset from this Image's &lt;i&gt;mountPoint&lt;/i&gt; node to attach to.
Defaults to "0 0 0". ie. attach this Image's &lt;i&gt;mountPoint&lt;/i&gt; node to the ShapeBase model's mount# node.</desc>
</field>
<field>
<name>shakeCamera</name>
<desc>Flag indicating whether the camera should shake when this Image fires.
@note Camera shake only works properly if the player is in control of the one and only shapeBase object in the scene which fires an Image that uses camera shake.</desc>
</field>
<field>
<name>shapeFile</name>
<desc>The DTS or DAE model to use for this Image.</desc>
</field>
<field>
<name>shellExitDir</name>
<desc>Vector direction to eject shell casings.</desc>
</field>
<field>
<name>shellExitVariance</name>
<desc>Variance (in degrees) from the shellExitDir vector.</desc>
</field>
<field>
<name>shellVelocity</name>
<desc>Speed at which to eject casings.</desc>
</field>
<field>
<name>stateAllowImageChange</name>
<desc>If false, other Images will temporarily be blocked from mounting while the state machine is executing the tasks in this state.
For instance, if we have a rocket launcher, the player shouldn't be able to switch out &lt;i&gt;while&lt;/i&gt; firing. So, you'd set stateAllowImageChange to false in firing states, and true the rest of the time.</desc>
</field>
<field>
<name>stateDirection</name>
<desc>Direction of the animation to play in this state.
True is forward, false is backward.</desc>
</field>
<field>
<name>stateEjectShell</name>
<desc>If true, a shell casing will be ejected in this state.</desc>
</field>
<field>
<name>stateEmitter</name>
<desc>Emitter to generate particles in this state (from muzzle point or specified node).

@see stateEmitterNode</desc>
</field>
<field>
<name>stateEmitterNode</name>
<desc>Name of the node to emit particles from.

@see stateEmitter</desc>
</field>
<field>
<name>stateEmitterTime</name>
<desc>How long (in seconds) to emit particles on entry to this state.</desc>
</field>
<field>
<name>stateEnergyDrain</name>
<desc>Amount of energy to subtract from the Image in this state.
Energy is drained at stateEnergyDrain units/sec as long as we are in this state.</desc>
</field>
<field>
<name>stateFire</name>
<desc>The first state with this set to true is the state entered by the client when it receives the 'fire' event.</desc>
</field>
<field>
<name>stateIgnoreLoadedForReady</name>
<desc>If set to true, and both ready and loaded transitions are true, the ready transition will be taken instead of the loaded transition.
A state is 'ready' if pressing the fire trigger in that state would transition to the fire state.</desc>
</field>
<field>
<name>stateLoadedFlag</name>
<desc>Set the loaded state of the Image.
&lt;ul&gt;&lt;li&gt;IgnoreLoaded: Don't change Image loaded state.&lt;/li&gt;&lt;li&gt;Loaded: Set Image loaded state to true.&lt;/li&gt;&lt;li&gt;NotLoaded: Set Image loaded state to false.&lt;/li&gt;&lt;/ul&gt;</desc>
</field>
<field>
<name>stateName</name>
<desc>Name of this state.</desc>
</field>
<field>
<name>stateRecoil</name>
<desc>Type of recoil sequence to play on the ShapeBase object on entry to this state.
&lt;ul&gt;&lt;li&gt;NoRecoil: Do not play a recoil sequence.&lt;/li&gt;&lt;li&gt;LightRecoil: Play the light_recoil sequence.&lt;/li&gt;&lt;li&gt;MediumRecoil: Play the medium_recoil sequence.&lt;/li&gt;&lt;li&gt;HeavyRecoil: Play the heavy_recoil sequence.&lt;/li&gt;&lt;/ul&gt;</desc>
</field>
<field>
<name>stateScaleAnimation</name>
<desc>If true, the timeScale of the stateSequence animation will be adjusted such that the sequence plays for stateTimeoutValue seconds.</desc>
</field>
<field>
<name>stateScript</name>
<desc>Method to execute on entering this state.
Scoped to this image class name, then ShapeBaseImageData. The script callback function takes the same arguments as the onMount callback.</desc>
</field>
<field>
<name>stateSequence</name>
<desc>Name of the sequence to play on entry to this state.</desc>
</field>
<field>
<name>stateSequenceRandomFlash</name>
<desc>If true, a random frame from the muzzle flash sequence will be displayed each frame.
The name of the muzzle flash sequence is the same as stateSequence, with "_vis" at the end.</desc>
</field>
<field>
<name>stateSound</name>
<desc>Sound to play on entry to this state.</desc>
</field>
<field>
<name>stateSpinThread</name>
<desc>Controls how fast the 'spin' animation sequence will be played in this state.
&lt;ul&gt;&lt;li&gt;Ignore: No change to the spin sequence.&lt;/li&gt;&lt;li&gt;Stop: Stops the spin sequence at its current position.&lt;/li&gt;&lt;li&gt;SpinUp: Increase spin sequence timeScale from 0 (on state entry) to 1 (after stateTimeoutValue seconds).&lt;/li&gt;&lt;li&gt;SpinDown: Decrease spin sequence timeScale from 1 (on state entry) to 0 (after stateTimeoutValue seconds).&lt;/li&gt;&lt;li&gt;FullSpeed: Resume the spin sequence playback at its current position with timeScale=1.&lt;/li&gt;&lt;/ul&gt;</desc>
</field>
<field>
<name>stateTimeoutValue</name>
<desc>Time in seconds to wait before transitioning to stateTransitionOnTimeout.</desc>
</field>
<field>
<name>stateTransitionOnAltTriggerDown</name>
<desc>Name of the state to transition to when the alt trigger state of the Image changes to false (alt fire button up).</desc>
</field>
<field>
<name>stateTransitionOnAltTriggerUp</name>
<desc>Name of the state to transition to when the alt trigger state of the Image changes to true (alt fire button down).</desc>
</field>
<field>
<name>stateTransitionOnAmmo</name>
<desc>Name of the state to transition to when the ammo state of the Image changes to true.</desc>
</field>
<field>
<name>stateTransitionOnLoaded</name>
<desc>Name of the state to transition to when the loaded state of the Image changes to 'Loaded'.</desc>
</field>
<field>
<name>stateTransitionOnNoAmmo</name>
<desc>Name of the state to transition to when the ammo state of the Image changes to false.</desc>
</field>
<field>
<name>stateTransitionOnNoTarget</name>
<desc>Name of the state to transition to when the Image loses a target.</desc>
</field>
<field>
<name>stateTransitionOnNotLoaded</name>
<desc>Name of the state to transition to when the loaded state of the Image changes to 'Empty'.</desc>
</field>
<field>
<name>stateTransitionOnNotWet</name>
<desc>Name of the state to transition to when the Image exits the water.</desc>
</field>
<field>
<name>stateTransitionOnTarget</name>
<desc>Name of the state to transition to when the Image gains a target.</desc>
</field>
<field>
<name>stateTransitionOnTimeout</name>
<desc>Name of the state to transition to when we have been in this state for stateTimeoutValue seconds.</desc>
</field>
<field>
<name>stateTransitionOnTriggerDown</name>
<desc>Name of the state to transition to when the trigger state of the Image changes to false (fire button released).</desc>
</field>
<field>
<name>stateTransitionOnTriggerUp</name>
<desc>Name of the state to transition to when the trigger state of the Image changes to true (fire button down).</desc>
</field>
<field>
<name>stateTransitionOnWet</name>
<desc>Name of the state to transition to when the Image enters the water.</desc>
</field>
<field>
<name>stateWaitForTimeout</name>
<desc>If false, this state ignores stateTimeoutValue and transitions immediately if other transition conditions are met.</desc>
</field>
<field>
<name>useRemainderDT</name>
<desc>If true, allow multiple timeout transitions to occur within a single tick (useful if states have a very small timeout).</desc>
</field>
<field>
<name>usesEnergy</name>
<desc>Flag indicating whether this Image uses energy instead of ammo.</desc>
</field>
</class>
<class>
<name>ShapeBaseImageDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Sim2DAudioEvent</name>
</class>
<class>
<name>Sim2DAudioEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Sim3DAudioEvent</name>
</class>
<class>
<name>Sim3DAudioEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimComponent</name>
<base>NetObject</base>
<method>
<name>addComponents</name>
<desc>%obj.addComponents( %compObjName, %compObjName2, ... );
Adds additional components to current list.
@param Up to 62 component names
@return Returns true on success, false otherwise.</desc>
</method>
<method>
<name>getComponent</name>
<args>(idx)</args>
<desc>Get the component corresponding to the given index.
@param idx An integer index value corresponding to the desired component.
@return The id of the component at the given index as an integer</desc>
</method>
<method>
<name>getComponentCount</name>
<args>()</args>
<desc>Get the current component count
@return The number of components in the list as an integer</desc>
</method>
<method>
<name>getIsTemplate</name>
<args>()</args>
<desc>Check whether SimComponent is currently a template
@return true if is a template and false if not</desc>
</method>
<method>
<name>isEnabled</name>
<args>()</args>
<desc>Check whether SimComponent is currently enabled
@return true if enabled and false if not</desc>
</method>
<method>
<name>removeComponents</name>
<desc>%obj.removeComponents( %compObjName, %compObjName2, ... );
Removes components by name from current list.
@param objNamex Up to 62 component names
@return Returns true on success, false otherwise.</desc>
</method>
<method>
<name>setEnabled</name>
<args>(enabled)</args>
<desc>Sets or unsets the enabled flag
@param enabled Boolean value
@return No return value</desc>
</method>
<method>
<name>setIsTemplate</name>
<args>(template)</args>
<desc>Sets or unsets the template flag
@param template Boolean value
@return No return value</desc>
</method>
<field>
<name>Template</name>
<desc>Places the object in a component set for later use in new levels.</desc>
</field>
</class>
<class>
<name>SimComponentClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimDataBlock</name>
<base>SimObject</base>
</class>
<class>
<name>SimDataBlockClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimDataBlockEvent</name>
</class>
<class>
<name>SimDataBlockEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimGroup</name>
<base>SimSet</base>
</class>
<class>
<name>SimGroupClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimObject</name>
<method>
<name>assignFieldsFrom</name>
<args>( SimObject fromObject )</args>
<desc>Copy fields from another object onto this one.  The objects must be of same type. Everything from the object will overwrite what's in this object; extra fields in this object will remain. This includes dynamic fields.
@param fromObject The object from which to copy fields.</desc>
</method>
<method>
<name>assignPersistentId</name>
<args>()</args>
<desc>Assign a persistent ID to the object if it does not already have one.</desc>
</method>
<method>
<name>call</name>
<args>( string method, string args... )</args>
<desc>Dynamically call a method on an object.
@param method Name of method to call.
@param args Zero or more arguments for the method.
@return The result of the method call.</desc>
</method>
<method>
<name>clone</name>
<args>()</args>
<desc>Create a copy of this object.
@return An exact duplicate of this object.</desc>
</method>
<method>
<name>deepClone</name>
<args>()</args>
<desc>Create a copy of this object and all its subobjects.
@return An exact duplicate of this object and all objects it references.</desc>
</method>
<method>
<name>delete</name>
<args>()</args>
<desc>Delete and remove the object.</desc>
</method>
<method>
<name>dump</name>
<args>( bool detailed=false )</args>
<desc>Dump a description of all fields and methods defined on this object to the console.
@param detailed Whether to print detailed information about members.</desc>
</method>
<method>
<name>dumpClassHierarchy</name>
<args>()</args>
<desc>Dump the native C++ class hierarchy of this object's C++ class to the console.</desc>
</method>
<method>
<name>dumpGroupHierarchy</name>
<args>()</args>
<desc>Dump the hierarchy of this object up to RootGroup to the console.</desc>
</method>
<method>
<name>dumpMethods</name>
<args>()</args>
<desc>List the methods defined on this object.
@return An ArrayObject populated with (name,description) pairs of all methods defined on the object.</desc>
</method>
<method>
<name>getCanSave</name>
<args>()</args>
<desc>Get whether the object will be included in saves.
@return True if the object will be saved; false otherwise.</desc>
</method>
<method>
<name>getClassName</name>
<args>()</args>
<desc>Get the name of the C++ class which the object is an instance of.
@return The name of the C++ class of the object.</desc>
</method>
<method>
<name>getClassNamespace</name>
<args>()</args>
<desc>Get the name of the class namespace assigned to this object.
@return The name of the 'class' namespace.</desc>
</method>
<method>
<name>getClassObject</name>
<args>()</args>
<desc>Return the meta-object corresponding to the SimObject's class.
@return The meta-object of this object.</desc>
</method>
<method>
<name>getDynamicField</name>
<args>( int index )</args>
<desc>Get a value of a dynamic field by index.
@param index The index of the dynamic field.
@return The value of the dynamic field at the given index or "".</desc>
</method>
<method>
<name>getDynamicFieldCount</name>
<args>()</args>
<desc>Get the number of dynamic fields defined on the object.
@return The number of dynamic fields defined on the object.</desc>
</method>
<method>
<name>getField</name>
<args>( int index )</args>
<desc>Retrieve the value of a static field by index.
@param index The index of the static field.
@return The value of the static field with the given index or "".</desc>
</method>
<method>
<name>getFieldCount</name>
<args>()</args>
<desc>Get the number of static fields on the object.
@return The number of static fields defined on the object.</desc>
</method>
<method>
<name>getFieldType</name>
<args>( string fieldName )</args>
<desc>Get the console type code of the given field.
@return The numeric type code for the underlying console type of the given field.</desc>
</method>
<method>
<name>getFieldValue</name>
<args>( string fieldName, int index=-1 )</args>
<desc>Return the value of the given field on this object.
@param fieldName The name of the field.  If it includes a field index, the index is parsed out.
@param index Optional parameter to specify the index of an array field separately.
@return The value of the given field or "" if undefined.</desc>
</method>
<method>
<name>getFilename</name>
<args>()</args>
<desc>Returns the filename the object is attached to.
@return The name of the file the object is associated with; usually the file the object was loaded from.</desc>
</method>
<method>
<name>getGroup</name>
<args>()</args>
<desc>Get the group that this object is contained in.
@note If not assigned to particular SimGroup, an object belongs to RootGroup.
@return The SimGroup object to which the object belongs.</desc>
</method>
<method>
<name>getId</name>
<args>()</args>
<desc>Get the underlying unique numeric ID of the object.
@note Object IDs are unique only during single engine runs.
@return The unique numeric ID of the object.</desc>
</method>
<method>
<name>getInternalName</name>
<args>()</args>
<desc>Get the internal name of the object.
@return The internal name of the object.</desc>
</method>
<method>
<name>getName</name>
<args>()</args>
<desc>Get the global name of the object.
@return The global name assigned to the object.</desc>
</method>
<method>
<name>getSuperClassNamespace</name>
<args>()</args>
<desc>Get the name of the superclass namespace assigned to this object.
@return The name of the 'superClass' namespace.</desc>
</method>
<method>
<name>getType</name>
<args>()</args>
<desc>Return the type mask for this object.
@return The numeric type mask for the object.</desc>
</method>
<method>
<name>isChildOfGroup</name>
<args>( SimGroup group )</args>
<desc>Test whether the object belongs directly or indirectly to the given group.
@param group The SimGroup object.
@return True if the object is a child of the given group or a child of a group that the given group is directly or indirectly a child to.</desc>
</method>
<method>
<name>isEditorOnly</name>
<args>()</args>
<desc>Return true if the object is only used by the editor.
@return True if this object exists only for the sake of editing.</desc>
</method>
<method>
<name>isExpanded</name>
<args>()</args>
<desc>Get whether the object has been marked as expanded. (in editor)
@return True if the object is marked expanded.</desc>
</method>
<method>
<name>isInNamespaceHierarchy</name>
<args>( string name )</args>
<desc>Test whether the namespace of this object is a direct or indirect child to the given namespace.
@param name The name of a namespace.
@return True if the given namespace name is within the namespace hierarchy of this object.</desc>
</method>
<method>
<name>isMemberOfClass</name>
<args>( string className )</args>
<desc>Test whether this object is a member of the specified class.
@param className Name of a native C++ class.
@return True if this object is an instance of the given C++ class or any of its super classes.</desc>
</method>
<method>
<name>isMethod</name>
<args>( string methodName )</args>
<desc>Test whether the given method is defined on this object.
@param The name of the method.
@return True if the object implements the given method.</desc>
</method>
<method>
<name>isNameChangeAllowed</name>
<args>()</args>
<desc>Get whether this object may be renamed.
@return True if this object can be renamed; false otherwise.</desc>
</method>
<method>
<name>isSelected</name>
<args>()</args>
<desc>Get whether the object has been marked as selected. (in editor)
@return True if the object is currently selected.</desc>
</method>
<method>
<name>save</name>
<args>( string fileName, bool selectedOnly=false, string preAppendString="" )</args>
<desc>Save out the object to the given file.
@param fileName The name of the file to save to.@param selectedOnly If true, only objects marked as selected will be saved out.
@param preAppendString Text which will be preprended directly to the object serialization.
@param True on success, false on failure.</desc>
</method>
<method>
<name>schedule</name>
<args>( float time, string method, string args... )</args>
<desc>Delay an invocation of a method.
@param time The number of milliseconds after which to invoke the method.  This is a soft limit.
@param method The method to call.
@param args The arguments with which to call the method.
@return The numeric ID of the created schedule.  Can be used to cancel the call.</desc>
</method>
<method>
<name>setCanSave</name>
<args>( bool value=true )</args>
<desc>Set whether the object will be included in saves.
@param value If true, the object will be included in saves; if false, it will be excluded.</desc>
</method>
<method>
<name>setClassNamespace</name>
<args>( string name )</args>
<desc>Assign a class namespace to this object.
@param name The name of the 'class' namespace for this object.</desc>
</method>
<method>
<name>setEditorOnly</name>
<args>( bool value=true )</args>
<desc>Set/clear the editor-only flag on this object.
@param value If true, the object is marked as existing only for the editor.</desc>
</method>
<method>
<name>setFieldType</name>
<args>( string fieldName, string type )</args>
<desc>Set the console type code for the given field.
@param fieldName The name of the dynamic field to change to type for.
@param type The name of the console type.
@note This only works for dynamic fields.  Types of static fields cannot be changed.</desc>
</method>
<method>
<name>setFieldValue</name>
<args>( string fieldName, string value, int index=-1 )</args>
<desc>Set the value of the given field on this object.
@param fieldName The name of the field to assign to.  If it includes an array index, the index will be parsed out.
@param value The new value to assign to the field.
@param index Optional argument to specify an index for an array field.
@return True.</desc>
</method>
<method>
<name>setFilename</name>
<args>( string fileName )</args>
<desc>Sets the object's file name and path
@param fileName The name of the file to associate this object with.</desc>
</method>
<method>
<name>setHidden</name>
<args>( bool value=true )</args>
<desc>Hide/unhide the object.
@param value If true, the object will be hidden; if false, the object will be unhidden.</desc>
</method>
<method>
<name>setInternalName</name>
<args>( string newInternalName )</args>
<desc>Set the internal name of the object.
@param newInternalName The new internal name for the object.</desc>
</method>
<method>
<name>setIsExpanded</name>
<args>( bool state=true )</args>
<desc>Set whether the object has been marked as expanded. (in editor)
@param state True if the object is to be marked expanded; false if not.</desc>
</method>
<method>
<name>setIsSelected</name>
<args>( bool state=true )</args>
<desc>Set whether the object has been marked as selected. (in editor)
@param state True if object is to be marked selected; false if not.</desc>
</method>
<method>
<name>setLocked</name>
<args>( bool value=true )</args>
<desc>Lock/unlock the object in the editor.
@param value If true, the object will be locked; if false, the object will be unlocked.</desc>
</method>
<method>
<name>setName</name>
<args>( string newName )</args>
<desc>Set the global name of the object.
@param newName The new global name to assign to the object.
@note If name changing is disallowed on the object, the method will fail with a console error.</desc>
</method>
<method>
<name>setNameChangeAllowed</name>
<args>( bool value=true )</args>
<desc>Set whether this object can be renamed from its first name.
@param value If true, renaming is allowed for this object; if false, trying to change the name of the object will generate a console error.</desc>
</method>
<method>
<name>setSuperClassNamespace</name>
<args>( string name )</args>
<desc>Assign a superclass namespace to this object.
@param name The name of the 'superClass' namespace for this object.</desc>
</method>
<field>
<name>canSave</name>
<desc>Whether the object can be saved out. If false, the object is purely transient in nature.</desc>
</field>
<field>
<name>canSaveDynamicFields</name>
<desc>True if dynamic fields (added at runtime) should be saved. Defaults to true.</desc>
</field>
<field>
<name>class</name>
<desc>Script class of object.</desc>
</field>
<field>
<name>className</name>
<desc>Script class of object.</desc>
</field>
<field>
<name>hidden</name>
<desc>Whether the object is visible.</desc>
</field>
<field>
<name>internalName</name>
<desc>Optional name that may be used to lookup this object within a SimSet.</desc>
</field>
<field>
<name>locked</name>
<desc>Whether the object can be edited.</desc>
</field>
<field>
<name>name</name>
<desc>Optional global name of this object.</desc>
</field>
<field>
<name>parentGroup</name>
<desc>Group hierarchy parent of the object.</desc>
</field>
<field>
<name>persistentId</name>
<desc>The universally unique identifier for the object.</desc>
</field>
<field>
<name>superClass</name>
<desc>Script super-class of object.</desc>
</field>
</class>
<class>
<name>SimObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimPersistSet</name>
<base>SimSet</base>
<method>
<name>resolvePersistentIds</name>
<args>()</args>
<desc>Try to bind unresolved persistent IDs in the set.</desc>
</method>
</class>
<class>
<name>SimPersistSetClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimpleComponent</name>
<base>SimComponent</base>
</class>
<class>
<name>SimpleComponentClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimpleMessageEvent</name>
</class>
<class>
<name>SimpleMessageEventClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimpleNetObject</name>
<base>NetObject</base>
<method>
<name>msg</name>
<args>( NetConnection con, string message )</args>
<desc>@brief Send a SimpleNetObject message to the specified connection.

@param con The unique ID of the connection to transmit to
@param message The string containing the message to transmit</desc>
</method>
<method>
<name>setMessage</name>
<args>( string msg )</args>
<desc>@brief Sets the internal message variable.

@param msg The new message to send

@return Value</desc>
</method>
</class>
<class>
<name>SimpleNetObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimResponseCurve</name>
<base>SimObject</base>
<method>
<name>addPoint</name>
<desc>addPoint( F32 value, F32 time )</desc>
</method>
<method>
<name>clear</name>
<desc>clear()</desc>
</method>
<method>
<name>getValue</name>
<desc>getValue( F32 time )</desc>
</method>
</class>
<class>
<name>SimResponseCurveClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimSet</name>
<base>SimObject</base>
<method>
<name>acceptsAsChild</name>
<args>( SimObject obj )</args>
<desc>Test whether the given object may be added to the set.
@param obj The object to test for potential membership.
@return True if the object may be added to the set, false otherwise.</desc>
</method>
<method>
<name>add</name>
<args>( SimObject objects... )</args>
<desc>Add the given objects to the set.
@param objects The objects to add to the set.</desc>
</method>
<method>
<name>bringToFront</name>
<args>( SimObject obj )</args>
<desc>Make the given object the first object in the set.
@param obj The object to bring to the frontmost position.  Must be contained in the set.</desc>
</method>
<method>
<name>callOnChildren</name>
<args>( string method, string args... )</args>
<desc>Call a method on all objects contained in the set.
@param method The name of the method to call.
@param args The arguments to the method.</desc>
</method>
<method>
<name>clear</name>
<args>()</args>
<desc>Remove all objects from the set.</desc>
</method>
<method>
<name>deleteAllObjects</name>
<args>()</args>
<desc>Delete all objects in the set.</desc>
</method>
<method>
<name>findObjectByInternalName</name>
<args>( string internalName, bool searchChildren=false )</args>
<desc>Find an object in the set by its internal name.
@param internalName The internal name of the object to look for.
@param searchChildren If true, SimSets contained in the set will be recursively searched for the object.
@return The object with the given internal name or 0 if no match was found.</desc>
</method>
<method>
<name>getCount</name>
<args>()</args>
<desc>Get the number of objects contained in the set.
@return The number of objects contained in the set.</desc>
</method>
<method>
<name>getFullCount</name>
<args>()</args>
<desc>Get the number of direct and indirect child objects contained in the set.
@return The number of objects contained in the set as well as in other sets contained directly or indirectly in the set.</desc>
</method>
<method>
<name>getObject</name>
<args>( int index )</args>
<desc>Get the object at the given index.
@param index The object index.
@return The object at the given index or -1 if index is out of range.</desc>
</method>
<method>
<name>getObjectIndex</name>
<args>( SimObject obj )</args>
<desc>Return the index of the given object in this set.
@param obj The object for which to return the index.  Must be contained in the set.
@return The index of the object or -1 if the object is not contained in the set.</desc>
</method>
<method>
<name>getRandom</name>
<args>()</args>
<desc>Return a random object from the set.
@return A randomly selected object from the set or NULL if the set is empty.</desc>
</method>
<method>
<name>isMember</name>
<args>( SimObject obj )</args>
<desc>Test whether the given object belongs to the set.
@param obj The object.
@return True if the object is contained in the set; false otherwise.</desc>
</method>
<method>
<name>listObjects</name>
<args>()</args>
<desc>Dump a list of all objects contained in the set to the console.</desc>
</method>
<method>
<name>pushToBack</name>
<args>( SimObject obj )</args>
<desc>Make the given object the last object in the set.
@param obj The object to bring to the last position.  Must be contained in the set.</desc>
</method>
<method>
<name>remove</name>
<args>( SimObject objects... )</args>
<desc>Remove the given objects from the set.
@param objects The objects to remove from the set.</desc>
</method>
<method>
<name>reorderChild</name>
<args>( SimObject child1, SimObject child2 )</args>
<desc>Make sure child1 is ordered right before child2 in the set.
@param child1 The first child.  The object must already be contained in the set.
@param child2 The second child.  The object must already be contained in the set.</desc>
</method>
<method>
<name>sort</name>
<args>( string callbackFunction )</args>
<desc>Sort the objects in the set using the given comparison function.
@param callbackFunction Name of a function that takes two object arguments A and B and returns -1 if A is less, 1 if B is less, and 0 if both are equal.</desc>
</method>
<field>
<name>onObjectAdded( SimObject object )</name>
<desc>Called when an object is added to the set.
@param object The object that was added.</desc>
</field>
<field>
<name>onObjectRemoved( SimObject object )</name>
<desc>Called when an object is removed from the set.
@param object The object that was removed.</desc>
</field>
</class>
<class>
<name>SimSetClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SimXMLDocument</name>
<base>SimObject</base>
<method>
<name>addComment</name>
<args>(string comment)</args>
<desc>@brief Add the given comment as a child of current stack element.

@param comment String containing the comment.</desc>
</method>
<method>
<name>addData</name>
<args>(string text)</args>
<desc>@brief Add the given text as a child of current stack element.

@param text String containing the data.</desc>
</method>
<method>
<name>addHeader</name>
<args>()</args>
<desc>@brief Add XML header to document.</desc>
</method>
<method>
<name>addNewElement</name>
<args>(string name)</args>
<desc>@brief Create new element as child of current stack element and push new element on to stack.

@param name String containing name of new element.</desc>
</method>
<method>
<name>addText</name>
<args>(string text)</args>
<desc>@brief Add the given text as a child of current stack element.

@param text String containing the text.</desc>
</method>
<method>
<name>attribute</name>
<args>(string attri)</args>
<desc>@brief Get string attribute from top element on element stack.

@param attri String containing attribute to query.</desc>
</method>
<method>
<name>attributeExists</name>
<args>(string attribute)</args>
<desc>@brief Get true if named attribute exists.

@param attribute Name of attribute being queried for.

@param True if the attribute exists.</desc>
</method>
<method>
<name>attributeF32</name>
<args>(string attri)</args>
<desc>@brief Get float attribute from top element on element stack.

@param attri String containing attribute to query.</desc>
</method>
<method>
<name>attributeS32</name>
<args>(string attri)</args>
<desc>@brief Get int attribute from top element on element stack.

@param attri String containing attribute to query.</desc>
</method>
<method>
<name>clear</name>
<args>()</args>
<desc>@brief Clear contents of XML document.</desc>
</method>
<method>
<name>clearError</name>
<args>()</args>
<desc>@brief Clear error description.</desc>
</method>
<method>
<name>elementValue</name>
<desc>Get element value if it exists (string).</desc>
</method>
<method>
<name>firstAttribute</name>
<args>()</args>
<desc>@brief Obtain the name of the current element's first attribute.

@return String containing the name</desc>
</method>
<method>
<name>getData</name>
<args>()</args>
<desc>@brief Gets the text from the current stack element.

@return String containing the data from current stack element.</desc>
</method>
<method>
<name>getErrorDesc</name>
<desc>Get current error description.</desc>
</method>
<method>
<name>getText</name>
<args>()</args>
<desc>@brief Gets the text from the current stack element.

@return String containing the text in the current element.</desc>
</method>
<method>
<name>lastAttribute</name>
<args>()</args>
<desc>@brief Obtain the name of the current element's last attribute.

@return String containing the name.</desc>
</method>
<method>
<name>loadFile</name>
<args>(string FileName)</args>
<desc>@brief Load file from given filename.@param FileName Name and path of XML document</desc>
</method>
<method>
<name>nextAttribute</name>
<args>()</args>
<desc>@brief Get the name of the next attribute for the current element after a call to firstAttribute().

@return String containing the name.</desc>
</method>
<method>
<name>nextSiblingElement</name>
<args>(string name)</args>
<desc>@brief Set top element on stack to next element with given name.

@param name String containing name to set next sibling.</desc>
</method>
<method>
<name>parse</name>
<args>(string xmlString)</args>
<desc>@brief Create document from XML string.

@param xmlString Line from XML.</desc>
</method>
<method>
<name>popElement</name>
<args>()</args>
<desc>@brief Pop last element off of stack.</desc>
</method>
<method>
<name>prevAttribute</name>
<args>()</args>
<desc>@brief Get the name of the previous attribute for the current element after a call to lastAttribute().

@return String containing the name.</desc>
</method>
<method>
<name>pushChildElement</name>
<args>(S32 index)</args>
<desc>@brief Push the child element at the given index onto stack.

@param index Numerical index of element being pushed.</desc>
</method>
<method>
<name>pushFirstChildElement</name>
<args>(string name)</args>
<desc>@brief Push first child element with given name onto stack.

@param name String containing name of the child element.</desc>
</method>
<method>
<name>pushNewElement</name>
<desc>Create new element as child of current stack element and push new element on to stack.</desc>
</method>
<method>
<name>readComment</name>
<args>(S32 index)</args>
<desc>@brief Returns the comment at the specified index.

@param index Index number to query

@return String containing the comment.</desc>
</method>
<method>
<name>removeText</name>
<args>()</args>
<desc>@brief Remove any text on the current stack element.</desc>
</method>
<method>
<name>reset</name>
<args>()</args>
<desc>@brief Set this to default state at construction.</desc>
</method>
<method>
<name>saveFile</name>
<args>()</args>
<desc>@brief Save file to given filename.

@return True if file saves successfully</desc>
</method>
<method>
<name>setAttribute</name>
<args>(string attribute, string value)</args>
<desc>@brief Set attribute of top stack element to given value.

@param attribute Name of attribute being changed
@param value New value to assign to attribute</desc>
</method>
<method>
<name>setObjectAttributes</name>
<args>(string objectID)</args>
<desc>@brief Set attribute of top stack element to given value.

@param objectID Unique ID of SimObject being modified.</desc>
</method>
</class>
<class>
<name>SimXMLDocumentClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SkyBox</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
</method>
<field>
<name>drawBottom</name>
<desc>If false the bottom of the skybox is not rendered.</desc>
</field>
<field>
<name>fogBandHeight</name>
<desc>The height (0-1) of the fog band from the horizon to the top of the SkyBox.</desc>
</field>
<field>
<name>Material</name>
<desc>The name of a cubemap material for the sky box.</desc>
</field>
</class>
<class>
<name>SkyBoxClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SpawnSphere</name>
<base>MissionMarker</base>
<method>
<name>spawnObject</name>
<args>([string additionalProps])</args>
<desc>Spawns the object based                                                        on the SpawnSphere's class, datablock, properties,                                                        and script settings. Allows you to pass in extra properties.@hide</desc>
</method>
<field>
<name>autoSpawn</name>
<desc>Flag to spawn object as soon as SpawnSphere is created, true to enable or false to disabled</desc>
</field>
<field>
<name>indoorWeight</name>
<desc>Deprecated</desc>
</field>
<field>
<name>onAdd( int objectId )</name>
<desc>Called when the SpawnSphere is being created.
@param objectId The unique SimObjectId generated when SpawnSphere is created</desc>
</field>
<field>
<name>outdoorWeight</name>
<desc>Deprecated</desc>
</field>
<field>
<name>radius</name>
<desc>Determines the size of the sphere in which the object will spawn</desc>
</field>
<field>
<name>spawnClass</name>
<desc>Class assigned to object when created, such as Player, or AIPlayer</desc>
</field>
<field>
<name>spawnDatablock</name>
<desc>Predefined datablock assigned to the object when created</desc>
</field>
<field>
<name>spawnProperties</name>
<desc>String containing ; delimited properties that are set at the time of spawning</desc>
</field>
<field>
<name>SpawnScript</name>
<desc>Command to execute when spawning an object. New object id is stored in $SpawnObject.  Max 255 characters.</desc>
</field>
<field>
<name>sphereWeight</name>
<desc>Deprecated</desc>
</field>
</class>
<class>
<name>SpawnSphereClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Splash</name>
<base>GameBase</base>
</class>
<class>
<name>SplashClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SplashData</name>
<base>GameBaseData</base>
<field>
<name>acceleration</name>
<desc>Constant acceleration value to place upon the splash effect.</desc>
</field>
<field>
<name>colors</name>
<desc>Color values to set the splash effect, rgba. Up to 4 allowed. Will transition through colors based on values set in the times value. Example: colors[0] = "0.6 1.0 1.0 0.5".</desc>
</field>
<field>
<name>delayMS</name>
<desc>Time to delay, in milliseconds, before actually starting this effect.</desc>
</field>
<field>
<name>delayVariance</name>
<desc>Time variance for delayMS.</desc>
</field>
<field>
<name>ejectionAngle</name>
<desc>Rotational angle to create a splash ring.</desc>
</field>
<field>
<name>ejectionFreq</name>
<desc>Frequency in which to emit splash rings.</desc>
</field>
<field>
<name>emitter</name>
<desc>List of particle emitters to create at the point of this Splash effect.</desc>
</field>
<field>
<name>Explosion</name>
<desc>ExplosionData object to create at the creation position of this splash effect.</desc>
</field>
<field>
<name>height</name>
<desc>Height for the splash to reach.</desc>
</field>
<field>
<name>lifetimeMS</name>
<desc>Lifetime for this effect, in milliseconds.</desc>
</field>
<field>
<name>lifetimeVariance</name>
<desc>Time variance for lifetimeMS.</desc>
</field>
<field>
<name>numSegments</name>
<desc>Number of ejection points in the splash ring.</desc>
</field>
<field>
<name>ringLifetime</name>
<desc>Lifetime, in milliseconds, for a splash ring.</desc>
</field>
<field>
<name>scale</name>
<desc>The scale of this splashing effect, defined as the F32 points X, Y, Z.</desc>
</field>
<field>
<name>soundProfile</name>
<desc>SFXProfile effect to play.</desc>
</field>
<field>
<name>startRadius</name>
<desc>Starting radius size of a splash ring.</desc>
</field>
<field>
<name>texFactor</name>
<desc>Factor in which to apply the texture to the splash ring, 0.0f - 1.0f.</desc>
</field>
<field>
<name>texture</name>
<desc>Imagemap file to use as the texture for the splash effect.</desc>
</field>
<field>
<name>texWrap</name>
<desc>Amount to wrap the texture around the splash ring, 0.0f - 1.0f.</desc>
</field>
<field>
<name>times</name>
<desc>Times to transition through the splash effect. Up to 4 allowed. Values are 0.0 - 1.0, and corrispond to the life of the particle where 0 is first created and 1 is end of lifespace.</desc>
</field>
<field>
<name>velocity</name>
<desc>Velocity for the splash effect to travel.</desc>
</field>
<field>
<name>Width</name>
<desc>Width for the X and Y coordinates to create this effect within.</desc>
</field>
</class>
<class>
<name>SplashDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SpotLight</name>
<base>LightBase</base>
<field>
<name>innerAngle</name>
<desc>float innerAngle</desc>
</field>
<field>
<name>outerAngle</name>
<desc>float outerAngle</desc>
</field>
<field>
<name>range</name>
<desc>float range</desc>
</field>
</class>
<class>
<name>SpotLightClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>SQLiteObject</name>
<base>SimObject</base>
<method>
<name>clearResult</name>
<args>(int resultSet)</args>
<desc>Clears memory used by the specified result set, and deletes the result set.</desc>
</method>
<method>
<name>closeDatabase</name>
<desc>Closes the active database.</desc>
</method>
<method>
<name>endOfResult</name>
<args>(int resultSet)</args>
<desc>Checks to see if the internal pointer for the specified result set is at the end, indicating there are no more rows left to read.</desc>
</method>
<method>
<name>EOF</name>
<args>(int resultSet)</args>
<desc>Same as endOfResult().</desc>
</method>
<method>
<name>EOR</name>
<args>(int resultSet)</args>
<desc>Same as endOfResult().</desc>
</method>
<method>
<name>escapeString</name>
<args>(string)</args>
<desc>Escapes the given string, making it safer to pass into a query.</desc>
</method>
<method>
<name>firstRow</name>
<args>(int resultSet)</args>
<desc>Moves the result set's row pointer to the very first row in the result set.</desc>
</method>
<method>
<name>getColumn</name>
<args>(resultSet column)</args>
<desc>Returns the value of the specified column (Column can be specified by name or index) in the current row of the specified result set. If the call fails, the returned string will indicate the error.</desc>
</method>
<method>
<name>getColumnIndex</name>
<args>(resultSet columnName)</args>
<desc>Looks up the specified column name in the specified result set, and returns the columns index number.  A return value of 0 indicates the lookup failed for some reason (usually this indicates you specified a column name that doesn't exist or is spelled wrong).</desc>
</method>
<method>
<name>getColumnName</name>
<args>(resultSet columnIndex)</args>
<desc>Looks up the specified column index in the specified result set, and returns the column's name.  A return value of an empty string indicates the lookup failed for some reason (usually this indicates you specified a column index that is invalid or exceeds the number of columns in the result set). Columns are index starting with 1 not 0</desc>
</method>
<method>
<name>getRow</name>
<args>(int resultSet)</args>
<desc>Returns what row the result set's row pointer is currently on.</desc>
</method>
<method>
<name>lastRow</name>
<args>(int resultSet)</args>
<desc>Moves the result set's row pointer to the very last row in the result set.</desc>
</method>
<method>
<name>nextRow</name>
<args>(int resultSet)</args>
<desc>Moves the result set's row pointer to the next row.</desc>
</method>
<method>
<name>numColumns</name>
<args>(int resultSet)</args>
<desc>Returns the number of columns in the result set.</desc>
</method>
<method>
<name>numRows</name>
<args>(int resultSet)</args>
<desc>Returns the number of rows in the result set.</desc>
</method>
<method>
<name>openDatabase</name>
<args>(const char* filename)</args>
<desc>Opens the database specifed by filename.  Returns true or false.</desc>
</method>
<method>
<name>previousRow</name>
<args>(int resultSet)</args>
<desc>Moves the result set's row pointer to the previous row</desc>
</method>
<method>
<name>query</name>
<args>(const char* sql, int mode)</args>
<desc>Performs an SQL query on the open database and returns an identifier to a valid result set. mode is currently unused, and is reserved for future use.</desc>
</method>
<method>
<name>setRow</name>
<args>(int resultSet int row)</args>
<desc>Moves the result set's row pointer to the row specified.  Row indices start at 1 not 0.</desc>
</method>
</class>
<class>
<name>SQLiteObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>StaticShape</name>
<base>ShapeBase</base>
<method>
<name>getPoweredState</name>
<desc>@internal</desc>
</method>
<method>
<name>setPoweredState</name>
<args>(bool isPowered)</args>
<desc>@internal</desc>
</method>
</class>
<class>
<name>StaticShapeClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>StaticShapeData</name>
<base>ShapeBaseData</base>
<field>
<name>dynamicType</name>
<desc>An integer value which, if speficied, is added to the value retured by getType().</desc>
</field>
<field>
<name>noIndividualDamage</name>
<desc>Deprecated

@internal</desc>
</field>
</class>
<class>
<name>StaticShapeDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>StreamObject</name>
<base>SimObject</base>
<method>
<name>copyFrom</name>
<args>(StreamObject other)</args>
</method>
<method>
<name>getPosition</name>
<args>()</args>
<desc>@brief Gets the position in the stream

The easiest way to visualize this is to think of a cursor in a text file. If you have moved the cursor by five characters, the current position is 5. If you move ahead 10 more characters, the position is now 15. For StreamObject, when you read in the line the position is increased by the number of characters parsed, the null terminator, and a newline.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
// This file contains two lines of text repeated:
// Hello World
// Hello World
%fsObject.open("./test.txt", "read");

// Read in the first line
%line = %fsObject.readLine();

// Get the position of the stream
%position = %fsObject.getPosition();

// Print the current position
// Should be 13, 10 for the words, 1 for the space, 1 for the null terminator, and 1 for the newline
echo(%position);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return Number of bytes which stream has parsed so far, null terminators and newlines are included</desc>
</method>
<method>
<name>getStatus</name>
<args>()</args>
<desc>@brief Gets a printable string form of the status

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Get the status and print it
%status = %fsObject.getStatus();
echo(%status);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return String containing status constant, one of the following:

^OK - Stream is active and no file errors

^IOError - Something went wrong during read or writing the stream

^EOS - An unsupported operation used.  Always w/ accompanied by AssertWarn

^IllegalCall - Tried to operate on a closed stream (or detached filter)

^UnknownError - Catchall for an error of some kind

^Invalid - Entire stream is invalid</desc>
</method>
<method>
<name>getStreamSize</name>
<args>()</args>
<desc>@brief Gets the size of the stream

The size is dependent on the type of stream being used. If it is a file stream, returned value will be the size of the file. If it is a memory stream, it will be the size of the allocated buffer.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
// This file contains the following two lines:
// HelloWorld
// HelloWorld
%fsObject.open("./test.txt", "read");

// Found out how large the file stream is
// Then print it to the console
// Should be 22
%streamSize = %fsObject.getStreamSize();
echo(%streamSize);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return Size of stream, in bytes</desc>
</method>
<method>
<name>isEOF</name>
<args>()</args>
<desc>@brief Tests if the stream has reached the end of the file

This is an alternative name for isEOS. Both functions are interchangeable. This simply exists for those familiar with some C++ file I/O standards.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Keep reading until we reach the end of the file
while( !%fsObject.isEOF() )
{
%line = %fsObject.readLine();
echo(%line);
}
// Made it to the end
echo("Finished reading file");

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return True if the parser has reached the end of the file, false otherwise
@hide</desc>
</method>
<method>
<name>isEOS</name>
<args>()</args>
<desc>@brief Tests if the stream has reached the end of the file

This is an alternative name for isEOF. Both functions are interchangeable. This simply exists for those familiar with some C++ file I/O standards.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
%fsObject.open("./test.txt", "read");

// Keep reading until we reach the end of the file
while( !%fsObject.isEOS() )
{
%line = %fsObject.readLine();
echo(%line);
}
// Made it to the end
echo("Finished reading file");

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return True if the parser has reached the end of the file, false otherwise</desc>
</method>
<method>
<name>readLine</name>
<args>()</args>
<desc>@brief Read a line from the stream.

Emphasis on *line*, as in you cannot parse individual characters or chunks of data. There is no limitation as to what kind of data you can read.

@tsexample
// Create a file stream object for reading
// This file contains the following two lines:
// HelloWorld
// HelloWorld
%fsObject = new FileStreamObject();

%fsObject.open("./test.txt", "read");

// Read in the first line
%line = %fsObject.readLine();

// Print the line we just read
echo(%line);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return String containing the line of data that was just read</desc>
</method>
<method>
<name>readLongString</name>
<args>(maxLength)</args>
</method>
<method>
<name>readString</name>
<args>()</args>
<desc>@brief This function should be deprecated@hide</desc>
</method>
<method>
<name>readSTString</name>
<args>([caseSensitive = false])</args>
</method>
<method>
<name>setPosition</name>
<args>( int newPosition )</args>
<desc>@brief Gets the position in the stream

The easiest way to visualize this is to think of a cursor in a text file. If you have moved the cursor by five characters, the current position is 5. If you move ahead 10 more characters, the position is now 15. For StreamObject, when you read in the line the position is increased by the number of characters parsed, the null terminator, and a newline. Using setPosition allows you to skip to specific points of the file.

@tsexample
// Create a file stream object for reading
%fsObject = new FileStreamObject();

// Open a file for reading
// This file contains the following two lines:
// 11111111111
// Hello World
%fsObject.open("./test.txt", "read");

// Skip ahead by 12, which will bypass the first line entirely
%fsObject.setPosition(12);

// Read in the next line
%line = %fsObject.readLine();

// Print the line just read in, should be "Hello World"
echo(%line);

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample

@return Number of bytes which stream has parsed so far, null terminators and newlines are included</desc>
</method>
<method>
<name>writeLine</name>
<args>( string line )</args>
<desc>@brief Write a line to the stream, if it was opened for writing.

There is no limit as to what kind of data you can write. Any format and data is allowable, not just text. Be careful of what you write, as whitespace, current values, and literals will be preserved.

@param line The data we are writing out to file.@tsexample
// Create a file stream
%fsObject = new FileStreamObject();

// Open the file for writing
// If it does not exist, it is created. If it does exist, the file is cleared
%fsObject.open("./test.txt", "write");

// Write a line to the file
%fsObject.writeLine("Hello World");

// Write another line to the file
%fsObject.writeLine("Documentation Rocks!");

// Always remember to close a file stream when finished
%fsObject.close();
@endtsexample</desc>
</method>
<method>
<name>writeLongString</name>
<args>(maxLength, string)</args>
</method>
<method>
<name>writeString</name>
<args>(string, [maxLength = 255])</args>
</method>
</class>
<class>
<name>StreamObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Sun</name>
<base>SceneObject</base>
<method>
<name>animate</name>
<desc>animate( F32 duration, F32 startAzimuth, F32 endAzimuth, F32 startElevation, F32 endElevation )</desc>
</method>
<method>
<name>apply</name>
</method>
<field>
<name>ambient</name>
<desc>Color shading applied to surfaces not in direct contact with light source, such as in the shadows or interiors.</desc>
</field>
<field>
<name>attenuationRatio</name>
<desc>The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.</desc>
</field>
<field>
<name>azimuth</name>
<desc>The horizontal angle of the sun measured clockwise from the positive Y world axis.</desc>
</field>
<field>
<name>brightness</name>
<desc>Adjust the Sun's global contrast/intensity</desc>
</field>
<field>
<name>castShadows</name>
<desc>Enables/disables shadows cast by objects due to Sun light</desc>
</field>
<field>
<name>color</name>
<desc>Color shading applied to surfaces in direct contact with light source.</desc>
</field>
<field>
<name>cookie</name>
<desc>A custom pattern texture which is projected from the light.</desc>
</field>
<field>
<name>coronaEnabled</name>
<desc>Enable or disable rendering of the corona sprite.</desc>
</field>
<field>
<name>coronaMaterial</name>
<desc>Texture for the corona sprite.</desc>
</field>
<field>
<name>coronaScale</name>
<desc>Controls size the corona sprite renders, specified as a fractional amount of the screen height.</desc>
</field>
<field>
<name>coronaTint</name>
<desc>Modulates the corona sprite color ( if coronaUseLightColor is false ).</desc>
</field>
<field>
<name>coronaUseLightColor</name>
<desc>Modulate the corona sprite color by the color of the light ( overrides coronaTint ).</desc>
</field>
<field>
<name>elevation</name>
<desc>The elevation angle of the sun above or below the horizon.</desc>
</field>
<field>
<name>fadeStartDistance</name>
<desc>Start fading shadows out at this distance.  0 = auto calculate this distance.</desc>
</field>
<field>
<name>flareScale</name>
<desc>Changes the size and intensity of the flare.</desc>
</field>
<field>
<name>flareType</name>
<desc>Datablock for the flare produced by the Sun</desc>
</field>
<field>
<name>includeLightmappedGeometryInShadow</name>
<desc>This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>lastSplitTerrainOnly</name>
<desc>This toggles only terrain being rendered to the last split of a PSSM shadow map.</desc>
</field>
<field>
<name>logWeight</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>numSplits</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>overDarkFactor</name>
<desc>The ESM shadow darkening factor</desc>
</field>
<field>
<name>representedInLightmap</name>
<desc>This light is represented in lightmaps (static light, default: false)</desc>
</field>
<field>
<name>shadowDarkenColor</name>
<desc>The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>shadowDistance</name>
<desc>The distance from the camera to extend the PSSM shadow.</desc>
</field>
<field>
<name>shadowSoftness</name>
<desc>float shadowSoftness</desc>
</field>
<field>
<name>shadowType</name>
<desc>The type of shadow to use on this light.</desc>
</field>
<field>
<name>texSize</name>
<desc>The texture size of the shadow map.</desc>
</field>
</class>
<class>
<name>SunClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TCPGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>TCPObject</name>
<base>SimObject</base>
<method>
<name>connect</name>
<args>( string address )</args>
<desc>Connect to the given address.
@param address Server address to connect to.
@tsexample
// Set the address.
%address = "www.TorquePowered.com";

// Inform this TCPObject to connect to the specified address.
%thisTCPObj.connect(%address);
@endtsexample
@ingroup Platform</desc>
</method>
<method>
<name>disconnect</name>
<args>()</args>
<desc>Disconnect from whatever this TCPObject is currently connected to, if anything.
@tsexample
// Inform this TCPObject to disconnect from anything it is currently connected to.
%thisTCPObj.disconnect();
@endtsexample
@ingroup Platform</desc>
</method>
<method>
<name>listen</name>
<args>( int port )</args>
<desc>Start listening on the specified port for connections.
@param port Port for this TCPObject to start listening for connections on.
@tsexample
// Set the port number list
%portNumber = 80;

// Inform this TCPObject to start listening at the specified port.
%thisTCPObj.send(%portNumber);
@endtsexample
@ingroup Platform</desc>
</method>
<method>
<name>send</name>
<args>( string data )</args>
<desc>Transmits the data string to the server.
@param data The data string to send back to the server.
@tsexample
// Set the command data
%data = ""GET " @ $RSSFeed::serverURL @ " HTTP/1.0
Host: " @ $RSSFeed::serverName @ "\nUser-Agent: " @ $RSSFeed::userAgent @ "\n\r\n\r\n""

// Send the command back to the active server.
%thisTCPObj.send(%data);
@endtsexample
@ingroup Platform</desc>
</method>
<field>
<name>onConnected()</name>
<desc>Called whenever a connection is established with a server.</desc>
</field>
<field>
<name>onConnectFailed()</name>
<desc>Called whenever a connection has failed to be established with a server.</desc>
</field>
<field>
<name>onConnectionRequest( string address, string ID )</name>
<desc>Called whenever a connection request is made.
@param address Server address to connect to.
@param ID Connection ID</desc>
</field>
<field>
<name>onDisconnect()</name>
<desc>Called whenever the TCPObject disconnects from whatever it is currently connected to.</desc>
</field>
<field>
<name>onDNSFailed()</name>
<desc>Called whenever the DNS has failed to resolve.</desc>
</field>
<field>
<name>onDNSResolved()</name>
<desc>Called whenever the DNS has been resolved.</desc>
</field>
<field>
<name>onLine( string line )</name>
<desc>Called whenever a line of data is sent from the server connected to this TCPObject to the game client.
@param line Data sent from the server.</desc>
</field>
</class>
<class>
<name>TCPObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TerrainBlock</name>
<base>SceneObject</base>
<method>
<name>createNew</name>
<desc>TerrainBlock.create( String terrainName, U32 resolution, String materialName, bool genNoise )</desc>
</method>
<method>
<name>exportHeightMap</name>
<args>(string filename, [string format])</args>
<desc>export the terrain block's heightmap to a bitmap file (default: png)</desc>
</method>
<method>
<name>exportLayerMaps</name>
<args>(string filePrefix, [string format])</args>
<desc>export the terrain block's layer maps to bitmap files (default: png)</desc>
</method>
<method>
<name>import</name>
<args>( String terrainName, String heightMap, F32 metersPerPixel, F32 heightScale, String materials, String opacityLayers )</args>
</method>
<method>
<name>save</name>
<args>( string fileName )</args>
<desc>@brief Saves the terrain block's terrain file to the specified file name.

@param fileName Name and path of file to save terrain data to.

@return True if file save was successful, false otherwise</desc>
</method>
<field>
<name>baseTexSize</name>
<desc>Size of base texture size per meter.</desc>
</field>
<field>
<name>lightMapSize</name>
<desc>Light map dimensions in pixels.</desc>
</field>
<field>
<name>screenError</name>
<desc>Not yet implemented.</desc>
</field>
<field>
<name>squareSize</name>
<desc>Indicates the spacing between points on the XY plane on the terrain.</desc>
</field>
<field>
<name>terrainFile</name>
<desc>The source terrain data file.</desc>
</field>
</class>
<class>
<name>TerrainBlockClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TerrainEditor</name>
<base>EditTSCtrl</base>
<method>
<name>addMaterial</name>
<args>( string matName )</args>
<desc>Adds a new material.</desc>
</method>
<method>
<name>attachTerrain</name>
<args>(TerrainBlock terrain)</args>
</method>
<method>
<name>clearSelection</name>
</method>
<method>
<name>getActionName</name>
<args>(int num)</args>
</method>
<method>
<name>getActiveTerrain</name>
</method>
<method>
<name>getBrushPos</name>
<desc>Returns a Point2I.</desc>
</method>
<method>
<name>getBrushPressure</name>
<args>()</args>
</method>
<method>
<name>getBrushSize</name>
<args>()</args>
</method>
<method>
<name>getBrushSoftness</name>
<args>()</args>
</method>
<method>
<name>getBrushType</name>
<args>()</args>
</method>
<method>
<name>getCurrentAction</name>
</method>
<method>
<name>getMaterialCount</name>
<desc>Returns the current material count.</desc>
</method>
<method>
<name>getMaterialIndex</name>
<args>( string name )</args>
<desc>Returns the index of the material with the given name or -1.</desc>
</method>
<method>
<name>getMaterialName</name>
<args>( int index )</args>
<desc>Returns the name of the material at the given index.</desc>
</method>
<method>
<name>getMaterials</name>
<args>()</args>
<desc>gets the list of current terrain materials.</desc>
</method>
<method>
<name>getNumActions</name>
</method>
<method>
<name>getNumTextures</name>
</method>
<method>
<name>getSlopeLimitMaxAngle</name>
</method>
<method>
<name>getSlopeLimitMinAngle</name>
</method>
<method>
<name>getTerrainBlock</name>
<args>(S32 index)</args>
</method>
<method>
<name>getTerrainBlockCount</name>
<args>()</args>
</method>
<method>
<name>getTerrainBlocksMaterialList</name>
<args>()</args>
<desc>gets the list of current terrain materials for all terrain blocks.</desc>
</method>
<method>
<name>getTerrainUnderWorldPoint</name>
<args>(x/y/z)</args>
<desc>Gets the terrain block that is located under the given world point.
@param x/y/z The world coordinates (floating point values) you wish to query at. These can be formatted as either a string ("x y z") or separately as (x, y, z)
@return Returns the ID of the requested terrain block (0 if not found).</desc>
</method>
<method>
<name>markEmptySquares</name>
</method>
<method>
<name>mirrorTerrain</name>
</method>
<method>
<name>processAction</name>
<args>(string action=NULL)</args>
</method>
<method>
<name>removeMaterial</name>
<args>( int index )</args>
<desc>Remove the material at the given index.</desc>
</method>
<method>
<name>reorderMaterial</name>
<args>( int index, int order )</args>
<desc>Reorder material at the given index to the new position, changing the order in which it is rendered / blended.</desc>
</method>
<method>
<name>resetSelWeights</name>
<args>(bool clear)</args>
</method>
<method>
<name>setAction</name>
<args>(string action_name)</args>
</method>
<method>
<name>setBrushPos</name>
<args>(int x, int y)</args>
</method>
<method>
<name>setBrushPressure</name>
<args>(float pressure)</args>
</method>
<method>
<name>setBrushSize</name>
<args>(int w [, int h])</args>
</method>
<method>
<name>setBrushSoftness</name>
<args>(float softness)</args>
</method>
<method>
<name>setBrushType</name>
<args>(string type)</args>
<desc>One of box, ellipse, selection.</desc>
</method>
<method>
<name>setSlopeLimitMaxAngle</name>
</method>
<method>
<name>setSlopeLimitMinAngle</name>
</method>
<method>
<name>setTerraformOverlay</name>
<args>(bool overlayEnable)</args>
<desc>sets the terraformer current heightmap to draw as an overlay over the current terrain.</desc>
</method>
<method>
<name>updateMaterial</name>
<args>( int index, string matName )</args>
<desc>Changes the material name at the index.</desc>
</method>
<field>
<name>adjustHeightMouseScale</name>
<desc>float adjustHeightMouseScale</desc>
</field>
<field>
<name>adjustHeightVal</name>
<desc>float adjustHeightVal</desc>
</field>
<field>
<name>borderFillColor</name>
<desc>ColorI borderFillColor</desc>
</field>
<field>
<name>borderFrameColor</name>
<desc>ColorI borderFrameColor</desc>
</field>
<field>
<name>borderHeight</name>
<desc>float borderHeight</desc>
</field>
<field>
<name>borderLineMode</name>
<desc>bool borderLineMode</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>isMissionDirty</name>
<desc>bool isMissionDirty</desc>
</field>
<field>
<name>materialGroup</name>
<desc>int materialGroup</desc>
</field>
<field>
<name>maxBrushSize</name>
<desc>Point2I maxBrushSize</desc>
</field>
<field>
<name>noiseFactor</name>
<desc>float noiseFactor</desc>
</field>
<field>
<name>paintIndex</name>
<desc>int paintIndex</desc>
</field>
<field>
<name>processUsesBrush</name>
<desc>bool processUsesBrush</desc>
</field>
<field>
<name>renderBorder</name>
<desc>bool renderBorder</desc>
</field>
<field>
<name>renderSolidBrush</name>
<desc>bool renderSolidBrush</desc>
</field>
<field>
<name>renderVertexSelection</name>
<desc>bool renderVertexSelection</desc>
</field>
<field>
<name>scaleVal</name>
<desc>float scaleVal</desc>
</field>
<field>
<name>selectionHidden</name>
<desc>bool selectionHidden</desc>
</field>
<field>
<name>setHeightVal</name>
<desc>float setHeightVal</desc>
</field>
<field>
<name>smoothFactor</name>
<desc>float smoothFactor</desc>
</field>
<field>
<name>softSelectDefaultFilter</name>
<desc>string softSelectDefaultFilter</desc>
</field>
<field>
<name>softSelectFilter</name>
<desc>string softSelectFilter</desc>
</field>
<field>
<name>softSelectRadius</name>
<desc>float softSelectRadius</desc>
</field>
</class>
<class>
<name>TerrainEditorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TerrainMaterial</name>
<base>SimObject</base>
<field>
<name>detailDistance</name>
<desc>Changes how far camera can see the detail map rendering on the material</desc>
</field>
<field>
<name>detailMap</name>
<desc>Detail map for the material</desc>
</field>
<field>
<name>detailSize</name>
<desc>Used to scale the detail map to the material square</desc>
</field>
<field>
<name>detailStrength</name>
<desc>Exponentially sharpens or lightens the detail map rendering on the material</desc>
</field>
<field>
<name>diffuseMap</name>
<desc>Base texture for the material</desc>
</field>
<field>
<name>diffuseSize</name>
<desc>Used to scale the diffuse map to the material square</desc>
</field>
<field>
<name>normalMap</name>
<desc>Bump map for the material</desc>
</field>
<field>
<name>parallaxScale</name>
<desc>Used to scale the height from the normal map to give some self occlusion effect (aka parallax) to the terrain material</desc>
</field>
<field>
<name>useSideProjection</name>
<desc>Makes that terrain material project along the sides of steep slopes instead of projected downwards</desc>
</field>
</class>
<class>
<name>TerrainMaterialClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TerrainMaterialSet</name>
<base>SimSet</base>
</class>
<class>
<name>TerrainSmoothAction</name>
<base>UndoAction</base>
<method>
<name>smooth</name>
<args>( TerrainBlock obj, F32 factor, U32 steps )</args>
</method>
</class>
<class>
<name>TerrainSmoothActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TimeOfDay</name>
<base>SceneObject</base>
<method>
<name>addTimeOfDayEvent</name>
<desc>addTimeOfDayEvent( triggerElevation, identifierString )</desc>
</method>
<method>
<name>animate</name>
<args>( time, speed )</args>
</method>
<method>
<name>setDayLength</name>
<desc>setDayLength( time )</desc>
</method>
<method>
<name>setPlay</name>
<desc>setPlay( bool )</desc>
</method>
<method>
<name>setTimeOfDay</name>
<desc>setTimeOfDay( time )</desc>
</method>
<field>
<name>axisTilt</name>
<desc>The angle in degrees between global equator and tropic.</desc>
</field>
<field>
<name>azimuthOverride</name>
<desc>float azimuthOverride</desc>
</field>
<field>
<name>dayLength</name>
<desc>The length of a virtual day in real world seconds.</desc>
</field>
<field>
<name>dayScale</name>
<desc>Scalar applied to time that elapses while the sun is up.</desc>
</field>
<field>
<name>nightScale</name>
<desc>Scalar applied to time that elapses while the sun is down.</desc>
</field>
<field>
<name>play</name>
<desc>True when the TimeOfDay object is operating.</desc>
</field>
<field>
<name>startTime</name>
<desc>float startTime</desc>
</field>
<field>
<name>time</name>
<desc>Current time of day.</desc>
</field>
</class>
<class>
<name>TimeOfDayClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Trigger</name>
<base>GameBase</base>
<method>
<name>getNumObjects</name>
</method>
<method>
<name>getObject</name>
<args>(int idx)</args>
</method>
<field>
<name>enterCommand</name>
<desc>The command to execute when an object enters this trigger. Object id stored in %obj. Maximum 1023 characters.</desc>
</field>
<field>
<name>leaveCommand</name>
<desc>The command to execute when an object leaves this trigger. Object id stored in %obj. Maximum 1023 characters.</desc>
</field>
<field>
<name>onAdd( int objectId )</name>
<desc>Called when the Trigger is being created.
@param objectId the object id of the Trigger being created</desc>
</field>
<field>
<name>onRemove( int objectId )</name>
<desc>Called when the before the Trigger is deleted.
@param objectId the object id of the Trigger being deleted</desc>
</field>
<field>
<name>polyhedron</name>
<desc>The polyhedron type is really a quadrilateral and consists of a cornerpoint followed by three vectors representing the edges extending from the corner.</desc>
</field>
<field>
<name>tickCommand</name>
<desc>The command to execute while an object is inside this trigger. Maximum 1023 characters.</desc>
</field>
</class>
<class>
<name>TriggerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TriggerData</name>
<base>GameBaseData</base>
<field>
<name>clientSide</name>
<desc>Forces Trigger callbacks to only be called on clients.</desc>
</field>
<field>
<name>onEnterTrigger( Trigger trigger, GameBase obj )</name>
<desc>Called when an object enters the volume of the Trigger instance using this TriggerData.
@param trigger the Trigger instance whose volume the object entered
@param obj the object that entered the volume of the Trigger instance</desc>
</field>
<field>
<name>onLeaveTrigger( Trigger trigger, GameBase obj )</name>
<desc>Called when an object leaves the volume of the Trigger instance using this TriggerData.
@param trigger the Trigger instance whose volume the object left
@param obj the object that left the volume of the Trigger instance</desc>
</field>
<field>
<name>onTickTrigger( Trigger trigger )</name>
<desc>Called every tickPeriodMS number of milliseconds as specified in the TriggerData whenever one or more objects are inside the volume of the trigger.
@param trigger the Trigger instance whose volume the object is inside</desc>
</field>
<field>
<name>tickPeriodMS</name>
<desc>Time in milliseconds between calls to TriggerData::onTickTrigger().</desc>
</field>
</class>
<class>
<name>TriggerDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TSForestItemData</name>
<base>ForestItemData</base>
</class>
<class>
<name>TSForestItemDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TSShapeConstructor</name>
<base>SimObject</base>
<method>
<name>addCollisionDetail</name>
<args>( int size, string type, string target, int depth=4, float merge=30, float concavity=30, int maxVerts=32, float boxMaxError=0, float sphereMaxError=0, float capsuleMaxError=0 )</args>
<desc>Autofit a mesh primitive or set of convex hulls to the shape geometry. Hulls may optionally be converted to boxes, spheres and/or capsules based on their volume.
@param size size for this detail level
@param type one of: box, sphere, capsule, 10-dop x, 10-dop y, 10-dop z, 18-dop, 26-dop, convex hulls. See the Shape Editor documentation for more details about these types.
@param target geometry to fit collision mesh(es) to; either "bounds" (for the whole shape), or the name of an object in the shape
@param depth maximum split recursion depth (hulls only)
@param merge volume % threshold used to merge hulls together (hulls only)
@param concavity volume % threshold used to detect concavity (hulls only)
@param maxVerts maximum number of vertices per hull (hulls only)
@param boxMaxError max % volume difference for a hull to be converted to a box (hulls only)
@param sphereMaxError max % volume difference for a hull to be converted to a sphere (hulls only)
@param capsuleMaxError max % volume difference for a hull to be converted to a capsule (hulls only)
@return true if successful, false otherwise

@tsexample
%this.addCollisionDetail( "ColConvex", "bounds", 4, 20, 30, 32, 50, 50, 50, "Col-1" );
@endtsexample</desc>
</method>
<method>
<name>addImposter</name>
<args>( int size, int equatorSteps, int polarSteps, int dl, int dim, bool includePoles, float polarAngle )</args>
<desc>Add (or edit) an imposter detail level to the shape.
If the shape already contains an imposter detail level, this command will simply change the imposter settings
@param size size of the imposter detail level
@param equatorSteps defines the number of snapshots to take around the equator. Imagine the object being rotated around the vertical axis, then a snapshot taken at regularly spaced intervals.
@param polarSteps defines the number of snapshots taken between the poles (top and bottom), at each equator step. eg. At each equator snapshot, snapshots are taken at regular intervals between the poles.
@param dl the detail level to use when generating the snapshots. Note that this is an array index rather than a detail size. So if an object has detail sizes of: 200, 150, and 40, then setting dl to 1 will generate the snapshot using detail size 150.
@param dim defines the size of the imposter images in pixels. The larger the number, the more detailed the billboard will be.
@param includePoles flag indicating whether to include the "pole" snapshots. ie. the views from the top and bottom of the object.
@param polar_angle if pole snapshots are active (includePoles is true), this parameter defines the camera angle (in degrees) within which to render the pole snapshot. eg. if polar_angle is set to 25 degrees, then the snapshot taken at the pole (looking directly down or up at the object) will be rendered when the camera is within 25 degrees of the pole.
@return true if successful, false otherwise

@tsexample
%this.addImposter( 2, 4, 0, 0, 64, false, 0 );
%this.addImposter( 2, 4, 2, 0, 64, true, 10 );   // this command would edit the existing imposter detail level
@endtsexample</desc>
</method>
<method>
<name>addMesh</name>
<args>( string meshName, string srcShape, string srcMesh )</args>
<desc>Add geometry from another DTS or DAE shape file into this shape.
Any materials required by the source mesh are also copied into this shape.&lt;br&gt;
@param meshName full name (object name + detail size) of the new mesh. If no detail size is present at the end of the name, a value of 2 is used.&lt;br&gt;An underscore before the number at the end of the name will be interpreted as a negative sign. eg. "MyMesh_4" will be interpreted as "MyMesh-4".
@param srcShape name of a shape file (DTS or DAE) that contains the mesh
@param srcMesh the full name (object name + detail size) of the mesh to copy from the DTS/DAE file into this shape&lt;/li&gt;@return true if successful, false otherwise

@tsexample
%this.addMesh( "ColMesh-1", "./collision.dts", "ColMesh", "Col-1" );
%this.addMesh( "SimpleShape10", "./testShape.dae", "MyMesh2",  );
@endtsexample</desc>
</method>
<method>
<name>addNode</name>
<args>( string name, string parentName, TransformF txfm=TransformF::Identity, bool isWorld=false )</args>
<desc>Add a new node.
@param name name for the new node (must not already exist)
@param parentName name of an existing node to be the parent of the new node. If empty (""), the new node will be at the root level of the node hierarchy.
@param txfm (optional) transform string of the form: "pos.x pos.y pos.z rot.x rot.y rot.z rot.angle]"
@param isworld (optional) flag to set the local-to-parent or the global transform. If false, or not specified, the position and orientation are treated as relative to the node's parent.
@return true if successful, false otherwise

@tsexample
%this.addNode( "Nose", "Bip01 Head", "0 2 2 0 0 1 0" );
%this.addNode( "myRoot", "", "0 0 4 0 0 1 1.57" );
%this.addNode( "Nodes", "Bip01 Head", "0 2 0 0 0 1 0", true );
@endtsexample</desc>
</method>
<method>
<name>addPrimitive</name>
<args>( string meshName, string type, string params, TransformF txfm, string nodeName )</args>
<desc>Add a new mesh primitive to the shape.
@param meshName full name (object name + detail size) of the new mesh. If no detail size is present at the end of the name, a value of 2 is used.&lt;br&gt;An underscore before the number at the end of the name will be interpreted as a negative sign. eg. "MyMesh_4" will be interpreted as "MyMesh-4".
@param type one of: "box", "sphere", "capsule"
@param params mesh primitive parameters:
&lt;ul&gt;&lt;li&gt;for box: "size_x size_y size_z"&lt;/li&gt;&lt;li&gt;for sphere: "radius"&lt;/li&gt;&lt;li&gt;for capsule: "height radius"&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
@param txfm local transform offset from the node for this mesh
@param nodeName name of the node to attach the new mesh to (will change the object's node if adding a new mesh to an existing object)
@return true if successful, false otherwise

@tsexample
%this.addMesh( "Box4", "box", "2 4 2", "0 2 0 0 0 1 0", "eye" );
%this.addMesh( "Sphere256", "sphere", "2", "0 0 0 0 0 1 0", "root" );
%this.addMesh( "MyCapsule-1", "capsule", "2 5", "0 0 2 0 0 1 0", "base01" );
@endtsexample</desc>
</method>
<method>
<name>addSequence</name>
<args>( string source, string name, int start=0, int end=-1 )</args>
<desc>Add a new sequence to the shape.
@param source the name of an existing sequence, or the name of a DTS or DAE shape or DSQ sequence file. When the shape file contains more than one sequence, the desired sequence can be specified by appending the name to the end of the shape file. eg. "myShape.dts run" would select the "run" sequence from the "myShape.dts" file.
@param name name of the new sequence
@param start (optional) first frame to copy. Defaults to 0, the first frame in the sequence.
@param end (optional) last frame to copy. Defaults to -1, the last frame in the sequence.
@return true if successful, false otherwise

@tsexample
%this.addSequence( "./testShape.dts ambient", "ambient" );
%this.addSequence( "./myPlayer.dae run", "run" );
%this.addSequence( "./player_look.dsq", "look", 0, -1 );     // start to end
%this.addSequence( "walk", "walk_shortA", 0, 4 );            // start to frame 4
%this.addSequence( "walk", "walk_shortB", 4, -1 );           // frame 4 to end
@endtsexample</desc>
</method>
<method>
<name>addTrigger</name>
<args>( string name, int keyframe, int state )</args>
<desc>Add a new trigger to the sequence.
@param name name of the sequence to modify
@param keyframe keyframe of the new trigger
@param state of the new trigger
@return true if successful, false otherwise

@tsexample
%this.addTrigger( "walk", 3, 1 );
%this.addTrigger( "walk", 5, -1 );
@endtsexample</desc>
</method>
<method>
<name>dumpShape</name>
<args>( string filename="" )</args>
<desc>Dump the shape hierarchy to the console or to a file. Useful for reviewing the result of a series of construction commands.
@param filename Destination filename. If not specified, dump to console.

@tsexample
%this.dumpShape();               // dump to console
%this.dumpShape( "./dump.txt" ); // dump to file
@endtsexample</desc>
</method>
<method>
<name>getBounds</name>
<args>()</args>
<desc>Get the bounding box for the shape.
@return Bounding box "minX minY minZ maxX maxY maxZ"</desc>
</method>
<method>
<name>getDetailLevelCount</name>
<args>()</args>
<desc>Get the total number of detail levels in the shape.
@return the number of detail levels in the shape</desc>
</method>
<method>
<name>getDetailLevelIndex</name>
<args>( int size )</args>
<desc>Get the index of the detail level with a given size.
@param size size of the detail level to lookup
@return index of the detail level with the desired size, or -1 if no suchdetail exists

@tsexample
if ( %this.getDetailLevelSize( 32 ) == -1 )   echo( "Error: This shape does not have a detail level at size 32" );@endtsexample</desc>
</method>
<method>
<name>getDetailLevelName</name>
<args>( int index )</args>
<desc>Get the name of the indexed detail level.
@param index detail level index (valid range is 0 - getDetailLevelCount()-1)
@return the detail level name

@tsexample
// print the names of all detail levels in the shape
%count = %this.getDetailLevelCount();
for ( %i = 0; %i &lt; %count; %i++ )
echo( %i SPC %this.getDetailLevelName( %i ) );
@endtsexample</desc>
</method>
<method>
<name>getDetailLevelSize</name>
<args>( int index )</args>
<desc>Get the size of the indexed detail level.
@param index detail level index (valid range is 0 - getDetailLevelCount()-1)
@return the detail level size

@tsexample
// print the sizes of all detail levels in the shape
%count = %this.getDetailLevelCount();
for ( %i = 0; %i &lt; %count; %i++ )
echo( "Detail" @ %i @ " has size " @ %this.getDetailLevelSize( %i ) );
@endtsexample</desc>
</method>
<method>
<name>getImposterDetailLevel</name>
<args>()</args>
<desc>Get the index of the imposter (auto-billboard) detail level (if any).
@return imposter detail level index, or -1 if the shape does not useimposters.</desc>
</method>
<method>
<name>getImposterSettings</name>
<args>( int index )</args>
<desc>Get the settings used to generate imposters for the indexed detail level.
@param index index of the detail level to query (does not need to be an imposter detail level
@return string of the form: "valid eqSteps pSteps dl dim poles angle", where:&lt;dl&gt;&lt;dt&gt;valid&lt;/dt&gt;&lt;dd&gt;1 if this detail level generates imposters, 0 otherwise&lt;/dd&gt;&lt;dt&gt;eqSteps&lt;/dt&gt;&lt;dd&gt;number of steps around the equator&lt;/dd&gt;&lt;dt&gt;pSteps&lt;/dt&gt;&lt;dd&gt;number of steps between the poles&lt;/dd&gt;&lt;dt&gt;dl&lt;/dt&gt;&lt;dd&gt;index of the detail level used to generate imposters&lt;/dd&gt;&lt;dt&gt;dim&lt;/dt&gt;&lt;dd&gt;size (in pixels) of each imposter image&lt;/dd&gt;&lt;dt&gt;poles&lt;/dt&gt;&lt;dd&gt;1 to include pole images, 0 otherwise&lt;/dd&gt;&lt;dt&gt;angle&lt;/dt&gt;&lt;dd&gt;angle at which to display pole images&lt;/dd&gt;&lt;/dl&gt;

@tsexample
// print the imposter detail level settings
%index = %this.getImposterDetailLevel();
if ( %index != -1 )
echo( "Imposter settings: " @ %this.getImposterSettings( %index ) );
@endtsexample</desc>
</method>
<method>
<name>getMeshCount</name>
<args>( string name )</args>
<desc>Get the number of meshes (detail levels) for the specified object.
@param name name of the object to query
@return the number of meshes for this object.

@tsexample
%count = %this.getMeshCount( "SimpleShape" );
@endtsexample</desc>
</method>
<method>
<name>getMeshMaterial</name>
<args>( string name )</args>
<desc>Get the name of the material attached to a mesh. Note that only the first material used by the mesh is returned.
@param name full name (object name + detail size) of the mesh to query
return name of the material attached to the mesh (suitable for use with the Material mapTo field)

@tsexample
echo( "Mesh material is " @ %this.sgetMeshMaterial( "SimpleShape128" ) );
@endtsexample</desc>
</method>
<method>
<name>getMeshName</name>
<args>( string name, int index )</args>
<desc>Get the name of the indexed mesh (detail level) for the specified object.
@param name name of the object to query
@param index index of the mesh (valid range is 0 - getMeshCount()-1)
@return the mesh name.

@tsexample
// print the names of all meshes in the shape
%objCount = %this.getObjectCount();
for ( %i = 0; %i &lt; %objCount; %i++ )
{
%objName = %this.getObjectName( %i );
%meshCount = %this.getMeshCount( %objName );
for ( %j = 0; %j &lt; %meshCount; %j++ )
echo( %this.getMeshName( %objName, %j ) );
}
@endtsexample</desc>
</method>
<method>
<name>getMeshSize</name>
<args>( string name, int index )</args>
<desc>Get the detail level size of the indexed mesh for the specified object.
@param name name of the object to query
@param index index of the mesh (valid range is 0 - getMeshCount()-1)
@return the mesh detail level size.

@tsexample
// print sizes for all detail levels of this object
%objName = "trunk";
%count = %this.getMeshCount( %objName );
for ( %i = 0; %i &lt; %count; %i++ )
echo( %this.getMeshSize( %objName, %i ) );
@endtsexample</desc>
</method>
<method>
<name>getMeshType</name>
<args>( string name )</args>
<desc>Get the display type of the mesh.
@param name name of the mesh to query
@return the string returned is one of:&lt;dl&gt;&lt;dt&gt;normal&lt;/dt&gt;&lt;dd&gt;a normal 3D mesh&lt;/dd&gt;&lt;dt&gt;billboard&lt;/dt&gt;&lt;dd&gt;a mesh that always faces the camera&lt;/dd&gt;&lt;dt&gt;billboardzaxis&lt;/dt&gt;&lt;dd&gt;a mesh that always faces the camera in the Z-axis&lt;/dd&gt;&lt;/dl&gt;

@tsexample
echo( "Mesh type is " @ %this.getMeshType( "SimpleShape128" ) );
@endtsexample</desc>
</method>
<method>
<name>getNodeChildCount</name>
<args>( string name )</args>
<desc>Get the number of children of this node.
@param name name of the node to query.
@return the number of child nodes.

@tsexample
%count = %this.getNodeChildCount( "Bip01 Pelvis" );
@endtsexample</desc>
</method>
<method>
<name>getNodeChildName</name>
<args>( string name, int index )</args>
<desc>Get the name of the indexed child node.
@param name name of the parent node to query.
@param index index of the child node (valid range is 0 - getNodeChildName()-1).
@return the name of the indexed child node.

@tsexample
function dumpNode( %shape, %name, %indent )
{
echo( %indent @ %name );
%count = %shape.getNodeChildCount( %name );
for ( %i = 0; %i &lt; %count; %i++ )
dumpNode( %shape, %shape.getNodeChildName( %name, %i ), %indent @ "   " );
}

function dumpShape( %shape )
{
// recursively dump node hierarchy
%count = %shape.getNodeCount();
for ( %i = 0; %i &lt; %count; %i++ )
{
// dump top level nodes
%name = %shape.getNodeName( %i );
if ( %shape.getNodeParentName( %name ) $=  )
dumpNode( %shape, %name, "" );
}
}
@endtsexample</desc>
</method>
<method>
<name>getNodeCount</name>
<args>()</args>
<desc>Get the total number of nodes in the shape.
@return the number of nodes in the shape.

@tsexample
%count = %this.getNodeCount();
@endtsexample</desc>
</method>
<method>
<name>getNodeIndex</name>
<args>( string name )</args>
<desc>Get the index of the node.
@param name name of the node to lookup.
@return the index of the named node, or -1 if no such node exists.

@tsexample
// get the index of Bip01 Pelvis node in the shape
%index = %this.getNodeIndex( "Bip01 Pelvis" );
@endtsexample</desc>
</method>
<method>
<name>getNodeName</name>
<args>( int index )</args>
<desc>Get the name of the indexed node.
@param index index of the node to lookup (valid range is 0 - getNodeCount()-1).
@return the name of the indexed node, or "" if no such node exists.

@tsexample
// print the names of all the nodes in the shape
%count = %this.getNodeCount();
for (%i = 0; %i &lt; %count; %i++)
echo(%i SPC %this.getNodeName(%i));
@endtsexample</desc>
</method>
<method>
<name>getNodeObjectCount</name>
<args>( string name )</args>
<desc>Get the number of geometry objects attached to this node.
@param name name of the node to query.
@return the number of attached objects.

@tsexample
%count = %this.getNodeObjectCount( "Bip01 Head" );
@endtsexample</desc>
</method>
<method>
<name>getNodeObjectName</name>
<args>( string name, int index )</args>
<desc>Get the name of the indexed object.
@param name name of the node to query.
@param index index of the object (valid range is 0 - getNodeObjectCount()-1).
@return the name of the indexed object.

@tsexample
// print the names of all objects attached to the node
%count = %this.getNodeObjectCount( "Bip01 Head" );
for ( %i = 0; %i &lt; %count; %i++ )
echo( %this.getNodeObjectName( "Bip01 Head", %i ) );
@endtsexample</desc>
</method>
<method>
<name>getNodeParentName</name>
<args>( string name )</args>
<desc>Get the name of the node's parent. If the node has no parent (ie. it is at the root level), return an empty string.
@param name name of the node to query.
@return the name of the node's parent, or "" if the node is at the root level

@tsexample
echo( "Bip01 Pelvis parent = " @ %this.getNodeParentName( "Bip01 Pelvis ") );
@endtsexample</desc>
</method>
<method>
<name>getNodeTransform</name>
<args>( string name, bool isWorld=false )</args>
<desc>Get the base (ie. not animated) transform of a node.
@param name name of the node to query.
@param isWorld true to get the global transform, false (or omitted) to get the local-to-parent transform.
@return the node transform in the form "pos.x pos.y pos.z rot.x rot.y rot.z rot.angle".

@tsexample
%ret = %this.getNodeTransform( "mount0" );
%this.setNodeTransform( "mount4", %ret );
@endtsexample</desc>
</method>
<method>
<name>getObjectCount</name>
<args>()</args>
<desc>Get the total number of objects in the shape.
@return the number of objects in the shape.

@tsexample
%count = %this.getObjectCount();
@endtsexample</desc>
</method>
<method>
<name>getObjectIndex</name>
<args>( string name )</args>
<desc>Get the index of the first object with the given name.
@param name name of the object to get.
@return the index of the named object.

@tsexample
%index = %this.getObjectIndex( "Head" );
@endtsexample</desc>
</method>
<method>
<name>getObjectName</name>
<args>( int index )</args>
<desc>Get the name of the indexed object.
@param index index of the object to get (valid range is 0 - getObjectCount()-1).
@return the name of the indexed object.

@tsexample
// print the names of all objects in the shape
%count = %this.getObjectCount();
for ( %i = 0; %i &lt; %count; %i++ )
echo( %i SPC %this.getObjectName( %i ) );
@endtsexample</desc>
</method>
<method>
<name>getObjectNode</name>
<args>( string name )</args>
<desc>Get the name of the node this object is attached to.
@param name name of the object to get.
@return the name of the attached node, or an empty string if this object is not attached to a node (usually the case for skinned meshes).

@tsexample
echo( "Hand is attached to " @ %this.getObjectNode( "Hand" ) );
@endtsexample</desc>
</method>
<method>
<name>getSequenceBlend</name>
<args>( string name )</args>
<desc>Get information about blended sequences.
@param name name of the sequence to query
@return TAB delimited string of the form: "isBlend blendSeq blendFrame", where:&lt;dl&gt;&lt;dt&gt;blend_flag&lt;/dt&gt;&lt;dd&gt;a boolean flag indicating whether this sequence is a blend&lt;/dd&gt;&lt;dt&gt;blend_seq_name&lt;/dt&gt;&lt;dd&gt;the name of the sequence that contains the reference frame (empty for blend sequences embedded in DTS files)&lt;/dd&gt;&lt;dt&gt;blend_seq_frame&lt;/dt&gt;&lt;dd&gt;the blend reference frame (empty for blend sequences embedded in DTS files)&lt;/dd&gt;&lt;/dl&gt;
@note Note that only sequences set to be blends using the setSequenceBlend command will contain the blendSeq and blendFrame information.

@tsexample
%blendData = %this.getSequenceBlend( "look" );
if ( getField( %blendData, 0 ) )
echo( "look is a blend, reference: " @ getField( %blendData, 1 ) );
@endtsexample</desc>
</method>
<method>
<name>getSequenceCount</name>
<args>()</args>
<desc>Get the total number of sequences in the shape.
@return the number of sequences in the shape</desc>
</method>
<method>
<name>getSequenceCyclic</name>
<args>( string name )</args>
<desc>Check if this sequence is cyclic (looping).
@param name name of the sequence to query
@return true if this sequence is cyclic, false if not

@tsexample
if ( !%this.getSequenceCyclic( "ambient" ) )
error( "ambient sequence is not cyclic!" );
@endtsexample</desc>
</method>
<method>
<name>getSequenceFrameCount</name>
<args>( string name )</args>
<desc>Get the number of keyframes in the sequence.
@param name name of the sequence to query
@return number of keyframes in the sequence

@tsexample
echo( "Run has " @ %this.getSequenceFrameCount( "run" ) @ " keyframes" );
@endtsexample</desc>
</method>
<method>
<name>getSequenceGroundSpeed</name>
<args>( string name )</args>
<desc>Get the ground speed of the sequence.
@note Note that only the first 2 ground frames of the sequence are examined; the speed is assumed to be constant throughout the sequence.
@param name name of the sequence to query
@return string of the form: "trans.x trans.y trans.z rot.x rot.y rot.z"

@tsexample
%speed = VectorLen( getWords( %this.getSequenceGroundSpeed( "run" ), 0, 2 ) );
echo( "Run moves at " @ %speed @ " units per frame" );
@endtsexample</desc>
</method>
<method>
<name>getSequenceIndex</name>
<args>( string name )</args>
<desc>Find the index of the sequence with the given name.
@param name name of the sequence to lookup
@return index of the sequence with matching name, or -1 if not found

@tsexample
// Check if a given sequence exists in the shape
if ( %this.getSequenceIndex( "walk" ) == -1 )
echo( "Could not find 'walk' sequence" );
@endtsexample</desc>
</method>
<method>
<name>getSequenceName</name>
<args>( int index )</args>
<desc>Get the name of the indexed sequence.
@param index index of the sequence to query (valid range is 0 - getSequenceCount()-1)
@return the name of the sequence

@tsexample
// print the name of all sequences in the shape
%count = %this.getSequenceCount();
for ( %i = 0; %i &lt; %count; %i++ )
echo( %i SPC %this.getSequenceName( %i ) );
@endtsexample</desc>
</method>
<method>
<name>getSequencePriority</name>
<args>( string name )</args>
<desc>Get the priority setting of the sequence.
@param name name of the sequence to query
@return priority value of the sequence</desc>
</method>
<method>
<name>getSequenceSource</name>
<args>( string name )</args>
<desc>Get information about where the sequence data came from.
For example, whether it was loaded from an external DSQ file.
@param name name of the sequence to query
@return TAB delimited string of the form: "from reserved start end total", where:&lt;dl&gt;&lt;dt&gt;from&lt;/dt&gt;&lt;dd&gt;the source of the animation data, such as the path to a DSQ file, or the name of an existing sequence in the shape. This field will be empty for sequences already embedded in DTS or DAE file.&lt;/dd&gt;&lt;dt&gt;reserved&lt;/dt&gt;&lt;dd&gt;reserved value&lt;/dd&gt;&lt;dt&gt;start&lt;/dt&gt;&lt;dd&gt;the first frame in the source sequence used to create this sequence&lt;/dd&gt;&lt;dt&gt;end&lt;/dt&gt;&lt;dd&gt;the last frame in the source sequence used to create this sequence&lt;/dd&gt;&lt;dt&gt;total&lt;/dt&gt;&lt;dd&gt;the total number of frames in the source sequence&lt;/dd&gt;&lt;/dl&gt;

@tsexample
// print the source for the walk animation
echo( "walk source:" SPC getField( %this.getSequenceSource( "walk" ), 0 ) );
@endtsexample</desc>
</method>
<method>
<name>getTargetCount</name>
<args>()</args>
<desc>Get the number of materials in the shape.
@return the number of materials in the shape.

@tsexample
%count = %this.getTargetCount();
@endtsexample</desc>
</method>
<method>
<name>getTargetName</name>
<args>( int index )</args>
<desc>Get the name of the indexed shape material.
@param index index of the material to get (valid range is 0 - getTargetCount()-1).
@return the name of the indexed material.

@tsexample
%count = %this.getTargetCount();
for ( %i = 0; %i &lt; %count; %i++ )
echo( "Target " @ %i @ ": " @ %this.getTargetName( %i ) );
@endtsexample</desc>
</method>
<method>
<name>getTrigger</name>
<args>( string name, int index )</args>
<desc>Get information about the indexed trigger
@param name name of the sequence to query
@param index index of the trigger (valid range is 0 - getTriggerCount()-1)
@return string of the form "frame state"

@tsexample
// print all triggers in the sequence
%count = %this.getTriggerCount( "back" );
for ( %i = 0; %i &lt; %count; %i++ )
echo( %i SPC %this.getTrigger( "back", %i ) );
@endtsexample</desc>
</method>
<method>
<name>getTriggerCount</name>
<args>( string name )</args>
<desc>Get the number of triggers in the specified sequence.
@param name name of the sequence to query
@return number of triggers in the sequence</desc>
</method>
<method>
<name>removeDetailLevel</name>
<args>( int index )</args>
<desc>Remove the detail level (including all meshes in the detail level)
@param size size of the detail level to remove
@return true if successful, false otherwise
@tsexample
%this.removeDetailLevel( 2 );
@endtsexample</desc>
</method>
<method>
<name>removeImposter</name>
<args>()</args>
<desc>Remove the imposter detail level (if any) from the shape.
@return true if successful, false otherwise</desc>
</method>
<method>
<name>removeMesh</name>
<args>( string name )</args>
<desc>Remove a mesh from the shape.
If all geometry is removed from an object, the object is also removed.
@param name full name (object name + detail size) of the mesh to remove
@return true if successful, false otherwise

@tsexample
%this.removeMesh( "SimpleShape128" );
@endtsexample</desc>
</method>
<method>
<name>removeNode</name>
<args>( string name )</args>
<desc>Remove a node from the shape.
The named node is removed from the shape, including from any sequences that use the node. Child nodes and objects attached to the node are re-assigned to the node's parent.
@param name name of the node to remove.
@return true if successful, false otherwise.

@tsexample
%this.removeNode( "Nose" );
@endtsexample</desc>
</method>
<method>
<name>removeObject</name>
<args>( string name )</args>
<desc>Remove an object (including all meshes for that object) from the shape.
@param name name of the object to remove.
@return true if successful, false otherwise.

@tsexample
// clear all objects in the shape
%count = %this.getObjectCount();
for ( %i = %count-1; %i &gt;= 0; %i-- )
%this.removeObject( %this.getObjectName(%i) );
@endtsexample</desc>
</method>
<method>
<name>removeSequence</name>
<args>( string name )</args>
<desc>Remove the sequence from the shape.
@param name name of the sequence to remove
@return true if successful, false otherwise</desc>
</method>
<method>
<name>removeTrigger</name>
<args>( string name, int keyframe, int state )</args>
<desc>Remove a trigger from the sequence.
@param name name of the sequence to modify
@param keyframe keyframe of the trigger to remove
@param state of the trigger to remove
@return true if successful, false otherwise

@tsexample
%this.removeTrigger( "walk", 3, 1 );
@endtsexample</desc>
</method>
<method>
<name>renameDetailLevel</name>
<args>( string oldName, string newName )</args>
<desc>Rename a detail level.
@note Note that detail level names must be unique, so this command will fail if there is already a detail level with the desired name
@param oldName current name of the detail level
@param newName new name of the detail level
@return true if successful, false otherwise

@tsexample
%this.renameDetailLevel( "detail-1", "collision-1" );
@endtsexample</desc>
</method>
<method>
<name>renameNode</name>
<args>( string oldName, string newName )</args>
<desc>Rename a node.
@note Note that node names must be unique, so this command will fail if there is already a node with the desired name
@param oldName current name of the node
@param newName new name of the node
@return true if successful, false otherwise

@tsexample
%this.renameNode( "Bip01 L Hand", "mount5" );
@endtsexample</desc>
</method>
<method>
<name>renameObject</name>
<args>( string oldName, string newName )</args>
<desc>Rename an object.
@note Note that object names must be unique, so this command will fail if there is already an object with the desired name
@param oldName current name of the object
@param newName new name of the object
@return true if successful, false otherwise

@tsexample
%this.renameObject( "MyBox", "Box" );
@endtsexample</desc>
</method>
<method>
<name>renameSequence</name>
<args>( string oldName, string newName )</args>
<desc>Rename a sequence.
@note Note that sequence names must be unique, so this command will fail if there is already a sequence with the desired name
@param oldName current name of the sequence
@param newName new name of the sequence
@return true if successful, false otherwise

@tsexample
%this.renameSequence( "walking", "walk" );
@endtsexample</desc>
</method>
<method>
<name>saveShape</name>
<args>( string filename )</args>
<desc>Save the shape (with all current changes) to a new DTS file.
@param filename Destination filename.

@tsexample
%this.saveShape( "./myShape.dts" );
@endtsexample</desc>
</method>
<method>
<name>setBounds</name>
<args>( Box3F bbox )</args>
<desc>Set the shape bounds to the given bounding box.
@param Bounding box "minX minY minZ maxX maxY maxZ"
@return true if successful, false otherwise</desc>
</method>
<method>
<name>setDetailLevelSize</name>
<args>( int index, int newSize )</args>
<desc>Change the size of a detail level.@note Note that detail levels are always sorted in decreasing size order, so this command may cause detail level indices to change.
@param index index of the detail level to modify
@param newSize new size for the detail level
@return new index for this detail level

@tsexample
%this.setDetailLevelSize( 2, 256 );
@endtsexample</desc>
</method>
<method>
<name>setMeshMaterial</name>
<args>( string meshName, string matName )</args>
<desc>Set the name of the material attached to the mesh.
@param meshName full name (object name + detail size) of the mesh to modify
@param matName name of the material to attach. This could be the base name of the diffuse texture (eg. "test_mat" for "test_mat.jpg"), or the name of a Material object already defined in script.
@return true if successful, false otherwise

@tsexample
// set the mesh material
%this.setMeshMaterial( "SimpleShape128", "test_mat" );
@endtsexample</desc>
</method>
<method>
<name>setMeshSize</name>
<args>( string name, int size )</args>
<desc>Change the detail level size of the named mesh.
@param name full name (object name + current size ) of the mesh to modify
@param size new detail level size
@return true if successful, false otherwise.

@tsexample
%this.setMeshSize( "SimpleShape128", 64 );
@endtsexample</desc>
</method>
<method>
<name>setMeshType</name>
<args>( string name, string type )</args>
<desc>Set the display type for the mesh.
@param name full name (object name + detail size) of the mesh to modify
@param type the new type for the mesh: "normal", "billboard" or "billboardzaxis"
@return true if successful, false otherwise

@tsexample
// set the mesh to be a billboard
%this.setMeshType( "SimpleShape64", "billboard" );
@endtsexample</desc>
</method>
<method>
<name>setNodeParent</name>
<args>( string name, string parentName )</args>
<desc>Set the parent of a node.
@param name name of the node to modify
@param parentName name of the parent node to set (use "" to move the node to the root level)
@return true if successful, false if failed

@tsexample
%this.setNodeParent( "Bip01 Pelvis", "start01" );
@endtsexample</desc>
</method>
<method>
<name>setNodeTransform</name>
<args>( string name, TransformF txfm, bool isWorld=false )</args>
<desc>Set the base transform of a node. That is, the transform of the node when in the root (not-animated) pose.
@param name name of the node to modify
@param txfm transform string of the form: "pos.x pos.y pos.z rot.x rot.y rot.z rot.angle"
@param isworld (optional) flag to set the local-to-parent or the global transform. If false, or not specified, the position and orientation are treated as relative to the node's parent.
@return true if successful, false otherwise

@tsexample
%this.setNodeTransform( "mount0", "0 0 1 0 0 1 0" );
%this.setNodeTransform( "mount0", "0 0 0 0 0 1 1.57" );
%this.setNodeTransform( "mount0", "1 0 0 0 0 1 0", true );
@endtsexample</desc>
</method>
<method>
<name>setObjectNode</name>
<args>( string objName, string nodeName )</args>
<desc>Set the node an object is attached to.
When the shape is rendered, the object geometry is rendered at the node's current transform.
@param objName name of the object to modify
@param nodeName name of the node to attach the object to
@return true if successful, false otherwise

@tsexample
%this.setObjectNode( "Hand", "Bip01 LeftHand" );
@endtsexample</desc>
</method>
<method>
<name>setSequenceBlend</name>
<args>( string name, bool blend, string blendSeq, int blendFrame )</args>
<desc>Mark a sequence as a blend or non-blend.
A blend sequence is one that will be added on top of any other playing sequences. This is done by storing the animated node transforms relative to a reference frame, rather than as absolute transforms.
@param name name of the sequence to modify
@param blend true to make the sequence a blend, false for a non-blend
@param blendSeq the name of the sequence that contains the blend reference frame
@param blendFrame the reference frame in the blendSeq sequence
@return true if successful, false otherwise

@tsexample
%this.setSequenceBlend( "look", true, "root", 0 );
@endtsexample</desc>
</method>
<method>
<name>setSequenceCyclic</name>
<args>( string name, bool cyclic )</args>
<desc>Mark a sequence as cyclic or non-cyclic.
@param name name of the sequence to modify
@param cyclic true to make the sequence cyclic, false for non-cyclic
@return true if successful, false otherwise

@tsexample
%this.setSequenceCyclic( "ambient", true );
%this.setSequenceCyclic( "shoot", false );
@endtsexample</desc>
</method>
<method>
<name>setSequenceGroundSpeed</name>
<args>( string name, Point3F transSpeed, Point3F rotSpeed=Point3F::Zero )</args>
<desc>Set the translation and rotation ground speed of the sequence.
The ground speed of the sequence is set by generating ground transform keyframes. The ground translational and rotational speed is assumed to be constant for the duration of the sequence. Existing ground frames for the sequence (if any) will be replaced.
@param name name of the sequence to modify
@param transSpeed translational speed (trans.x trans.y trans.z) in Torque units per frame
@param rotSpeed (optional) rotational speed (rot.x rot.y rot.z) in radians per frame. Default is "0 0 0"
@return true if successful, false otherwise

@tsexample
%this.setSequenceGroundSpeed( "run", "5 0 0" );
%this.setSequenceGroundSpeed( "spin", "0 0 0", "4 0 0" );
@endtsexample</desc>
</method>
<method>
<name>setSequencePriority</name>
<args>( string name, float priority )</args>
<desc>Set the sequence priority.
@param name name of the sequence to modify
@param priority new priority value
@return true if successful, false otherwise</desc>
</method>
<method>
<name>writeChangeSet</name>
<args>()</args>
<desc>Write the current change set to a TSShapeConstructor script file. The name of the script file is the same as the model, but with .cs extension. eg. myShape.cs for myShape.dts or myShape.dae.</desc>
</method>
<field>
<name>adjustCenter</name>
<desc>Translate COLLADA model on import so the origin is at the center. No effect for DTS files.</desc>
</field>
<field>
<name>adjustFloor</name>
<desc>Translate COLLADA model on import so origin is at the (Z axis) bottom of the model. No effect for DTS files.
This can be used along with adjustCenter to have the origin at the center of the bottom of the model.
@see adjustCenter</desc>
</field>
<field>
<name>alwaysImport</name>
<desc>TAB separated patterns of nodes to import even if in neverImport list. No effect for DTS files.
Torque allows unwanted nodes in COLLADA (.dae) files to to be ignored during import. This field contains a TAB separated list of patterns to match node names. Any node that matches one of the patterns in the list will &lt;b&gt;always&lt;/b&gt; be imported, even if it also matches the neverImport list
@see neverImport

@tsexample
singleton TSShapeConstructor(MyShapeDae)
{
baseShape = "./myShape.dae";
alwaysImport = "mount*" TAB "eye";
neverImport = "*-PIVOT";
}
@endtsexample</desc>
</field>
<field>
<name>alwaysImportMesh</name>
<desc>TAB separated patterns of meshes to import even if in neverImportMesh list. No effect for DTS files.
Torque allows unwanted meshes in COLLADA (.dae) files to to be ignored during import. This field contains a TAB separated list of patterns to match mesh names. Any mesh that matches one of the patterns in the list will &lt;b&gt;always&lt;/b&gt; be imported, even if it also matches the neverImportMesh list
@see neverImportMesh

@tsexample
singleton TSShapeConstructor(MyShapeDae)
{
baseShape = "./myShape.dae";
alwaysImportMesh = "body*" TAB "armor" TAB "bounds";
neverImportMesh = "*-dummy";
}
@endtsexample</desc>
</field>
<field>
<name>baseShape</name>
<desc>Specifies the path to the DTS or DAE file to be operated on by this object.
Since the TSShapeConstructor script must be in the same folder as the DTS or DAE file, it is recommended to use a relative path so that the shape and script files can be copied to another location without having to modify the path.</desc>
</field>
<field>
<name>forceUpdateMaterials</name>
<desc>Forces update of the materials.cs file in the same folder as the COLLADA (.dae) file, even if Materials already exist. No effect for DTS files.
Normally only Materials that are not already defined are written to materials.cs.</desc>
</field>
<field>
<name>ignoreNodeScale</name>
<desc>Ignore &lt;scale&gt; elements inside COLLADA &lt;node&gt;s. No effect for DTS files.
This field is a workaround for certain exporters that generate bad node scaling, and is not usually required.</desc>
</field>
<field>
<name>lodType</name>
<desc>Control how the COLLADA (.dae) importer interprets LOD in the model. No effect for DTS files.
Set to one of the following values:
&lt;dl&gt;&lt;dt&gt;DetectDTS&lt;/dt&gt;&lt;dd&gt;The default value. Instructs the importer to search for a 'baseXXX-&gt;startXXX' node hierarchy at the root level. If found, the importer acts as if ''TrailingNumber'' was set. Otherwise, all geometry is imported at a single detail size.&lt;/dd&gt;&lt;dt&gt;SingleSize&lt;/dt&gt;&lt;dd&gt;All geometry is imported at a fixed detail size. Numbers at the end of geometry node's are ignored.&lt;/dd&gt;&lt;dt&gt;TrailingNumber&lt;/dt&gt;&lt;dd&gt;Numbers at the end of geometry node's name are interpreted as the detail size (similar to DTS exporting). Geometry instances with the same base name but different trailing number are grouped into the same object.&lt;/dd&gt;&lt;dt&gt;DEFAULT&lt;/dt&gt;&lt;dd&gt;The default value. Use the value in the .dae file (defaults to Z_AXIS if the &lt;up_axis&gt; element is not present).&lt;/dd&gt;&lt;/dl&gt;</desc>
</field>
<field>
<name>matNamePrefix</name>
<desc>Prefix to apply to all material map names in the COLLADA (.dae) file. No effect for DTS files.
This field is useful to avoid material name clashes for exporters that generate generic material names like "texture0" or "material1".</desc>
</field>
<field>
<name>neverImport</name>
<desc>TAB separated patterns of nodes to ignore on loading. No effect for DTS files.
Torque allows unwanted nodes in COLLADA (.dae) files to to be ignored during import. This field contains a TAB separated list of patterns to match node names. Any node that matches one of the patterns in the list will not be imported (unless it matches the alwaysImport list.
@see alwaysImport</desc>
</field>
<field>
<name>neverImportMesh</name>
<desc>TAB separated patterns of meshes to ignore on loading. No effect for DTS files.
Torque allows unwanted meshes in COLLADA (.dae) files to to be ignored during import. This field contains a TAB separated list of patterns to match mesh names. Any mesh that matches one of the patterns in the list will not be imported (unless it matches the alwaysImportMesh list.
@see alwaysImportMesh</desc>
</field>
<field>
<name>onLoad()</name>
<desc>Called immediately after the DTS or DAE file has been loaded; before the shape data is available to any other object (StaticShape, Player etc). This is where you should put any post-load commands to modify the shape in-memory such as addNode, renameSequence etc.</desc>
</field>
<field>
<name>onUnload()</name>
<desc>Called when the DTS or DAE resource is flushed from memory. Not normally required, but may be useful to perform cleanup.</desc>
</field>
<field>
<name>sequence</name>
<desc>Legacy method of adding sequences to a DTS or DAE shape after loading.

@tsexample
singleton TSShapeConstructor(MyShapeDae)
{
baseShape = "./myShape.dae";
sequence = "../anims/root.dae root";
sequence = "../anims/walk.dae walk";
sequence = "../anims/jump.dsq jump";
}
@endtsexample</desc>
</field>
<field>
<name>singleDetailSize</name>
<desc>Sets the detail size when lodType is set to SingleSize. No effect otherwise, and no effect for DTS files.
@see lodType</desc>
</field>
<field>
<name>unit</name>
<desc>Override the &lt;unit&gt; element in the COLLADA (.dae) file. No effect for DTS files.
COLLADA (.dae) files usually contain a &lt;unit&gt; element that indicates the 'real world' units that the model is described in. It means you can work in sensible and meaningful units in your modeling app.&lt;br&gt;
For example, if you were modeling a small object like a cup, it might make sense to work in inches (1 MAX unit = 1 inch), but if you were modeling a building, it might make more sense to work in feet (1 MAX unit = 1 foot). If you export both models to COLLADA, T3D will automatically scale them appropriately. 1 T3D unit = 1 meter, so the cup would be scaled down by 0.0254, and the building scaled down by 0.3048, given them both the correct scale relative to each other.&lt;br&gt;
Omit the field or set to -1 to use the value in the .dae file (1.0 if the &lt;unit&gt; element is not present)</desc>
</field>
<field>
<name>upAxis</name>
<desc>Override the &lt;up_axis&gt; element in the COLLADA (.dae) file. No effect for DTS files.
Set to one of the following values:
&lt;dl&gt;&lt;dt&gt;X_AXIS&lt;/dt&gt;&lt;dd&gt;Positive X points up. Model will be rotated into Torque's coordinate system (Z up).&lt;/dd&gt;&lt;dt&gt;Y_AXIS&lt;/dt&gt;&lt;dd&gt;Positive Y points up. Model will be rotated into Torque's coordinate system (Z up).&lt;/dd&gt;&lt;dt&gt;Z_AXIS&lt;/dt&gt;&lt;dd&gt;Positive Z points up. No rotation will be applied to the model.&lt;/dd&gt;&lt;dt&gt;DEFAULT&lt;/dt&gt;&lt;dd&gt;The default value. Use the value in the .dae file (defaults to Z_AXIS if the &lt;up_axis&gt; element is not present).&lt;/dd&gt;&lt;/dl&gt;</desc>
</field>
</class>
<class>
<name>TSShapeConstructorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>TSStatic</name>
<base>SceneObject</base>
<method>
<name>changeMaterial</name>
<args>( string mapTo="", Material oldMat=NULL, Material newMat=NULL )</args>
<desc>Change one of the materials on the shape.
This method changes materials per mapTo with others. The material that is being replaced is mapped to unmapped_mat as a part of this transition.
@note Warning, right now this only sort of works. It doesn't do a live update like it should.
@param mapTo the name of the material target to remap (from getTargetName)
@param oldMat the old Material that was mapped
@param newMat the new Material to map

@tsexample
// remap the first material in the shape
%mapTo = %obj.getTargetName( 0 );
%obj.changeMaterial( %mapTo, 0, MyMaterial );
@endtsexample</desc>
</method>
<method>
<name>getModelFile</name>
<args>()</args>
<desc>Get the model filename used by this shape.
@return the shape filename

@tsexample
// Acquire the model filename used on this shape.
%modelFilename = %obj.getModelFile();
@endtsexample</desc>
</method>
<method>
<name>getTargetCount</name>
<args>()</args>
<desc>Get the number of materials in the shape.
@return the number of materials in the shape.</desc>
</method>
<method>
<name>getTargetName</name>
<args>( int index=0 )</args>
<desc>Get the name of the indexed shape material.
@param index index of the material to get (valid range is 0 - getTargetCount()-1).
@return the name of the indexed material.</desc>
</method>
<field>
<name>allowPlayerStep</name>
<desc>Allow a Player to walk up sloping polygons in the TSStatic (based on the collisionType).</desc>
</field>
<field>
<name>collisionType</name>
<desc>The type of mesh data to use for collision queries.</desc>
</field>
<field>
<name>decalType</name>
<desc>The type of mesh data used to clip decal polygons against.</desc>
</field>
<field>
<name>forceDetail</name>
<desc>Forces rendering to a particular detail level.</desc>
</field>
<field>
<name>meshCulling</name>
<desc>Enables detailed culling of meshes within the TSStatic. Should only be used with large complex shapes like buildings which contain many submeshes.</desc>
</field>
<field>
<name>originSort</name>
<desc>Enables translucent sorting of the TSStatic by its origin instead of the bounds.</desc>
</field>
<field>
<name>playAmbient</name>
<desc>Enables automatic playing of the animation named "ambient" (if it exists) when the TSStatic is loaded.</desc>
</field>
<field>
<name>renderNormals</name>
<desc>Debug rendering mode shows the normals for each point in the TSStatic's mesh.</desc>
</field>
<field>
<name>shapeName</name>
<desc>Path and filename of the model file (.DTS, .DAE) to use for this TSStatic.</desc>
</field>
</class>
<class>
<name>TSStaticClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>UndoAction</name>
<base>SimObject</base>
<method>
<name>addToManager</name>
<desc>action.addToManager([undoManager])</desc>
</method>
<method>
<name>redo</name>
<args>()</args>
<desc>Reo action contained in undo.</desc>
</method>
<method>
<name>undo</name>
<args>()</args>
<desc>Undo action contained in undo.</desc>
</method>
<field>
<name>actionName</name>
<desc>A brief description of the action, for UI representation of this undo/redo action.</desc>
</field>
</class>
<class>
<name>UndoActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>UndoManager</name>
<base>SimObject</base>
<method>
<name>clearAll</name>
<desc>Clears the undo manager.</desc>
</method>
<method>
<name>getNextRedoName</name>
<desc>UndoManager.getNextRedoName();</desc>
</method>
<method>
<name>getNextUndoName</name>
<desc>UndoManager.getNextUndoName();</desc>
</method>
<method>
<name>getRedoAction</name>
<args>(index)</args>
</method>
<method>
<name>getRedoCount</name>
</method>
<method>
<name>getRedoName</name>
<args>(index)</args>
</method>
<method>
<name>getUndoAction</name>
<args>(index)</args>
</method>
<method>
<name>getUndoCount</name>
</method>
<method>
<name>getUndoName</name>
<args>(index)</args>
</method>
<method>
<name>popCompound</name>
<args>( bool discard=false )</args>
<desc>Pop the current CompoundUndoAction off the stack.</desc>
</method>
<method>
<name>pushCompound</name>
<args>( string name="" )</args>
<desc>Push a CompoundUndoAction onto the compound stack for assembly.</desc>
</method>
<method>
<name>redo</name>
<desc>UndoManager.redo();</desc>
</method>
<method>
<name>undo</name>
<desc>UndoManager.undo();</desc>
</method>
<field>
<name>numLevels</name>
<desc>Number of undo &amp; redo levels.</desc>
</field>
</class>
<class>
<name>UndoManagerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>UndoScriptAction</name>
<base>UndoAction</base>
</class>
<class>
<name>UndoScriptActionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Vehicle</name>
<base>ShapeBase</base>
<field>
<name>disableMove</name>
<desc>When this flag is set, the vehicle will ignore throttle changes.</desc>
</field>
</class>
<class>
<name>VehicleBlocker</name>
<base>SceneObject</base>
<field>
<name>Dimensions</name>
<desc>Point3F Dimensions</desc>
</field>
</class>
<class>
<name>VehicleBlockerClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>VehicleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>VehicleData</name>
<base>ShapeBaseData</base>
<field>
<name>bodyFriction</name>
<desc>Collision friction coefficient.
How well this object will slide against objects it collides with.</desc>
</field>
<field>
<name>bodyRestitution</name>
<desc>Collision 'bounciness'.
Normally in the range 0 (not bouncy at all) to 1 (100% bounciness).</desc>
</field>
<field>
<name>cameraDecay</name>
<desc>How quickly the camera moves back towards the vehicle when stopped.

@see cameraLag.</desc>
</field>
<field>
<name>cameraLag</name>
<desc>How much the camera lags behind the vehicle depending on vehicle speed.
Increasing this value will make the camera fall further behind the vehicle as it accelerates away.

@see cameraDecay.</desc>
</field>
<field>
<name>cameraOffset</name>
<desc>Vertical (Z axis) height of the camera above the vehicle.</desc>
</field>
<field>
<name>cameraRoll</name>
<desc>If true, the camera will roll with the vehicle. If false, the camera will always have the positive Z axis as up.</desc>
</field>
<field>
<name>collDamageMultiplier</name>
<desc>Damage to this vehicle after a collision (multiplied by collision velocity).
Currently unused.</desc>
</field>
<field>
<name>collDamageThresholdVel</name>
<desc>Minimum collision velocity to cause damage to this vehicle.
Currently unused.</desc>
</field>
<field>
<name>collisionTol</name>
<desc>Minimum distance between objects for them to be considered as colliding.</desc>
</field>
<field>
<name>contactTol</name>
<desc>Maximum relative velocity between objects for collisions to be resolved as contacts.
Velocities greater than this are handled as collisions.</desc>
</field>
<field>
<name>damageEmitter</name>
<desc>Array of particle emitters used to generate damage (dust, smoke etc) effects.

@see damageEmitterOffset</desc>
</field>
<field>
<name>damageEmitterOffset</name>
<desc>"x y z" offsets used to emit particles for each of the active damageEmitters.

@tsexample
// damage levels
damageLevelTolerance[0] = 0.5;
damageEmitter[0] = SmokeEmitter;
// emit offsets (used for all active damage level emitters
damageEmitterOffset[0] = "0.5 3 1";
damageEmitterOffset[1] = "-0.5 3 1";
numDmgEmitterAreas = 2;
@endtsexample</desc>
</field>
<field>
<name>damageLevelTolerance</name>
<desc>Damage level (as a percentage of maxDamage) above which to begin emitting particles from the associated damageEmitter.

@see damageEmitterOffset</desc>
</field>
<field>
<name>dustEmitter</name>
<desc>Dust particle emitter.

@see triggerDustHeight

@see dustHeight</desc>
</field>
<field>
<name>dustHeight</name>
<desc>Height above ground at which to emit particles from the dustEmitter.</desc>
</field>
<field>
<name>exitingWater</name>
<desc>Sound to play when exiting the water.</desc>
</field>
<field>
<name>exitSplashSoundVelocity</name>
<desc>Minimum velocity when leaving the water for the exitingWater sound to play.</desc>
</field>
<field>
<name>hardImpactSound</name>
<desc>Sound to play on a 'hard' impact.
This sound is played if the impact speed &gt;= hardImpactSpeed.
@see hardImpactSpeed</desc>
</field>
<field>
<name>hardImpactSpeed</name>
<desc>Minimum collision speed for the hardImpactSound to be played.</desc>
</field>
<field>
<name>hardSplashSoundVelocity</name>
<desc>Minimum velocity when entering the water for the imapactWaterHard sound to play.

@see impactWaterHard</desc>
</field>
<field>
<name>impactWaterEasy</name>
<desc>Sound to play when entering the water with speed &gt;= softSplashSoundVelocity and &lt; mediumSplashSoundVelocity.</desc>
</field>
<field>
<name>impactWaterHard</name>
<desc>Sound to play when entering the water with speed &gt;= hardSplashSoundVelocity.</desc>
</field>
<field>
<name>impactWaterMedium</name>
<desc>Sound to play when entering the water with speed &gt;= mediumSplashSoundVelocity and &lt; hardSplashSoundVelocity.</desc>
</field>
<field>
<name>integration</name>
<desc>Number of integration steps per tick.
Increase this to improve simulation stability (also increases simulation processing time).</desc>
</field>
<field>
<name>jetEnergyDrain</name>
<desc>Energy amount to drain for each tick the vehicle is jetting.
Once the vehicle's energy level reaches 0, it will no longer be able to jet.</desc>
</field>
<field>
<name>jetForce</name>
<desc>Additional force applied to the vehicle when it is jetting.
For WheeledVehicles, the force is applied in the forward direction. For FlyingVehicles, the force is applied in the thrust direction.</desc>
</field>
<field>
<name>massBox</name>
<desc>Define the box used to estimate the vehicle's moment of inertia.
Currently only used by WheeledVehicle, other vehicle types use a unit sphere to compute inertia.</desc>
</field>
<field>
<name>massCenter</name>
<desc>Defines the vehicle's center of mass (offset from the origin of the model).</desc>
</field>
<field>
<name>maxDrag</name>
<desc>Maximum drag coefficient.
Currently unused.</desc>
</field>
<field>
<name>maxSteeringAngle</name>
<desc>Maximum yaw (horizontal) and pitch (vertical) steering angle in radians.</desc>
</field>
<field>
<name>mediumSplashSoundVelocity</name>
<desc>Minimum velocity when entering the water for the imapactWaterMedium sound to play.

@see impactWaterMedium</desc>
</field>
<field>
<name>minDrag</name>
<desc>Minimum drag coefficient.
Currently only used by FlyingVehicle.</desc>
</field>
<field>
<name>minImpactSpeed</name>
<desc>Minimum collision speed for the onImpact callback to be invoked.</desc>
</field>
<field>
<name>minJetEnergy</name>
<desc>Minimum vehicle energy level to begin jetting.</desc>
</field>
<field>
<name>minRollSpeed</name>
<desc>Unused</desc>
</field>
<field>
<name>numDmgEmitterAreas</name>
<desc>Number of damageEmitterOffset values to use for each damageEmitter.

@see damageEmitterOffset</desc>
</field>
<field>
<name>onEnterLiquid( Vehicle obj, float coverage, string type )</name>
<desc>Called when the vehicle enters liquid.
@param obj the Vehicle object
@param coverage percentage of the vehicle's bounding box covered by the liquid
@param type type of liquid the vehicle has entered</desc>
</field>
<field>
<name>onLeaveLiquid( Vehicle obj, string type )</name>
<desc>Called when the vehicle leaves liquid.
@param obj the Vehicle object
@param type type of liquid the vehicle has left</desc>
</field>
<field>
<name>softImpactSound</name>
<desc>Sound to play on a 'soft' impact.
This sound is played if the impact speed is &lt; hardImpactSpeed and &gt;= softImpactSpeed.
@see softImpactSpeed</desc>
</field>
<field>
<name>softImpactSpeed</name>
<desc>Minimum collision speed for the softImpactSound to be played.</desc>
</field>
<field>
<name>softSplashSoundVelocity</name>
<desc>Minimum velocity when entering the water for the imapactWaterEasy sound to play.

@see impactWaterEasy</desc>
</field>
<field>
<name>splashEmitter</name>
<desc>Array of particle emitters used to generate splash effects.</desc>
</field>
<field>
<name>splashFreqMod</name>
<desc>Number of splash particles to generate based on vehicle speed.
This value is multiplied by the current speed to determine how many particles to generate each frame.</desc>
</field>
<field>
<name>splashVelEpsilon</name>
<desc>Minimum speed when moving through water to generate splash particles.</desc>
</field>
<field>
<name>triggerDustHeight</name>
<desc>Maximum height above surface to emit dust particles.
If the vehicle is less than triggerDustHeight above a static surface with a material that has 'showDust' set to true, the vehicle will emit particles from the dustEmitter.</desc>
</field>
<field>
<name>waterWakeSound</name>
<desc>Looping sound to play while moving through the water.</desc>
</field>
</class>
<class>
<name>VehicleDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WaterBlock</name>
<base>WaterObject</base>
<field>
<name>gridElementSize</name>
<desc>Spacing between vertices in the WaterBlock mesh</desc>
</field>
<field>
<name>gridSize</name>
<desc>Duplicate of gridElementSize for backwards compatility</desc>
</field>
</class>
<class>
<name>WaterBlockClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WaterObject</name>
<base>SceneObject</base>
<field>
<name>baseColor</name>
<desc>Changes color of water fog.</desc>
</field>
<field>
<name>clarity</name>
<desc>Relative opacity or transparency of the water surface.</desc>
</field>
<field>
<name>cubemap</name>
<desc>Cubemap used instead of reflection texture if fullReflect is off.</desc>
</field>
<field>
<name>density</name>
<desc>Affects buoyancy of an object, thus affecting the Z velocity of a player (jumping, falling, etc.</desc>
</field>
<field>
<name>depthGradientMax</name>
<desc>Depth in world units, the max range of the color gradient texture.</desc>
</field>
<field>
<name>depthGradientTex</name>
<desc>1D texture defining the base water color by depth</desc>
</field>
<field>
<name>distortEndDist</name>
<desc>Max distance that distortion algorithm is performed. The lower, the more distorted the effect.</desc>
</field>
<field>
<name>distortFullDepth</name>
<desc>Determines the scaling down of distortion in shallow water.</desc>
</field>
<field>
<name>distortStartDist</name>
<desc>Determines start of distortion effect where water surface intersects the camera near plane.</desc>
</field>
<field>
<name>foamAmbientLerp</name>
<desc>float foamAmbientLerp</desc>
</field>
<field>
<name>foamDir</name>
<desc>Point2F foamDir</desc>
</field>
<field>
<name>foamMaxDepth</name>
<desc>float foamMaxDepth</desc>
</field>
<field>
<name>foamOpacity</name>
<desc>float foamOpacity</desc>
</field>
<field>
<name>foamRippleInfluence</name>
<desc>float foamRippleInfluence</desc>
</field>
<field>
<name>foamSpeed</name>
<desc>float foamSpeed</desc>
</field>
<field>
<name>foamTex</name>
<desc>Diffuse texture for foam in shallow water (advanced lighting only)</desc>
</field>
<field>
<name>foamTexScale</name>
<desc>applied to the surface.</desc>
</field>
<field>
<name>fresnelBias</name>
<desc>Extent of fresnel affecting reflection fogging.</desc>
</field>
<field>
<name>fresnelPower</name>
<desc>Measures intensity of affect on reflection based on fogging.</desc>
</field>
<field>
<name>fullReflect</name>
<desc>Enables dynamic reflection rendering.</desc>
</field>
<field>
<name>liquidType</name>
<desc>Liquid type of WaterBlock, such as water, ocean, lava Currently only Water is defined and used.</desc>
</field>
<field>
<name>overallFoamOpacity</name>
<desc>float overallFoamOpacity</desc>
</field>
<field>
<name>overallRippleMagnitude</name>
<desc>Master variable affecting entire surface</desc>
</field>
<field>
<name>overallWaveMagnitude</name>
<desc>Master variable affecting entire body of water's undulation</desc>
</field>
<field>
<name>reflectDetailAdjust</name>
<desc>scale up or down the detail level for objects rendered in a reflection</desc>
</field>
<field>
<name>reflectivity</name>
<desc>Overall scalar to the reflectivity of the water surface.</desc>
</field>
<field>
<name>reflectMaxRateMs</name>
<desc>Affects the sort time of reflected objects.</desc>
</field>
<field>
<name>reflectNormalUp</name>
<desc>always use z up as the reflection normal</desc>
</field>
<field>
<name>reflectPriority</name>
<desc>Affects the sort order of reflected objects.</desc>
</field>
<field>
<name>reflectTexSize</name>
<desc>The texture size used for reflections (square)</desc>
</field>
<field>
<name>rippleDir</name>
<desc>Modifies the direction of ripples on the surface.</desc>
</field>
<field>
<name>rippleMagnitude</name>
<desc>Intensifies the vertext modification of the surface.</desc>
</field>
<field>
<name>rippleSpeed</name>
<desc>Modifies speed of surface ripples.</desc>
</field>
<field>
<name>rippleTex</name>
<desc>Normal map used to simulate small surface ripples</desc>
</field>
<field>
<name>rippleTexScale</name>
<desc>Intensifies the affect of the normal map applied to the surface.</desc>
</field>
<field>
<name>soundAmbience</name>
<desc>Ambient sound environment when listener is submerged.</desc>
</field>
<field>
<name>specularColor</name>
<desc>Color used for specularity on the water surface ( sun only ).</desc>
</field>
<field>
<name>specularPower</name>
<desc>Power used for specularity on the water surface ( sun only ).</desc>
</field>
<field>
<name>underwaterColor</name>
<desc>Changes the color shading of objects beneath the water surface.</desc>
</field>
<field>
<name>useOcclusionQuery</name>
<desc>turn off reflection rendering when occluded (delayed).</desc>
</field>
<field>
<name>viscosity</name>
<desc>Affects drag force applied to an object submerged in this container.</desc>
</field>
<field>
<name>waterFogDensity</name>
<desc>Intensity of underwater fogging.</desc>
</field>
<field>
<name>waterFogDensityOffset</name>
<desc>Delta, or limit, applied to waterFogDensity.</desc>
</field>
<field>
<name>waveDir</name>
<desc>Direction waves flow toward shores.</desc>
</field>
<field>
<name>waveMagnitude</name>
<desc>Height of water undulation.</desc>
</field>
<field>
<name>waveSpeed</name>
<desc>Speed of water undulation.</desc>
</field>
<field>
<name>wetDarkening</name>
<desc>The refract color intensity scaled at wetDepth.</desc>
</field>
<field>
<name>wetDepth</name>
<desc>The depth in world units at which full darkening will be received, giving a wet look to objects underwater.</desc>
</field>
<field>
<name>whiteCapAmount</name>
<desc>Visibility of foam in deeper / non-shore water.</desc>
</field>
</class>
<class>
<name>WaterObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WaterPlane</name>
<base>WaterObject</base>
<field>
<name>gridElementSize</name>
<desc>Duplicate of gridElementSize for backwards compatility</desc>
</field>
<field>
<name>gridSize</name>
<desc>Spacing between vertices in the WaterBlock mesh</desc>
</field>
</class>
<class>
<name>WaterPlaneClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WayPoint</name>
<base>MissionMarker</base>
<field>
<name>markerName</name>
<desc>Unique name representing this waypoint</desc>
</field>
<field>
<name>team</name>
<desc>Unique numerical ID assigned to this waypoint, or set of waypoints</desc>
</field>
</class>
<class>
<name>WayPointClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WayPointSet</name>
<base>SimSet</base>
</class>
<class>
<name>WheeledVehicle</name>
<base>Vehicle</base>
<method>
<name>getWheelCount</name>
<args>()</args>
<desc>Get the number of wheels on this vehicle.
@return the number of wheels (equal to the number of hub nodes defined in the model)</desc>
</method>
<method>
<name>setWheelPowered</name>
<args>( int wheel, bool powered )</args>
<desc>Set whether the wheel is powered (has torque applied from the engine).
A rear wheel drive car for example would set the front wheels to false, and the rear wheels to true.
@param wheel index of the wheel to set
@param powered flag indicating whether to power the wheel or not
@return true if successful, false if failed</desc>
</method>
<method>
<name>setWheelSpring</name>
<args>( int wheel, WheeledVehicleSpring spring )</args>
<desc>Set the WheeledVehicleSpring datablock for this wheel.
@param wheel index of the wheel to set
@param spring WheeledVehicleSpring datablock
@return true if successful, false if failed

@tsexample
%obj.setWheelSpring( 0, FrontSpring );
@endtsexample</desc>
</method>
<method>
<name>setWheelSteering</name>
<args>( int wheel, float steering )</args>
<desc>Set how much the wheel is affected by steering.
The steering factor controls how much the wheel is rotated by the vehicle steering. For example, most cars would have their front wheels set to 1.0, and their rear wheels set to 0 since only the front wheels should turn.

Negative values will turn the wheel in the opposite direction to the steering angle.
@param wheel index of the wheel to set
@param steering steering factor from -1 (full inverse) to 1 (full)
@return true if successful, false if failed</desc>
</method>
<method>
<name>setWheelTire</name>
<args>( int wheel, WheeledVehicleTire tire )</args>
<desc>Set the WheeledVehicleTire datablock for this wheel.
@param wheel index of the wheel to set
@param tire WheeledVehicleTire datablock
@return true if successful, false if failed

@tsexample
%obj.setWheelTire( 0, FrontTire );
@endtsexample</desc>
</method>
</class>
<class>
<name>WheeledVehicleClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WheeledVehicleData</name>
<base>VehicleData</base>
<field>
<name>brakeTorque</name>
<desc>Torque applied when braking.
This controls how fast the vehicle will stop when the brakes are applied.</desc>
</field>
<field>
<name>engineBrake</name>
<desc>Braking torque applied by the engine when the throttle and brake are both 0.
This controls how quickly the vehicle will coast to a stop.</desc>
</field>
<field>
<name>engineSound</name>
<desc>Looping engine sound.
The pitch is dynamically adjusted based on the current engine RPM</desc>
</field>
<field>
<name>engineTorque</name>
<desc>Torque available from the engine at 100% throttle.
This controls vehicle acceleration. ie. how fast it will reach maximum speed.</desc>
</field>
<field>
<name>jetSound</name>
<desc>Looping sound played when the vehicle is jetting.</desc>
</field>
<field>
<name>maxWheelSpeed</name>
<desc>Maximum linear velocity of each wheel.
This caps the maximum speed of the vehicle.</desc>
</field>
<field>
<name>squealSound</name>
<desc>Looping sound played while any of the wheels is slipping.
The volume is dynamically adjusted based on how much the wheels are slipping.</desc>
</field>
<field>
<name>tireEmitter</name>
<desc>ParticleEmitterData datablock used to generate particles from each wheel when the vehicle is moving and the wheel is in contact with the ground.</desc>
</field>
<field>
<name>WheelImpactSound</name>
<desc>Sound played when the wheels impact the ground.
Currently unused.</desc>
</field>
</class>
<class>
<name>WheeledVehicleDataClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WheeledVehicleSpring</name>
<base>SimDataBlock</base>
<field>
<name>antiSwayForce</name>
<desc>Force applied to equalize extension of the spring on the opposite wheel.
This force helps to keep the suspension balanced when opposite wheels are at different heights.</desc>
</field>
<field>
<name>damping</name>
<desc>Force applied to slow changes to the extension of this spring.
Increasing this makes the suspension stiffer which can help stabilise bouncy vehicles.</desc>
</field>
<field>
<name>force</name>
<desc>Maximum spring force (when compressed to minimum length, 0)
.Increasing this will make the vehicle suspension ride higher (for a given vehicle mass), and also make the vehicle more bouncy when landing jumps.</desc>
</field>
<field>
<name>length</name>
<desc>Maximum spring length. ie. how far the wheel can extend from the root hub position.</desc>
</field>
</class>
<class>
<name>WheeledVehicleSpringClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WheeledVehicleTire</name>
<base>SimDataBlock</base>
<field>
<name>kineticFriction</name>
<desc>Tire friction when the wheel is slipping (no traction).</desc>
</field>
<field>
<name>lateralDamping</name>
<desc>Damping force applied against lateral forces generated by the tire.

@see lateralForce</desc>
</field>
<field>
<name>lateralForce</name>
<desc>Tire force perpendicular to the direction of movement.
Lateral force can in simple terms be considered left/right steering force. WheeledVehicles are acted upon by forces generated by their tires and the lateralForce measures the magnitude of the force exerted on the vehicle when the tires are deformed along the x-axis. With real wheeled vehicles, tires are constantly being deformed and it is the interplay of deformation forces which determines how a vehicle moves. In Torque's simulation of vehicle physics, tire deformation obviously can't be handled with absolute realism, but the interplay of a vehicle's velocity, its engine's torque and braking forces, and its wheels' friction, lateral deformation, lateralDamping, lateralRelaxation, longitudinal deformation, longitudinalDamping, and longitudinalRelaxation forces, along with its wheels' angular velocity are combined to create a robust real-time physical simulation.

For this field, the larger the value supplied for the lateralForce, the larger the effect steering maneuvers can have. In Torque tire forces are applied at a vehicle's wheel hubs.</desc>
</field>
<field>
<name>lateralRelaxation</name>
<desc>Relaxing force applied against lateral forces generated by the tire.
The lateralRelaxation force measures how strongly the tire effectively un-deforms.

@see lateralForce</desc>
</field>
<field>
<name>longitudinalDamping</name>
<desc>Damping force applied against longitudinal forces generated by the tire.

@see longitudinalForce</desc>
</field>
<field>
<name>longitudinalForce</name>
<desc>Tire force in the direction of movement.
Longitudinal force can in simple terms be considered forward/backward movement force. WheeledVehicles are acted upon by forces generated by their tires and the longitudinalForce measures the magnitude of the force exerted on the vehicle when the tires are deformed along the y-axis.

For this field, the larger the value, the larger the effect acceleration/deceleration inputs have.

@see lateralForce</desc>
</field>
<field>
<name>longitudinalRelaxation</name>
<desc>Relaxing force applied against longitudinal forces generated by the tire.
The longitudinalRelaxation force measures how strongly the tire effectively un-deforms.

@see longitudinalForce</desc>
</field>
<field>
<name>mass</name>
<desc>The mass of the wheel.
Currently unused.</desc>
</field>
<field>
<name>radius</name>
<desc>The radius of the wheel.
The radius is determined from the bounding box of the shape provided in the shapefile field, and does not need to be specified in script. The tire should be built with its hub axis along the object's Y-axis.</desc>
</field>
<field>
<name>Restitution</name>
<desc>Tire restitution.
Currently unused.</desc>
</field>
<field>
<name>shapeFile</name>
<desc>The path to the shape to use for the wheel.</desc>
</field>
<field>
<name>StaticFriction</name>
<desc>Tire friction when the wheel is not slipping (has traction).</desc>
</field>
</class>
<class>
<name>WheeledVehicleTireClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WorldEditor</name>
<base>EditTSCtrl</base>
<method>
<name>addUndoState</name>
</method>
<method>
<name>alignByAxis</name>
<args>(int axis)</args>
<desc>Align all selected objects along the given axis.</desc>
</method>
<method>
<name>alignByBounds</name>
<args>(int boundsAxis)</args>
<desc>Align all selected objects against the given bounds axis.</desc>
</method>
<method>
<name>canPasteSelection</name>
</method>
<method>
<name>clearIgnoreList</name>
</method>
<method>
<name>clearSelection</name>
</method>
<method>
<name>colladaExportSelection</name>
<args>( String path )</args>
<desc>Export the combined geometry of all selected objects to the specified path in collada format.</desc>
</method>
<method>
<name>copySelection</name>
</method>
<method>
<name>cutSelection</name>
</method>
<method>
<name>dropSelection</name>
<args>( bool skipUndo = false )</args>
</method>
<method>
<name>explodeSelectedPrefab</name>
<args>()</args>
<desc>Replace selected Prefab objects with a SimGroup containing all children objects defined in the .prefab.</desc>
</method>
<method>
<name>getActiveSelection</name>
<args>()</args>
<desc>Return the currently active WorldEditorSelection object.</desc>
</method>
<method>
<name>getSelectedObject</name>
<args>(int index)</args>
</method>
<method>
<name>getSelectionCentroid</name>
</method>
<method>
<name>getSelectionExtent</name>
</method>
<method>
<name>getSelectionRadius</name>
</method>
<method>
<name>getSelectionSize</name>
<args>()</args>
<desc>Return the number of objects currently selected in the editor.</desc>
</method>
<method>
<name>getSoftSnap</name>
<desc>getSoftSnap()
Is soft snapping always on?</desc>
</method>
<method>
<name>getSoftSnapAlignment</name>
<args>()</args>
<desc>Get the soft snap alignment.</desc>
</method>
<method>
<name>getSoftSnapBackfaceTolerance</name>
<desc>getSoftSnapBackfaceTolerance()
The fraction of the soft snap radius that backfaces may be included.</desc>
</method>
<method>
<name>getSoftSnapSize</name>
<desc>getSoftSnapSize()
Get the absolute size to trigger a soft snap.</desc>
</method>
<method>
<name>getTerrainSnapAlignment</name>
<args>()</args>
<desc>Get the terrain snap alignment.</desc>
</method>
<method>
<name>hideObject</name>
<args>(Object obj, bool hide)</args>
</method>
<method>
<name>hideSelection</name>
<args>(bool hide)</args>
</method>
<method>
<name>ignoreObjClass</name>
<args>(string class_name, ...)</args>
</method>
<method>
<name>invalidateSelectionCentroid</name>
</method>
<method>
<name>lockSelection</name>
<args>(bool lock)</args>
</method>
<method>
<name>makeSelectionPrefab</name>
<args>( string filename )</args>
<desc>Save selected objects to a .prefab file and replace them in the level with a Prefab object.</desc>
</method>
<method>
<name>mountRelative</name>
<args>( Object A, Object B )</args>
</method>
<method>
<name>pasteSelection</name>
</method>
<method>
<name>redirectConsole</name>
<args>( int objID )</args>
</method>
<method>
<name>resetSelectedRotation</name>
</method>
<method>
<name>resetSelectedScale</name>
</method>
<method>
<name>selectObject</name>
<args>(SimObject obj)</args>
</method>
<method>
<name>setActiveSelection</name>
<args>( id set )</args>
<desc>Set the currently active WorldEditorSelection object.</desc>
</method>
<method>
<name>setSoftSnap</name>
<desc>setSoftSnap(bool)
Allow soft snapping all of the time.</desc>
</method>
<method>
<name>setSoftSnapAlignment</name>
<args>( WorldEditor::AlignmentType type )</args>
<desc>Set the soft snap alignment.</desc>
</method>
<method>
<name>setSoftSnapBackfaceTolerance</name>
<desc>setSoftSnapBackfaceTolerance(F32 with range of 0..1)
The fraction of the soft snap radius that backfaces may be included.</desc>
</method>
<method>
<name>setSoftSnapSize</name>
<desc>setSoftSnapSize(F32)
Set the absolute size to trigger a soft snap.</desc>
</method>
<method>
<name>setTerrainSnapAlignment</name>
<args>( WorldEditor::AlignmentType alignment )</args>
<desc>Set the terrain snap alignment.</desc>
</method>
<method>
<name>softSnapDebugRender</name>
<desc>softSnapDebugRender(bool)
Toggle soft snapping debug rendering.</desc>
</method>
<method>
<name>softSnapRender</name>
<desc>softSnapRender(bool)
Render the soft snapping bounds.</desc>
</method>
<method>
<name>softSnapRenderTriangle</name>
<desc>softSnapRenderTriangle(bool)
Render the soft snapped triangle.</desc>
</method>
<method>
<name>softSnapSizeByBounds</name>
<desc>softSnapSizeByBounds(bool)
Use selection bounds size as soft snap bounds.</desc>
</method>
<method>
<name>transformSelection</name>
<desc>transformSelection(...)
Transform selection by given parameters.</desc>
</method>
<method>
<name>unselectObject</name>
<args>(SimObject obj)</args>
</method>
<field>
<name>boundingBoxCollision</name>
<desc>bool boundingBoxCollision</desc>
</field>
<field>
<name>defaultHandle</name>
<desc>filename defaultHandle</desc>
</field>
<field>
<name>dragRectColor</name>
<desc>ColorI dragRectColor</desc>
</field>
<field>
<name>dropAtBounds</name>
<desc>bool dropAtBounds</desc>
</field>
<field>
<name>dropAtScreenCenterMax</name>
<desc>float dropAtScreenCenterMax</desc>
</field>
<field>
<name>dropAtScreenCenterScalar</name>
<desc>float dropAtScreenCenterScalar</desc>
</field>
<field>
<name>dropBelowCameraOffset</name>
<desc>float dropBelowCameraOffset</desc>
</field>
<field>
<name>dropType</name>
<desc>WorldEditorDropType dropType</desc>
</field>
<field>
<name>faceSelectColor</name>
<desc>ColorI faceSelectColor</desc>
</field>
<field>
<name>fadeIcons</name>
<desc>Whether object icons should fade out with distance to camera pos.</desc>
</field>
<field>
<name>fadeIconsDist</name>
<desc>Distance from camera pos at which to start fading out icons.</desc>
</field>
<field>
<name>gridSnap</name>
<desc>If true, transform operations will snap to the grid.</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>lockedHandle</name>
<desc>filename lockedHandle</desc>
</field>
<field>
<name>objectMeshCollision</name>
<desc>bool objectMeshCollision</desc>
</field>
<field>
<name>objectsUseBoxCenter</name>
<desc>bool objectsUseBoxCenter</desc>
</field>
<field>
<name>objectTextColor</name>
<desc>ColorI objectTextColor</desc>
</field>
<field>
<name>objMouseOverColor</name>
<desc>ColorI objMouseOverColor</desc>
</field>
<field>
<name>objMouseOverSelectColor</name>
<desc>ColorI objMouseOverSelectColor</desc>
</field>
<field>
<name>objSelectColor</name>
<desc>ColorI objSelectColor</desc>
</field>
<field>
<name>objTextFormat</name>
<desc>string objTextFormat</desc>
</field>
<field>
<name>popupBackgroundColor</name>
<desc>ColorI popupBackgroundColor</desc>
</field>
<field>
<name>popupTextColor</name>
<desc>ColorI popupTextColor</desc>
</field>
<field>
<name>renderObjHandle</name>
<desc>bool renderObjHandle</desc>
</field>
<field>
<name>renderObjText</name>
<desc>bool renderObjText</desc>
</field>
<field>
<name>renderPopupBackground</name>
<desc>bool renderPopupBackground</desc>
</field>
<field>
<name>renderSelectionBox</name>
<desc>bool renderSelectionBox</desc>
</field>
<field>
<name>selectHandle</name>
<desc>filename selectHandle</desc>
</field>
<field>
<name>selectionBoxColor</name>
<desc>ColorI selectionBoxColor</desc>
</field>
<field>
<name>selectionLocked</name>
<desc>bool selectionLocked</desc>
</field>
<field>
<name>showMousePopupInfo</name>
<desc>bool showMousePopupInfo</desc>
</field>
<field>
<name>stickToGround</name>
<desc>bool stickToGround</desc>
</field>
<field>
<name>toggleIgnoreList</name>
<desc>bool toggleIgnoreList</desc>
</field>
</class>
<class>
<name>WorldEditorClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>WorldEditorSelection</name>
<base>SimPersistSet</base>
<method>
<name>containsGlobalBounds</name>
<args>()</args>
<desc>True if an object with global bounds is contained in the selection.</desc>
</method>
<method>
<name>getBoxCentroid</name>
<args>()</args>
<desc>Return the center of the bounding box around the selection.</desc>
</method>
<method>
<name>getCentroid</name>
<args>()</args>
<desc>Return the median of all object positions in the selection.</desc>
</method>
<method>
<name>offset</name>
<args>( vector delta, float gridSnap=0 )</args>
<desc>Move all objects in the selection by the given delta.</desc>
</method>
<method>
<name>subtract</name>
<args>( SimSet )</args>
<desc>Remove all objects in the given set from this selection.</desc>
</method>
<method>
<name>union</name>
<args>( SimSet set )</args>
<desc>Add all objects in the given set to this selection.</desc>
</method>
</class>
<class>
<name>WorldEditorSelectionClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>ZipObject</name>
<base>SimObject</base>
<method>
<name>addFile</name>
<args>(filename, pathInZip[, replace = true])</args>
<desc>Add a file to the zip</desc>
</method>
<method>
<name>closeArchive</name>
<args>()</args>
<desc>Close a zip file</desc>
</method>
<method>
<name>closeFile</name>
<args>(stream)</args>
<desc>Close a file within the zip</desc>
</method>
<method>
<name>deleteFile</name>
<args>(pathInZip)</args>
<desc>Delete a file from the zip</desc>
</method>
<method>
<name>extractFile</name>
<args>(pathInZip, filename)</args>
<desc>Extract a file from the zip</desc>
</method>
<method>
<name>getFileEntry</name>
<args>(index)</args>
<desc>Get file entry. Returns tab separated string containing filename, uncompressed size, compressed size, compression method and CRC32</desc>
</method>
<method>
<name>getFileEntryCount</name>
<args>()</args>
<desc>Get number of files in the zip</desc>
</method>
<method>
<name>openArchive</name>
<args>(filename, [accessMode = Read])</args>
<desc>Open a zip file</desc>
</method>
<method>
<name>openFileForRead</name>
<args>(filename)</args>
<desc>Open a file within the zip for reading</desc>
</method>
<method>
<name>openFileForWrite</name>
<args>(filename)</args>
<desc>Open a file within the zip for reading</desc>
</method>
</class>
<class>
<name>ZipObjectClass</name>
<base>ConsoleClassObject</base>
</class>
<class>
<name>Zone</name>
<base>SceneObject</base>
<field>
<name>soundAmbience</name>
<desc>Ambient sound environment for the zone.</desc>
</field>
</class>
<class>
<name>ZoneClass</name>
<base>ConsoleClassObject</base>
</class>
<function>
<name>activateDirectInput</name>
<desc>Activate input. (ie, grab the mouse again so the user can play our game.</desc>
</function>
<function>
<name>activatePackage</name>
<desc>activatePackage(packageName)</desc>
</function>
<function>
<name>addBadWord</name>
<args>( string badWord )</args>
<desc>Add a string to the bad word filter
The bad word filter is a table containing words which will not be displayed in chat windows. Instead, a designated replacement string will be displayed.
@param badWord Exact text of the word to restrict.
@return True if word was successfully added, false if the word or a subset of it already exists in the table
@see filterString

@tsexample
// In this game, "Foobar" is banned
%badWord = "Foobar";

// Returns true, word was successfully added
addBadWord(%badWord);

// Returns false, word has already been added
addBadWord("Foobar");@endtsexample
@ingroup Game</desc>
</function>
<function>
<name>addGlobalShaderMacro</name>
<args>( string name, string value=NULL )</args>
<desc>Adds a global shader macro which will be merged with the script defined macros on every shader.  The macro will replace the value of an existing macro of the same name.  For the new macro to take effect all the shaders in the system need to be reloaded.
@see resetLightManager, removeGlobalShaderMacro
@ingroup Rendering</desc>
</function>
<function>
<name>addMaterialMapping</name>
<args>(string texName, string matName)</args>
<desc>@brief Set up a material to texture mapping.

@ingroup Materials</desc>
</function>
<function>
<name>addSceneEvent</name>
<desc>addSceneEvent(S32 eventType,S32 physUser,F32 time,F32 duration,S32 node,Point3F value,const char *action,S32 dbID)</desc>
</function>
<function>
<name>addTaggedString</name>
<args>(string str)</args>
<desc>@brief Use the addTaggedString function to tag a new string and add it to the NetStringTable

@param string The string to tagged and placed in the NetStringTable. Tagging ignores case, so tagging the same string (excluding case differences) will be ignored as a duplicated tag.

@return Returns a string( containing a numeric value) equivalent to the string ID for the newly tagged string@ingroup Networking</desc>
</function>
<function>
<name>addTerrain</name>
<desc>Add Terrain</desc>
</function>
<function>
<name>aiAddPlayer</name>
<desc>aiAddPlayer( 'playerName'[, 'AIClassType'] );</desc>
</function>
<function>
<name>aiConnect</name>
<args>(...)</args>
<desc>@brief Make a new AIConnection, and pass arguments to the onConnect script callback.

@see GameConnection for parameter information
@ingroup AI</desc>
</function>
<function>
<name>allowConnections</name>
<desc>allowConnections(bool);</desc>
</function>
<function>
<name>backtrace</name>
<desc>Print the call stack.</desc>
</function>
<function>
<name>beginSampling</name>
<args>(location, [backend])</args>
<desc>@brief Takes a string informing the backend where to store sample data and optionally a name of the specific logging backend to use.  The default is the CSV backend. In most cases, the logging store will be a file name.@tsexample
beginSampling( "mysamples.csv" );
@endtsexample

@ingroup Rendering</desc>
</function>
<function>
<name>buildTaggedString</name>
<args>(string format, ...)</args>
<desc>@brief Bbuild a tagged string using the specified format.@ingroup Networking</desc>
</function>
<function>
<name>calcExplosionCoverage</name>
<args>( Point3F pos=Point3F(0.0f,0.0f,0.0f), int id=NULL, int covMask=NULL )</args>
<desc>Calculates how much an explosion effects a specific object. Use this to determine
damage values to objects based on their distance from the explosion's center point.
@tsexample
// Get the position of an explosion.
%position = ExplosionData.getPosition();

// Set a list of TypeMasks (defined in gameFunctioncs.cpp), seperated by the | character.
%TypeMasks = $TypeMasks::StaticObjectType | $TypeMasks::ItemObjectType

// Call the function, and acquire the value of effect, from 0.0f - 1.0f.
%effectValue = calcExplosionCoverage(%position , %sceneObjectToEffect , %TypeMasks);
@endtsexample
@ingroup FX</desc>
</function>
<function>
<name>call</name>
<args>( string functionName, string args... )</args>
<desc>Apply the given arguments to the specified global function and return the result of the call.

@param functionName The name of the function to call.  This function must be in the global namespace, i.e. you cannot call a function in a namespace through #call.  Use eval() for that.
@return The result of the function call.

@tsexample
function myFunction( %arg )
{
return ( %arg SPC "World!" );
}

echo( call( "myFunction", "Hello" ) ); // Prints "Hello World!" to the console.
@endtsexample

@ingroup Scripting</desc>
</function>
<function>
<name>cancel</name>
<desc>cancel(eventId)</desc>
</function>
<function>
<name>cancelAll</name>
<desc>cancelAll(objectId): cancel pending events on the specified object.  Events will be automatically cancelled if object is deleted.</desc>
</function>
<function>
<name>cancelServerQuery</name>
<desc>cancelServerQuery()</desc>
</function>
<function>
<name>castNxTractorBeam</name>
<desc>Point3F start, Point3F dir, S32 type</desc>
</function>
<function>
<name>castRayShape</name>
<desc>castRayShape(start,end);</desc>
</function>
<function>
<name>cleanupTexturePool</name>
<args>()</args>
<desc>Release the unused pooled textures in texture manager freeing up video memory.
@ingroup GFX</desc>
</function>
<function>
<name>clearClientPaths</name>
</function>
<function>
<name>clearDR</name>
</function>
<function>
<name>clearGFXResourceFlags</name>
<args>()</args>
<desc>Clears the flagged state on all allocated GFX resources. See flagCurrentGFXResources for usage details.
@ingroup GFX
@see flagCurrentGFXResources, listGFXResources, describeGFXResources</desc>
</function>
<function>
<name>clearSceneEvents</name>
<desc>clearSceneEvents()</desc>
</function>
<function>
<name>clearServerPaths</name>
</function>
<function>
<name>clearWaitForReset</name>
<desc>clearWaitForReset()</desc>
</function>
<function>
<name>clientContainerSearchCurrDist</name>
<desc>Get distance of the center of the current item from the center of the current initContainerRadiusSearch.</desc>
</function>
<function>
<name>clientContainerSearchCurrRadiusDist</name>
<desc>Get the distance of the closest point of the current item from the center of the current initContainerRadiusSearch.</desc>
</function>
<function>
<name>clientContainerSearchNext</name>
<desc>Get next item from a search started with initContainerRadiusSearch.</desc>
</function>
<function>
<name>closeNetPort</name>
<args>()</args>
<desc>@brief Closes the current network port

@ingroup Networking</desc>
</function>
<function>
<name>cls</name>
<args>()</args>
<desc>@brief Clear the screen.

@ingroup Console</desc>
</function>
<function>
<name>collapseEscape</name>
<args>( string text )</args>
<desc>Replace all escape sequences in @a text with their respective character codes.

This function replaces all escape sequences (like \n, \t, etc.) in the given string with the respective characters they respresent.

The primary use of this function is for converting strings from their literal form into their compiled/translated form, as it is done by the TorqueScript compiler.

@param text A string.
@return A duplicate of @a text with all escape sequences replaced by their respective character codes.

@tsexample
// Print:
//
//    str
//    ing
//
// to the console.  Note how the backslash in the string must be escaped here
// in order to preserve the TorqueScript compiler from collapsing the escape
// sequence in the resulting string.
echo( collapseEscape( "str\ning" ) );
@endtsexample

@see expandEscape

@ingroup Strings</desc>
</function>
<function>
<name>collapseFilename</name>
<args>(string filename)</args>
<desc>@internal Editor use only</desc>
</function>
<function>
<name>commandToClient</name>
<args>(NetConnection client, string func, ...)</args>
<desc>@brief Send a command from the server to the client

@param function Name of the client command being called
@param ... Various parameters being passed to client command

@tsexample
// Set up the client command
// Update the Ammo Counter with current ammo, if not any then hide the counter.
function clientCmdSetAmmoAmountHud(%amount)
{
if (!%amount)
^  AmmoAmount.setVisible(false);
else
{
^  AmmoAmount.setVisible(true);
^  AmmoAmount.setText("Ammo: "@%amount);
}
}
// Call it from a server function
function GameConnection::setAmmoAmountHud(%client, %amount)
{
commandToClient(%client, 'SetAmmoAmountHud', %amount);
}
@endtsexample

@ingroup Networking</desc>
</function>
<function>
<name>commandToServer</name>
<args>(string func, ...)</args>
<desc>@brief Send a command to the server.

@param function Name of the server command being called
@param ... Various parameters being passed to server command

@tsexample
// Create a standard function
function toggleCamera(%val)
{
^// If key was down, call a server command named 'ToggleCamera'
^if (%val)
^^commandToServer('ToggleCamera');
}

// Server command being called from above
function serverCmdToggleCamera(%client)
{
if (%client.getControlObject() == %client.player)
{
^  %client.camera.setVelocity("0 0 0");
^  %control = %client.camera;
}
else
{
^  %client.player.setVelocity("0 0 0");
^  %control = %client.player;
}
%client.setControlObject(%control);
clientCmdSyncEditorGui();
}
@endtsexample

@ingroup Networking</desc>
</function>
<function>
<name>compile</name>
<args>( string fileName, bool overrideNoDSO=false )</args>
<desc>Compile a file to bytecode.

This function will read the TorqueScript code in the specified file, compile it to internal bytecode, and, if DSO generation is enabled or @a overrideNoDDSO is true, will store the compiled code in a .dso file in the current DSO path mirrorring the path of @a fileName.

@param fileName Path to the file to compile to bytecode.
@param overrideNoDSO If true, force generation of DSOs even if the engine is compiled to not generate write compiled code to DSO files.

@return True if the file was successfully compiled, false if not.

@note The definitions contained in the given file will not be made available and no code will actually be executed.  Use exec() for that.

@see getDSOPath
@see exec
@ingroup Scripting</desc>
</function>
<function>
<name>containerBoxEmpty</name>
<args>( int mask, Point3F center, float xRadius, float yRadius=-1, float zRadius=-1 )</args>
<desc>See if any objects of given types are present in box of given extent.

@note Extent parameter is last since only one radius is often needed. If one radius is provided, the yRadius and zRadius are assumed to be the same.
@param  mask   Indicates the type of objects we are checking against.
@param  center Center of box.
@param  xRadius Search radius in the x-axis. See note above.
@param  yRadius Search radius in the y-axis. See note above.
@param  zRadius Search radius in the z-axis. See note above.
@return true if the box is empty, false if any object is found.
@ingroup gameObjects</desc>
</function>
<function>
<name>containerFindFirst</name>
<args>(bitset type, Point3F point, float x, float y, float z)</args>
<desc>Find objects matching the bitmask type within a box centered at point, with extents x, y, z.

Returns the first object found; thereafter, you can get more results using containerFindNext().@ingroup Game</desc>
</function>
<function>
<name>containerFindNext</name>
<desc>Get more results from a previous call to containerFindFirst().@ingroup Game</desc>
</function>
<function>
<name>containerRayCast</name>
<args>( Point3F start, Point3F end, int mask, SceneObject  pExempt=NULL )</args>
<desc>Cast a ray from start to end, checking for collision against items matching mask.

If exempt is specified, then it is temporarily excluded from collision checks (For instance, you might want to exclude the player if said player was firing a weapon.)
@returns A string containing either null, if nothing was struck, or these fields:
&lt;ul&gt;&lt;li&gt;The ID of the object that was struck.&lt;/li&gt;&lt;li&gt;The x, y, z position that it was struck.&lt;/li&gt;&lt;li&gt;The x, y, z of the normal of the face that was struck.&lt;/li&gt;&lt;/ul&gt;@ingroup gameObjects</desc>
</function>
<function>
<name>containerSearchCurrDist</name>
<args>()</args>
<desc>Get distance of the center of the current item from the center of the current initContainerRadiusSearch.@return distance from the center of the current object to the center of the search
@see containerSearchNext
@ingroup gameObjects</desc>
</function>
<function>
<name>containerSearchCurrRadiusDist</name>
<args>()</args>
<desc>Get the distance of the closest point of the current item from the center of the current initContainerRadiusSearch.@return distance from the closest point of the current object to the center of the search
@see containerSearchNext
@ingroup gameObjects</desc>
</function>
<function>
<name>containerSearchNext</name>
<args>()</args>
<desc>Get next item from a search started with initContainerRadiusSearch() or initContainerTypeSearch().@return the next object found in the search, or null if no more
@tsexample
// print the names of all nearby ShapeBase derived objects
%position = %obj.getPosition;
%radius = 20;
%mask = $TypeMasks::ShapeBaseObjectType;
initContainerRadiusSearch( %position, %radius, %mask );
while ( (%targetObject = containerSearchNext()) != 0 )
{
echo( "Found: " @ %targetObject.getName() );
}
@endtsexample
@ingroup gameObjects</desc>
</function>
<function>
<name>containsBadWords</name>
<args>( string text )</args>
<desc>Checks to see if text is a bad word
The text is considered to be a bad word if it has been added to the bad word filter@param text Text to scan for bad words
@return True if the text has bad word(s), false if it is clean
@see addBadWord

@tsexample
// In this game, "Foobar" is banned
%badWord = "Foobar";

// Add a banned word to the bad word filter
addBadWord(%badWord);

// Create the base string, can come from anywhere like user chat
%userText = "Foobar";

// Create a string of random letters
%replacementChars = "knqwrtlzs";

// If the text contains a bad word, filter it before printing
// Otherwise print the original text
if(containsBadWords(%userText))
{
^// Filter the string
^%filteredText = filterString(%userText, %replacementChars);

^// Print filtered text
^echo(%filteredText);
}
else
^echo(%userText);

@endtsexample
@ingroup Game</desc>
</function>
<function>
<name>countBits</name>
<args>( int v )</args>
<desc>Count the number of bits that are set in the given 32 bit integer.
@param v An integer value.

@return The number of bits that are set in @a v.

@ingroup Utilities</desc>
</function>
<function>
<name>createPath</name>
<args>( string path )</args>
<desc>Create the given directory or the path leading to the given filename.
If @a path ends in a trailing slash, then all components in the given path will be created as directories (if not already in place).  If @a path, does @b not end in a trailing slash, then the last component of the path is taken to be a file name and only the directory components of the path will be created.

@param path The script path to create.

@ingroup FileSystem</desc>
</function>
<function>
<name>createPhysicsManager</name>
<desc>Create Physics Manager (int type) 1 = PhysX, 2 = ODE</desc>
</function>
<function>
<name>dbgDisconnect</name>
<args>()</args>
<desc>Forcibly disconnects any attached script debugging client.
@internal Primarily used for Torsion and other debugging tools</desc>
</function>
<function>
<name>dbgIsConnected</name>
<args>()</args>
<desc>Returns true if a script debugging client is connected else return false.
@internal Primarily used for Torsion and other debugging tools</desc>
</function>
<function>
<name>dbgSetParameters</name>
<args>(int port, string password, bool waitForClient)</args>
<desc>Open a debug server port on the specified port, requiring the specified password, and optionally waiting for the debug client to connect.
@internal Primarily used for Torsion and other debugging tools</desc>
</function>
<function>
<name>deactivateDirectInput</name>
<desc>Deactivate input. (ie, ungrab the mouse so the user can do other things.</desc>
</function>
<function>
<name>deactivatePackage</name>
<desc>deactivatePackage(packageName)</desc>
</function>
<function>
<name>debug</name>
<args>()</args>
<desc>Drop the engine into the native C++ debugger.

This function triggers a debug break and drops the process into the IDE's debugger.  If the process is not running with a debugger attached, this generates a runtime error on most platforms.

@ingroup Debugging</desc>
</function>
<function>
<name>debugv</name>
<args>( string variableName )</args>
<desc>Log the value of the given variable to the console.
This functions prints a string of the form "&lt;variableName&gt; = &lt;variable value&gt;" to the console.
@param variableName Name of the local or global variable to print.

@tsexample
%var = 1;
debugv( "%var" ); // Prints "%var = 1"
@endtsexample

@ingroup Debugging</desc>
</function>
<function>
<name>decalManagerAddDecal</name>
<args>( string inputPosition="1.0 1.0 1.0", string inputNormal="1.0 1.0 1.0", float rot=1.0, float scale=1.0, DecalData decalData=NULL, bool isImmortal=false )</args>
<desc>Adds a new decal to the decal manager.
@param position Position for new decal to be placed.
@param normal XYZ Rotation for new decal to be oriented. Like the axel for this decal.
@param rotation Distance for this decal to be rotated around the normal, like a tire on an axel.
@param scale Physical scale of new decal.
@param decalData DecalData Datablock to use for the new decal.
@param immortal Whether or not this decal is immortal. If immortal, it does not age and must be removed explicitly.
@return Returns the ID of the new decal object.
@tsexample
// Specify the decal position
%position = "1.0 1.0 1.0";

// Normal
%normal = ?;

// Specify the rotation for the decal
%rotation = "0.5";

// Specify the scale for the decal
%scale = "0.35";

// Specify the decalData datablock to use for this new decal
%decalData = "decalDatablockName";

// Specify if this decal is immortal. Immortal decals don't age and must be removed explicitly.
%immortal = "false";

// Tell the decal manager to remove all existing decals.
decalManagerAddDecal( %position, %normal, %rotation, %scale, %decalData, %immortal);
@endtsexample
@ingroup FX</desc>
</function>
<function>
<name>decalManagerClear</name>
<args>()</args>
<desc>Removes all decals currently loaded in the decalManager.
@tsexample
// Tell the decal manager to remove all existing decals.
decalManagerClear();
@endtsexample
@ingroup FX</desc>
</function>
<function>
<name>decalManagerDirty</name>
<args>()</args>
<desc>Returns if the decal manager has unsaved modifications.
@return True if the decal manager has unsaved modifications, false if everything has been saved.
@tsexample
// Ask the decal manager if it has unsaved modifications.
%hasUnsavedModifications = decalManagerDirty();
@endtsexample
@ingroup FX</desc>
</function>
<function>
<name>decalManagerLoad</name>
<args>( string decalLoadFile="" )</args>
<desc>Loads the decals from the entered filename.
@param filename Filename to load the decals from.
@return True if the decal manager was able to load the requested file, false if it could not.
@tsexample
// Set the filename to load the decals from.
%fileName = "./missionDecals.mis.decals";
// Inform the decal manager to load the decals from the entered filename.
decalManagerLoad(%fileName);
@endtsexample
@ingroup FX</desc>
</function>
<function>
<name>decalManagerRemoveDecal</name>
<args>( int decalID=-1 )</args>
<desc>Remove specified decal from the scene.
@return Returns true if successful, false if decal not found.
@param decalID Entry ID of the decal to remove.
@tsexample
// Specify a decal ID to be removed
%decalID = 1;

// Tell the decal manager to remove the specified decal ID.
decalManagerRemoveDecal( %decalId )
@endtsexample
@ingroup FX</desc>
</function>
<function>
<name>decalManagerSave</name>
<args>( string decalSaveFile="" )</args>
<desc>Saves the decals for the active mission in the entered filename.
@param filename Filename to save the decals at.
@tsexample
// Set the filename to save the decals in. If no filename is set, then the decals will
default to &lt;activeMissionName&gt;.mis.decals
%fileName = "./missionDecals.mis.decals";
// Inform the decal manager to save the decals for the active mission.
decalManagerSave(%fileName);
@endtsexample
@ingroup FX</desc>
</function>
<function>
<name>deleteDataBlocks</name>
<desc>Delete all the datablocks we've downloaded. This is usually done in preparation of downloading a new set of datablocks,  such as occurs on a mission change, but it's also good post-mission cleanup.</desc>
</function>
<function>
<name>deleteVariables</name>
<args>( string pattern )</args>
<desc>Undefine all global variables matching the given name @a pattern.
@param pattern A global variable name pattern.  Must begin with '$'.
@tsexample
// Define a global variable in the "My" namespace.
$My::Variable = "value";

// Undefine all variable in the "My" namespace.
deleteVariables( "$My::*" );
@endtsexample

@see strIsMatchExpr
@ingroup Scripting</desc>
</function>
<function>
<name>describeGFXResources</name>
<args>( string resourceTypes, string filePath, bool unflaggedOnly=false )</args>
<desc>@brief Dumps a description of GFX resources to a file or the console.
@param resourceTypes A space seperated list of resource types or an empty string for all resources.
@param filePath A file to dump the list to or an empty string to write to the console.
@param unflaggedOnly If true only unflagged resources are dumped. See flagCurrentGFXResources.
@note The resource types can be one or more of the following:

- texture
- texture target
- window target
- vertex buffers
- primitive buffers
- fences
- cubemaps
- shaders
- stateblocks

@ingroup GFX</desc>
</function>
<function>
<name>describeGFXStateBlocks</name>
<args>( string filePath )</args>
<desc>Dumps a description of all state blocks.
@param filePath A file to dump the state blocks to or an empty string to write to the console.
@ingroup GFX</desc>
</function>
<function>
<name>detag</name>
<args>( string str )</args>
<desc>@brief Removes tag from a specified string
@ingroup Console</desc>
</function>
<function>
<name>disableJoystick</name>
<desc>disableJoystick()</desc>
</function>
<function>
<name>disableXInput</name>
<desc>disableXInput()@brief Disabled XInput for Xbox 360 controller input
@ingroup Input</desc>
</function>
<function>
<name>dispatchMessage</name>
<args>(string queueName, string event, string data)</args>
<desc>@brief Dispatch a message to a queue

@param queue Queue to dispatch the message to
@param msg Message to dispatch
@param data Data for message
@return true for success, false for failure
@see dispatchMessageObject
@ingroup Platform</desc>
</function>
<function>
<name>dispatchMessageObject</name>
<args>(string queueName, string message)</args>
<desc>@brief Dispatch a message object to a queue

@param queue Queue to dispatch the message to
@param msg Message to dispatch
@return true for success, false for failure
@see dispatchMessage
@ingroup Platform</desc>
</function>
<function>
<name>displaySplashWindow</name>
<args>()</args>
<desc>Display a startup splash window suitable for showing while the engine still starts up.

@note This is currently only implemented on Windows.

@return True if the splash window could be successfully initialized.

@ingroup Platform</desc>
</function>
<function>
<name>DNetSetLogging</name>
<args>(bool enabled)</args>
<desc>@brief Enables logging of the connection protocols

@param enabled True to enable, false to disable
@ingroup Networking</desc>
</function>
<function>
<name>dropSceneEvent</name>
<desc>dropSceneEvent(S32 eventID, S32 DatabaseID)</desc>
</function>
<function>
<name>dumpConsoleClasses</name>
<args>(bool dumpScript = true, bool dumpEngine = true)</args>
<desc>dumps all declared console classes to the console.
@param dumpScript Specifies whether or not classes defined in script should be dumped.
@param dumpEngine Specifies whether or not classes defined in the engine should be dumped.@ingroup Logging</desc>
</function>
<function>
<name>dumpConsoleFunctions</name>
<args>(bool dumpScript = true, bool dumpEngine = true)</args>
<desc>Dumps all declared console functions to the console.
@param dumpScript Specifies whether or not functions defined in script should be dumped.
@param dumpEngine Specifies whether or not functions defined in the engine should be dumped.@ingroup Logging</desc>
</function>
<function>
<name>dumpEngineDocs</name>
<args>( string outputFile )</args>
<desc>Dumps the engine scripting documentation to the specified file overwriting any existing content.
@param outputFile The relative or absolute output file path and name.
@return Returns true if successful.
@ingroup Engine</desc>
</function>
<function>
<name>dumpFontCacheStatus</name>
<args>()</args>
<desc>Dumps to the console a full description of all cached fonts, along with info on the codepoints each contains.
@ingroup Font</desc>
</function>
<function>
<name>dumpMaterialInstances</name>
<desc>@brief Dumps a formatted list of currently allocated material instances to the console.

@ingroup Materials</desc>
</function>
<function>
<name>dumpNetStats</name>
</function>
<function>
<name>dumpProcessList</name>
<desc>Dumps all ProcessObjects in ServerProcessList and ClientProcessList to the console.</desc>
</function>
<function>
<name>dumpRandomNormalMap</name>
<args>()</args>
<desc>Creates a 64x64 normal map texture filled with noise. The texture is saved to randNormTex.png in the location of the game executable.

@ingroup GFX</desc>
</function>
<function>
<name>duplicateCachedFont</name>
<args>( string oldFontName, int oldFontSize, string newFontName )</args>
<desc>Copy the specified old font to a new name. The new copy will not have a platform font backing it, and so will never have characters added to it. But this is useful for making copies of fonts to add postprocessing effects to via exportCachedFont.
@param oldFontName The name of the font face to copy.
@param oldFontSize The size of the font to copy.
@param newFontName The name of the new font face.
@ingroup Font</desc>
</function>
<function>
<name>echo</name>
<args>( string text... )</args>
<desc>Log a message to the console.
This function concatenates all given arguments to a single string and prints the string to the console.
A newline is added automatically after the text.

@param text Any number of string arguments.

@ingroup Logging</desc>
</function>
<function>
<name>echoInputState</name>
<args>()</args>
<desc>@brief Prints a message to the console stating if DirectInput is enabled, and if Joystick is enabled

@ingroup Input</desc>
</function>
<function>
<name>enableJoystick</name>
<desc>enableJoystick()</desc>
</function>
<function>
<name>enableSamples</name>
<args>(pattern, [state])</args>
<desc>@brief Enable sampling for all keys that match the given name pattern. Slashes are treated as separators.

@ingroup Rendering</desc>
</function>
<function>
<name>enableWinConsole</name>
<desc>enableWinConsole(bool);</desc>
</function>
<function>
<name>enableXInput</name>
<desc>enableXInput()@brief Enables XInput for Xbox 360 controller input
@ingroup Input</desc>
</function>
<function>
<name>endsWith</name>
<args>( string str, string suffix, bool caseSensitive=false )</args>
<desc>@brief Test whether the given string ends with the given suffix.

@param str The string to test.
@param suffix The potential suffix of @a str.
@param caseSensitive If true, the comparison will be case-sensitive; if false, differences in casing will not be taken into account.
@return True if the last characters in @a str match the complete contents of @a suffix; false otherwise.

@tsexample
startsWith( "TEST123", "123" ) // Returns true.
@endtsexample

@see startsWith
@ingroup Strings</desc>
</function>
<function>
<name>enumColladaForImport</name>
<args>(string shapePath, GuiTreeViewCtrl ctrl)</args>
<desc>Collect scene information from a COLLADA file and store it in a GuiTreeView control. This function is used by the COLLADA import gui to show a preview of the scene contents prior to import, and is probably not much use for anything else.
@param shapePath COLLADA filename
@param ctrl GuiTreeView control to add elements to
@return true if successful, false otherwise
@ingroup Editors
@internal</desc>
</function>
<function>
<name>enumerateConsoleClasses</name>
<desc>enumerateConsoleClasses(&lt;"base class"&gt;);@brief Currently only used by editors and intenrnal console system
@internal</desc>
</function>
<function>
<name>enumerateConsoleClassesByCategory</name>
<args>( string category )</args>
<desc>@brief Provide a list of classes that belong to the given category.

@param category Contains the category type
@return String containing each classes in the specified category
@ingroup Editors
@internal</desc>
</function>
<function>
<name>error</name>
<args>( string text... )</args>
<desc>Log an error message to the console.
This function concatenates all given arguments to a single string and prints the string to the console as an error message (in the in-game console, these will show up using a red font by default).
A newline is added automatically after the text.

@param text Any number of string arguments.

@ingroup Logging</desc>
</function>
<function>
<name>eval</name>
<desc>eval(consoleString)</desc>
</function>
<function>
<name>excludeOtherInstance</name>
<args>( string appIdentifer )</args>
<desc>@brief Used to exclude/prevent all other instances using the same identifier specified

@note Not used on OSX, Xbox, or in Win debug builds

@param appIdentifier Name of the app set up for exclusive use.
@return False if another app is running that specified the same appIdentifier

@ingroup Platform
@ingroup GuiCore</desc>
</function>
<function>
<name>exec</name>
<args>( string fileName, bool noCalls=false, bool journalScript=false )</args>
<desc>Execute the given script file.
@param fileName
@param noCalls
@param journalScript
@return True if the script was successfully executed, false if not.

@tsexample
// Execute the init.cs script file found in the same directory as the current script file.
exec( "./init.cs" );
@endtsexample

@see compile
@see eval
@ingroup Scripting</desc>
</function>
<function>
<name>execPrefs</name>
<args>( string relativeFileName, bool noCalls=false, bool journalScript=false )</args>
<desc>@brief Manually execute a special script file that contains game or editor preferences

@param relativeFileName Name and path to file from project folder
@param noCalls Deprecated
@param journalScript Deprecated
@return True if script was successfully executed
@note Appears to be useless in Torque 3D, should be deprecated
@ingroup Scripting</desc>
</function>
<function>
<name>expandEscape</name>
<args>( string text )</args>
<desc>@brief Replace all characters in @a text that need to be escaped for the string to be a valid string literal with their respective escape sequences.

All characters in @a that cannot appear in a string literal will be replaced by an escape sequence (like \n, \t, etc.).

The primary use of this function is for converting strings suitable for being passed as string literals to the TorqueScript compiler.

@param text A string
@return A duplicate of the text parameter with all unescaped characters that cannot appear in string literals replaced by their respective escape sequences.

@tsxample
expandEscape( "str" NL "ing" ) // Returns "str\ning".
@endtsxample

@see collapseEscape
@ingroup Strings</desc>
</function>
<function>
<name>expandFilename</name>
<args>(string filename)</args>
<desc>@brief Grabs the full path of a specified file

@param filename Name of the local file to locate
@return String containing the full filepath on disk
@ingroup FileSystem</desc>
</function>
<function>
<name>expandOldFilename</name>
<args>(string filename)</args>
<desc>@brief Retrofits a filepath that uses old Torque style

@return String containing filepath with new formatting
@ingroup FileSystem</desc>
</function>
<function>
<name>export</name>
<args>( string pattern, string filename="", bool append=false )</args>
<desc>Write out the definitions of all global variables matching the given name @a pattern.
If @a fileName is not "", the variable definitions are written to the specified file.  Otherwise the definitions will be printed to the console.

The output are valid TorqueScript statements that can be executed to restore the global variable values.

@param pattern A global variable name pattern.  Must begin with '$'.
@param filename %Path of the file to which to write the definitions or "" to write the definitions to the console.
@param append If true and @a fileName is not "", then the definitions are appended to the specified file. Otherwise existing contents of the file (if any) will be overwritten.

@tsexample
// Write out all preference variables to a prefs.cs file.
export( "$prefs::*", "prefs.cs" );
@endtsexample

@ingroup Scripting</desc>
</function>
<function>
<name>exportCachedFont</name>
<args>( string faceName, int fontSize, string fileName, int padding, int kerning )</args>
<desc>Export specified font to the specified filename as a PNG. The image can then be processed in Photoshop or another tool and reimported using importCachedFont. Characters in the font are exported as one long strip.
@param faceName The name of the font face.
@param fontSize The size of the font in pixels.
@param fileName The file name and path for the output PNG.
@param padding The padding between characters.
@param kerning The kerning between characters.
@ingroup Font</desc>
</function>
<function>
<name>exportEngineAPIToXML</name>
<args>()</args>
<desc>Create a XML document containing a dump of the entire exported engine API.

@return A SimXMLDocument containing a dump of the engine's export information or NULL if the operation failed.

@ingroup Core</desc>
</function>
<function>
<name>fileBase</name>
<args>(string fileName)</args>
<desc>@brief Get the base of a file name (removes extension)

@param fileName Name and path of file to check
@return String containing the file name, minus extension
@ingroup FileSystem</desc>
</function>
<function>
<name>fileCreatedTime</name>
<args>( string fileName )</args>
<desc>@brief Returns a platform specific formatted string with the creation time for the file.@param fileName Name and path of file to check
@return Formatted string (OS specific) containing created time, "9/3/2010 12:33:47 PM" for example
@ingroup FileSystem</desc>
</function>
<function>
<name>fileDelete</name>
<args>(string path)</args>
<desc>@brief Delete a file from the hard drive

@param path Name and path of the file to delete
@note THERE IS NO RECOVERY FROM THIS. Deleted file is gone for good
@return True if file was successfully deleted
@ingroup FileSystem</desc>
</function>
<function>
<name>fileExt</name>
<args>(string fileName)</args>
<desc>@brief Get the extension of a file

@param fileName Name and path of file
@return String containing the extension, such as ".exe" or ".cs"
@ingroup FileSystem</desc>
</function>
<function>
<name>fileModifiedTime</name>
<args>( string fileName )</args>
<desc>@brief Returns a platform specific formatted string with the last modified time for the file.

@param fileName Name and path of file to check
@return Formatted string (OS specific) containing modified time, "9/3/2010 12:33:47 PM" for example
@ingroup FileSystem</desc>
</function>
<function>
<name>fileName</name>
<args>(string fileName)</args>
<desc>@brief Get the file name of a file (removes extension and path)

@param fileName Name and path of file to check
@return String containing the file name, minus extension and path
@ingroup FileSystem</desc>
</function>
<function>
<name>filePath</name>
<args>(string fileName)</args>
<desc>@brief Get the path of a file (removes name and extension)

@param fileName Name and path of file to check
@return String containing the path , minus name and extension
@ingroup FileSystem</desc>
</function>
<function>
<name>fileSize</name>
<desc>fileSize(fileName)@brief Determines the size of a file on disk

@param fileName Name and path of the file to check
@return Returns filesize in KB, or -1 if no file
@ingroup FileSystem</desc>
</function>
<function>
<name>filterString</name>
<args>( string baseString=NULL, string replacementChars=NULL )</args>
<desc>Replaces the characters in a string with designated text
@param baseString  The original string to filter.
@param replacementChars A string containing letters you wish to swap in the baseString.
@return The new scrambled string
@see containsBadWords

@tsexample
// Create the base string, can come from anywhere
%baseString = "Foobar";

// Create a string of random letters
%replacementChars = "knqwrtlzs";

// Filter the string
%newString = filterString(%baseString, %replacementChars);

// Print the new string to console
echo(%newString);@endtsexample
@ingroup Game</desc>
</function>
<function>
<name>findFirstFile</name>
<args>( string pattern, bool recurse=true )</args>
<desc>Begin a file system search based on a filename pattern.
This function returns the first file of a search.  To return the remaining hits of a search, use findNextFile().

You cannot run multiple simultaneous file system searches with these functions.  Each call to findFirstFile initiates a new search and renders a previous search invalid.

@param pattern The path and file name pattern to match against.
@param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern.
@return The path of the first file matched by the search or the empty string if no matching file could be found.

@tsexample
// Execute all .cs files in a subdirectory and its subdirectories.
for( %file = findFirstFile( "subdirectory/*.cs" ); %file !$= ""; %file = findNextFile() )
exec( %file );
@endtsexample

@see findNextFile
@see getFileCount
@see findFirstFileMultiExpr
@ingroup FileSearches</desc>
</function>
<function>
<name>findFirstFileMultiExpr</name>
<args>(string pattern [, bool recurse])</args>
<desc>@brief Returns the first file in the directory system matching the given pattern.

@param pattern The path and file name pattern to match against, such as *.cs.
@param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename patter.
@return String containing the number of files located and the list of files by name
@ingroup FileSystem</desc>
</function>
<function>
<name>findNextFile</name>
<args>( string pattern="" )</args>
<desc>Get the next file matched in a file system search initiated by findFirstFile().
@param pattern Ignored.
@return The path of the next filename matched by the search or the empty string if no more files match.

@tsexample
// Execute all .cs files in a subdirectory and its subdirectories.
for( %file = findFirstFile( "subdirectory/*.cs" ); %file !$= ""; %file = findNextFile() )
exec( %file );
@endtsexample

@see findFirstFile
@see getFileCount
@see findNextFileMultiExpr
@ingroup FileSearches</desc>
</function>
<function>
<name>findNextFileMultiExpr</name>
<args>([string pattern])</args>
<desc>@brief Returns the next file matching a search begun in findFirstFile.

@param pattern The path and file name pattern to match against.
@return The path of the next matching file in string format
@ingroup FileSystem</desc>
</function>
<function>
<name>firstWord</name>
<args>( string text )</args>
<desc>Return the first word in @a text.
@param text A list of words separated by newlines, spaces, and/or tabs.
@return The word at index 0 in @a text or "" if @a text is empty.

@note This is equal to
@tsexample_nopar
getWord( text, 0 )
@endtsexample

@see getWord
@ingroup FieldManip</desc>
</function>
<function>
<name>flagCurrentGFXResources</name>
<args>()</args>
<desc>@breif Flags all currently allocated GFX resources.
Used for resource allocation and leak tracking by flagging current resources then dumping a list of unflagged resources at some later point in execution.
@ingroup GFX
@see listGFXResources, clearGFXResourceFlags, describeGFXResources</desc>
</function>
<function>
<name>flushTextureCache</name>
<args>()</args>
<desc>Releases all textures and resurrects the texture manager.
@ingroup GFX</desc>
</function>
<function>
<name>fmodDumpDSPInfo</name>
<args>()</args>
<desc>@brief Dump information about the standard DSP effects.

@ingroup SFXFMOD</desc>
</function>
<function>
<name>fmodDumpMemoryStats</name>
<args>()</args>
<desc>@return Prints the current memory consumption of the FMOD module

@ingroup SFXFMOD</desc>
</function>
<function>
<name>FreeMemoryDump</name>
<desc>FreeMemoryDump();</desc>
</function>
<function>
<name>generateUUID</name>
<args>()</args>
<desc>Generate a new universally unique identifier (UUID).

@return A newly generated UUID.

@ingroup Utilities</desc>
</function>
<function>
<name>getActiveDDSFiles</name>
<args>()</args>
<desc>Returns the count of active DDSs files in memory.
@ingroup Rendering</desc>
</function>
<function>
<name>getActiveLightManager</name>
<args>()</args>
<desc>Returns the active light manager name.
@ingroup Lighting</desc>
</function>
<function>
<name>getBestHDRFormat</name>
<args>()</args>
<desc>Returns the best texture format for storage of HDR data for the active device.
@ingroup GFX</desc>
</function>
<function>
<name>getBitmapInfo</name>
<args>( string filename )</args>
<desc>Returns image info in the following format: width TAB height TAB bytesPerPixel. It will return an empty string if the file is not found.
@ingroup Rendering</desc>
</function>
<function>
<name>getBoxCenter</name>
<args>(Box b)</args>
<desc>@brief Get the center point of a box.

@param b A Box3F, in string format using "minExtentX minExtentY minExtentZ maxExtentX maxExtentY maxExtentZ"
@return Center of the box in string format using "X Y Z"
@ingroup Math</desc>
</function>
<function>
<name>getBuildString</name>
<desc>Get the type of build, "Debug" or "Release".</desc>
</function>
<function>
<name>getCategoryOfClass</name>
<args>( string className )</args>
<desc>@brief Return the category of the given class.

@param className String containing name of the class, such as "Player"
@return Category in string format
@ingroup Console</desc>
</function>
<function>
<name>getClipboard</name>
<args>()</args>
<desc>@brief Get text from the clipboard.

@internal</desc>
</function>
<function>
<name>getCompileTimeString</name>
<desc>Get the time of compilation.</desc>
</function>
<function>
<name>getCoreLangTable</name>
<args>()</args>
<desc>@brief Gets the primary LangTable used by the game

@return ID of the core LangTable
@ingroup Localization</desc>
</function>
<function>
<name>getCurrentActionMap</name>
<args>()</args>
<desc>Get the current ActionMap.
@return The current ActionMap.
@tsexample
%currentMap = moveMap.getCurrentActionMap();
@endtsexample

@ingroup Input</desc>
</function>
<function>
<name>getCurrentDirectory</name>
<args>()</args>
<desc>Return the current working directory.

@return The absolute path of the current working directory.

@see getWorkingDirectory

@ingroup FileSystem
@ingroup Platform</desc>
</function>
<function>
<name>getDebugRender</name>
</function>
<function>
<name>getDescriptionOfClass</name>
<args>( string className )</args>
<desc>@brief Return the description string for the given class.

@param className String containing name of the class, such as "Player"
@return Class description in string format
@ingroup Console</desc>
</function>
<function>
<name>getDesktopResolution</name>
<args>()</args>
<desc>Returns the width, height, and bitdepth of the screen/desktop.

@ingroup GFX</desc>
</function>
<function>
<name>getDirectoryList</name>
<args>(string path, string depth)</args>
<desc>@brief Gather the contents (list of files) of a directory or set of directories

@param path String containing the path of the directory
@depth Depth of search, as in how many subdirectories to parse through
@return String containing list of files found during search, "" if no files were found
@ingroup FileSystem</desc>
</function>
<function>
<name>getDisplayDeviceInformation</name>
<args>()</args>
<desc>Get the string describing the active GFX device.
@ingroup GFX</desc>
</function>
<function>
<name>getDisplayDeviceList</name>
<args>()</args>
<desc>Returns a tab-seperated string of the detected devices across all adapters.
@ingroup GFX</desc>
</function>
<function>
<name>getDSOPath</name>
<args>( string scriptFileName )</args>
<desc>Get the absolute path to the file in which the compiled code for the given script file will be stored.
@param scriptFileName %Path to the .cs script file.
@return The absolute path to the .dso file for the given script file.

@note The compiler will store newly compiled DSOs in the prefs path but pre-existing DSOs will be loaded from the current paths.

@see compile
@see getPrefsPath
@ingroup Scripting</desc>
</function>
<function>
<name>getEngineName</name>
<desc>Get the name of the engine product that this is running from, as a string.</desc>
</function>
<function>
<name>getEventAction</name>
<desc>getEventAction(S32 eventID)</desc>
</function>
<function>
<name>getEventCause</name>
<desc>getEventCause(S32 eventID)</desc>
</function>
<function>
<name>getEventDatabaseID</name>
<desc>getEventDatabaseID(S32 eventType,S32 physUser,F32 time,F32 duration,S32 node,const char *action)</desc>
</function>
<function>
<name>getEventDBID</name>
<desc>getEventDBID(S32 eventID)</desc>
</function>
<function>
<name>getEventDuration</name>
<desc>getEventDuration(S32 eventID)</desc>
</function>
<function>
<name>getEventIdByNum</name>
<desc>getEventIdByNum(S32 type,S32 actorID,S32 node,S32 eventNum)</desc>
</function>
<function>
<name>getEventIdByTime</name>
<desc>getEventIdByTime(S32 type,S32 actorID,S32 node,F32 startTime)</desc>
</function>
<function>
<name>getEventIDDB</name>
<desc>getEventIDDB(S32 dbID)</desc>
</function>
<function>
<name>getEventNode</name>
<desc>getEventNode(S32 eventID)</desc>
</function>
<function>
<name>getEventPhysUser</name>
<desc>getEventPhysUser(S32 eventID)</desc>
</function>
<function>
<name>getEventTime</name>
<desc>getEventTime(S32 eventID)</desc>
</function>
<function>
<name>getEventTimeLeft</name>
<desc>getEventTimeLeft(scheduleId) Get the time left in ms until this event will trigger.</desc>
</function>
<function>
<name>getEventType</name>
<desc>getEventType(S32 eventID)</desc>
</function>
<function>
<name>getEventTypeDescription</name>
<desc>getEventTypeDescription(S32 eventType)</desc>
</function>
<function>
<name>getEventValue</name>
<desc>getEventValue(S32 eventID)</desc>
</function>
<function>
<name>getExecutableName</name>
<args>()</args>
<desc>@brief Gets the name of the game's executable

@return String containing this game's executable name
@ingroup FileSystem</desc>
</function>
<function>
<name>getField</name>
<args>( string text, int index )</args>
<desc>Extract the field at the given @a index in the newline and/or tab separated list in @a text.
Fields in @a text must be separated by newlines and/or tabs.
@param text A list of fields separated by newlines and/or tabs.
@param index The zero-based index of the field to extract.
@return The field at the given index or "" if the index is out of range.

@tsexample
getField( "a b" TAB "c d" TAB "e f", 1 ) // Returns "c d"
@endtsexample

@see getFields
@see getFieldCount
@see getWord
@see getRecord
@ingroup FieldManip</desc>
</function>
<function>
<name>getFieldCount</name>
<args>( string text )</args>
<desc>Return the number of newline and/or tab separated fields in @a text.
@param text A list of fields separated by newlines and/or tabs.
@return The number of newline and/or tab sepearated elements in @a text.

@tsexample
getFieldCount( "a b" TAB "c d" TAB "e f" ) // Returns 3
@endtsexample

@see getWordCount
@see getRecordCount
@ingroup FieldManip</desc>
</function>
<function>
<name>getFields</name>
<args>( string text, int startIndex, int endIndex=-1 )</args>
<desc>Extract a range of fields from the given @a startIndex onwards thru @a endIndex.
Fields in @a text must be separated by newlines and/or tabs.
@param text A list of fields separated by newlines and/or tabs.
@param startIndex The zero-based index of the first field to extract from @a text.
@param endIndex The zero-based index of the last field to extract from @a text.  If this is -1, all fields beginning with @a startIndex are extracted from @a text.
@return A string containing the specified range of fields from @a text or "" if @a startIndex is out of range or greater than @a endIndex.

@tsexample
getFields( "a b" TAB "c d" TAB "e f", 1 ) // Returns "c d" TAB "e f"
@endtsexample

@see getField
@see getFieldCount
@see getWords
@see getRecords
@ingroup FieldManip</desc>
</function>
<function>
<name>getFileCount</name>
<args>( string pattern, bool recurse=true )</args>
<desc>Get the number of files in the given directory tree matching the given @a pattern.
@param pattern The path and file name pattern to match against.
@param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename pattern counting files in subdirectories.
@return

@tsexample
// Count the number of .cs files in a subdirectory and its subdirectories.
getFileCount( "subdirectory/*.cs" );
@endtsexample

@see findFirstFile
@see findNextFile
@see getFileCountMultiExpr
@ingroup FileSearches</desc>
</function>
<function>
<name>getFileCountMultiExpr</name>
<args>(string pattern [, bool recurse])</args>
<desc>@brief Returns the number of files in the directory tree that match the given pattern

@param pattern The path and file name pattern to match against, such as "*.cs"
@param recurse If true, the search will exhaustively recurse into subdirectories of the given path and match the given filename patter.
@return Number of files located using the pattern
@ingroup FileSystem</desc>
</function>
<function>
<name>getFileCRC</name>
<desc>getFileCRC(filename)</desc>
</function>
<function>
<name>getJoystickAxes</name>
<desc>getJoystickAxes( instance )</desc>
</function>
<function>
<name>getLightManagerNames</name>
<args>()</args>
<desc>Returns a tab seperated list of light manager names.
@ingroup Lighting</desc>
</function>
<function>
<name>getMainDotCsDir</name>
<args>()</args>
<desc>Get the absolute path to the directory that contains the main.cs script from which the engine was started.
This directory will usually contain all the game assets and, in a user-side game installation, will usually be read-only.

@return The path to the main game assets.

@ingroup FileSystem
@ingroup Platform</desc>
</function>
<function>
<name>getMapEntry</name>
<desc>Returns the material name via the materialList mapTo entry

@return String containing the material name

@ingroup Materials</desc>
</function>
<function>
<name>getMaterialMapping</name>
<args>(string texName)</args>
<desc>@brief Gets the name of the material mapped to this texture.

param texName Name of the texture

@ingroup Materials</desc>
</function>
<function>
<name>getMax</name>
<args>( float v1, float v2 )</args>
<desc>Calculate the greater of two specified numbers.
@param v1 Input value.@param v2 Input value.@returns The greater value of the two specified values.@ingroup Math</desc>
</function>
<function>
<name>getMin</name>
<args>( float v1, float v2 )</args>
<desc>Calculate the lesser of two specified numbers.
@param v1 Input value.@param v2 Input value.@returns The lesser value of the two specified values.@ingroup Math</desc>
</function>
<function>
<name>getModNameFromPath</name>
<args>(string path)</args>
<desc>@brief Attempts to extract a mod directory from path. Returns empty string on failure.

@param File path of mod folder
@note This is no longer relevant in Torque 3D (which does not use mod folders), should be deprecated
@internal</desc>
</function>
<function>
<name>getNumSceneEvents</name>
<desc>getNumSceneEvents(S32 type,S32 actorID,S32 node)</desc>
</function>
<function>
<name>getPixelShaderVersion</name>
<args>()</args>
<desc>Returns the pixel shader version for the active device.
@ingroup GFX</desc>
</function>
<function>
<name>getPlatformTime</name>
<desc>getPlatformTime();</desc>
</function>
<function>
<name>getPrefsPath</name>
<args>([relativeFileName])</args>
<desc>@note Appears to be useless in Torque 3D, should be deprecated
@internal</desc>
</function>
<function>
<name>getRandom</name>
<args>( int a=1, int b=0 )</args>
<desc>Get a random number between @a a and @a b.
@param a Lower bound on the random number.  The random number will be &gt;= @a a.
@param b Upper bound on the random number.  The random number will be &lt;= @a b.
@return A pseudo-random number between @a a and @a b.
@see setRandomSeed
@ingroup Random</desc>
</function>
<function>
<name>getRandomSeed</name>
<args>()</args>
<desc>Get the current seed used by the random number generator.
@return The current random number generator seed value.
@ingroup Random</desc>
</function>
<function>
<name>getRealTime</name>
<args>()</args>
<desc>@brief Return the current real time in milliseconds.

Real time is platform defined; typically time since the computer booted.

@ingroup Platform</desc>
</function>
<function>
<name>getRecord</name>
<args>( string text, int index )</args>
<desc>Extract the record at the given @a index in the newline-separated list in @a text.
Records in @a text must be separated by newlines.
@param text A list of records separated by newlines.
@param index The zero-based index of the record to extract.
@return The record at the given index or "" if @a index is out of range.

@tsexample
getRecord( "a b" NL "c d" NL "e f", 1 ) // Returns "c d"
@endtsexample

@see getRecords
@see getRecordCount
@see getWord
@see getField
@ingroup FieldManip</desc>
</function>
<function>
<name>getRecordCount</name>
<args>( string text )</args>
<desc>Return the number of newline-separated records in @a text.
@param text A list of records separated by newlines.
@return The number of newline-sepearated elements in @a text.

@tsexample
getRecordCount( "a b" NL "c d" NL "e f" ) // Returns 3
@endtsexample

@see getWordCount
@see getFieldCount
@ingroup FieldManip</desc>
</function>
<function>
<name>getRecords</name>
<args>( string text, int startIndex, int endIndex=-1 )</args>
<desc>Extract a range of records from the given @a startIndex onwards thru @a endIndex.
Records in @a text must be separated by newlines.
@param text A list of records separated by newlines.
@param startIndex The zero-based index of the first record to extract from @a text.
@param endIndex The zero-based index of the last record to extract from @a text.  If this is -1, all records beginning with @a startIndex are extracted from @a text.
@return A string containing the specified range of records from @a text or "" if @a startIndex is out of range or greater than @a endIndex.

@tsexample
getRecords( "a b" NL "c d" NL "e f", 1 ) // Returns "c d" NL "e f"
@endtsexample

@see getRecord
@see getRecordCount
@see getWords
@see getFields
@ingroup FieldManip</desc>
</function>
<function>
<name>getSceneID</name>
<desc>getSceneID()</desc>
</function>
<function>
<name>getSceneName</name>
<desc>getSceneName()</desc>
</function>
<function>
<name>getScheduleDuration</name>
<desc>getScheduleDuration(%scheduleId);</desc>
</function>
<function>
<name>getServerCount</name>
<desc>getServerCount();</desc>
</function>
<function>
<name>getSimTime</name>
<args>()</args>
<desc>Return the current sim time in milliseconds.

@brief Sim time is time since the game started.

@ingroup Platform</desc>
</function>
<function>
<name>getSubStr</name>
<args>( string str, int start, int numChars=-1 )</args>
<desc>@brief Return a substring of @a str starting at @a start and continuing either through to the end of @a str (if @a numChars is -1) or for @a numChars characters (except if this would exceed the actual source string length).
@param str The string from which to extract a substring.
@param start The offset at which to start copying out characters.
@param numChars Optional argument to specify the number of characters to copy.  If this is -1, all characters up the end of the input string are copied.
@return A string that contains the given portion of the input stream.

@tsexample
getSubStr( "foobar", 1, 2 ) // Returns "oo".
@endtsexample

@ingroup Strings</desc>
</function>
<function>
<name>getTag</name>
<args>(string textTagString)</args>
<desc>@brief Extracts the tag from a tagged string
@ingroup Console</desc>
</function>
<function>
<name>getTaggedString</name>
<args>(int tag)</args>
<desc>@brief Use the getTaggedString function to convert a tag to a string.

This is not the same as detag() which can only be used within the context of a function that receives a tag. This function can be used any time and anywhere to convert a tag to a string.

@param tag A numeric tag ID.@ingroup Networking</desc>
</function>
<function>
<name>getTemporaryDirectory</name>
<args>()</args>
<desc>@brief Returns the OS temporary directory, "C:/Users/Mich/AppData/Local/Temp" for example

@note This can be useful to adhering to OS standards and practices, but not really used in Torque 3D right now.
@note Be very careful when getting into OS level File I/O.@return String containing path to OS temp directory
@note This is legacy function brought over from TGB, and does not appear to have much use. Possibly deprecate?
@ingroup FileSystem
@internal</desc>
</function>
<function>
<name>getTemporaryFileName</name>
<args>()</args>
<desc>@brief Creates a name and extension for a potential temporary file

This does not create the actual file. It simply creates a random name for a file that does not exist.

@note This is legacy function brought over from TGB, and does not appear to have much use. Possibly deprecate?
@ingroup FileSystem
@internal</desc>
</function>
<function>
<name>getTerrainHeight</name>
<args>(Point2 pos)</args>
<desc>gets the terrain height at the specified position.@param pos The world space point, minus the z (height) value
Can be formatted as either ("x y") or (x,y)
@return Returns the terrain height at the given point as an F32 value.
@hide</desc>
</function>
<function>
<name>getTerrainHeightBelowPosition</name>
<args>(Point3F pos)</args>
<desc>gets the terrain height at the specified position.@param pos The world space point. Can be formatted as either ("x y z") or (x,y,z)
@note This function is useful if you simply want to grab the terrain height underneath an object.
@return Returns the terrain height at the given point as an F32 value.
@hide</desc>
</function>
<function>
<name>getTerrainUnderWorldPoint</name>
<args>(Point3F x/y/z)</args>
<desc>Gets the terrain block that is located under the given world point.
@param x/y/z The world coordinates (floating point values) you wish to query at. These can be formatted as either a string ("x y z") or separately as (x, y, z)
@return Returns the ID of the requested terrain block (0 if not found).

@hide</desc>
</function>
<function>
<name>getTextureProfileStats</name>
<args>()</args>
<desc>Returns a list of texture profiles in the format: ProfileName TextureCount TextureMB
@ingroup GFX</desc>
</function>
<function>
<name>getTime</name>
<desc>getTime()</desc>
</function>
<function>
<name>getTimeSinceStart</name>
<desc>getTimeSinceStart(%scheduleId);</desc>
</function>
<function>
<name>getTrailingNumber</name>
<args>( string str )</args>
<desc>Get the numeric suffix of the given input string.
@param str The string from which to read out the numeric suffix.
@return The numeric value of the number suffix of @a str or -1 if @a str has no such suffix.

@tsexample
getTrailingNumber( "test123" ) // Returns '123'.
@endtsexample

@see stripTrailingNumber
@ingroup Strings</desc>
</function>
<function>
<name>getUniqueInternalName</name>
<args>( String baseName, SimSet set, bool searchChildren )</args>
<desc>@brief Returns a unique unused internal name within the SimSet/Group based on a given base name.

@note Currently only used by editors
@ingroup Editors
@internal</desc>
</function>
<function>
<name>getUniqueName</name>
<args>( String baseName )</args>
<desc>@brief Returns a unique unused SimObject name based on a given base name.

@baseName Name to conver to a unique string if another instance exists
@note Currently only used by editors
@ingroup Editors
@internal</desc>
</function>
<function>
<name>getUserDataDirectory</name>
<desc>getUserDataDirectory()</desc>
</function>
<function>
<name>getUserHomeDirectory</name>
<desc>getUserHomeDirectory()</desc>
</function>
<function>
<name>getVariable</name>
<args>(string varName)</args>
<desc>@brief Returns the value of the named variable or an empty string if not found.

@varName Name of the variable to search for
@return Value contained by varName, "" if the variable does not exist
@ingroup Scripting</desc>
</function>
<function>
<name>getVersionNumber</name>
<desc>Get the version of the build, as a string.</desc>
</function>
<function>
<name>getVersionString</name>
<desc>Get the version of the build, as a string.</desc>
</function>
<function>
<name>getWebDeployment</name>
<args>()</args>
<desc>Test whether Torque is running in web-deployment mode.
In this mode, Torque will usually run within a browser and certain restrictions apply (e.g. Torque will not be able to enter fullscreen exclusive mode).
@return True if Torque is running in web-deployment mode.
@ingroup Platform</desc>
</function>
<function>
<name>getWord</name>
<args>( string text, int index )</args>
<desc>Extract the word at the given @a index in the whitespace-separated list in @a text.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param index The zero-based index of the word to extract.
@return The word at the given index or "" if the index is out of range.

@tsexample
getWord( "a b c", 1 ) // Returns "b"
@endtsexample

@see getWords
@see getWordCount
@see getField
@see getRecord
@ingroup FieldManip</desc>
</function>
<function>
<name>getWordCount</name>
<args>( string text )</args>
<desc>Return the number of whitespace-separated words in @a text.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@return The number of whitespace-separated words in @a text.

@tsexample
getWordCount( "a b c d e" ) // Returns 5
@endtsexample

@see getFieldCount
@see getRecordCount
@ingroup FieldManip</desc>
</function>
<function>
<name>getWords</name>
<args>( string text, int startIndex, int endIndex=-1 )</args>
<desc>Extract a range of words from the given @a startIndex onwards thru @a endIndex.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param startIndex The zero-based index of the first word to extract from @a text.
@param endIndex The zero-based index of the last word to extract from @a text.  If this is -1, all words beginning with @a startIndex are extracted from @a text.
@return A string containing the specified range of words from @a text or "" if @a startIndex is out of range or greater than @a endIndex.

@tsexample
getWords( "a b c d", 1, 2, ) // Returns "b c"
@endtsexample

@see getWord
@see getWordCount
@see getFields
@see getRecords
@ingroup FieldManip</desc>
</function>
<function>
<name>getWorkingDirectory</name>
<args>()</args>
<desc>@brief Reports the current directory file system is in

@return String containing full file path of working directory
@ingroup FileSystem</desc>
</function>
<function>
<name>getXInputState</name>
<args>( int controllerID, string property, bool current )</args>
<desc>@brief Queries the current state of an Xbox 360 controller

@param controllerID Unique ID assigned to device at creation
@param property Constant name of input action being queried, such as "XI_THUMBLX"
@param current True checks current device in action
@return Integer containing state of input, 0 off, 1 on
@ingroup Input</desc>
</function>
<function>
<name>gotoWebPage</name>
<args>( string address )</args>
<desc>Open the given URL or file in the user's web browser.

@param address The address to open.  If this is not prefixed by a protocol specifier ("...://"), then the function checks whether the address refers to a file or directory and if so, prepends "file://" to @a adress; if the file check fails, "http://" is prepended to @a address.

@tsexample
gotoWebPage( "http://www.torquepowered.com" );
@endtsexample

@ingroup Platform</desc>
</function>
<function>
<name>importCachedFont</name>
<args>( string faceName, int fontSize, string fileName, int padding, int kerning )</args>
<desc>Import an image strip from exportCachedFont. Call with the same parameters you called exportCachedFont.
@param faceName The name of the font face.
@param fontSize The size of the font in pixels.
@param fileName The file name and path for the input PNG.
@param padding The padding between characters.
@param kerning The kerning between characters.
@ingroup Font</desc>
</function>
<function>
<name>initClientContainerRadiusSearch</name>
<args>(Point3F pos, float radius, bitset mask)</args>
<desc>Start a search for items within radius of pos, filtering by bitset mask.</desc>
</function>
<function>
<name>initContainerRadiusSearch</name>
<args>( Point3F pos, float radius, int mask )</args>
<desc>Start a search for items within radius of pos, filtering by mask.
@param pos Center position for the search
@param radius Search radius
@param mask Bitmask of object types to include in the search
@see containerSearchNext
@ingroup gameObjects</desc>
</function>
<function>
<name>initContainerTypeSearch</name>
<args>( int mask )</args>
<desc>Start a search for all items of the types specified by the bitset mask.@param mask Bitmask of object types to include in the search
@see containerSearchNext
@ingroup gameObjects</desc>
</function>
<function>
<name>initDisplayDeviceInfo</name>
<args>()</args>
<desc>@brief Initializes variables that track device and vendor information/IDs

@ingroup Rendering</desc>
</function>
<function>
<name>isalnum</name>
<args>( string str, int index )</args>
<desc>Test whether the character at the given position is an alpha-numeric character.
Alpha-numeric characters are characters that are either alphabetic or numbers.
@param str The string to test.
@param index The index of a character in @a str.
@return True if the character at the given index in @a str is an alpha-numeric character; false otherwise.

@see isspace
@ingroup Strings</desc>
</function>
<function>
<name>isClass</name>
<args>( string className )</args>
<desc>@brief Returns if the passed string is a defined class

@param className String containing the name of the class
@return True if the class exists, false if clas does not exist or className is something else
@ingroup Console</desc>
</function>
<function>
<name>isCurrentScriptToolScript</name>
<args>()</args>
<desc>Returns true if the calling script is a tools script.
@hide</desc>
</function>
<function>
<name>isDebugBuild</name>
<args>()</args>
<desc>Test whether the engine has been compiled with TORQUE_DEBUG, i.e. if it includes debugging functionality.

@return True if this is a debug build; false otherwise.

@ingroup Platform</desc>
</function>
<function>
<name>isDefined</name>
<desc>isDefined(varName)@brief Determines if a variable exists and contains a value
@param varName Name of the variable to search for
@return True if the variable was defined in script, false if not
@ingroup Scripting</desc>
</function>
<function>
<name>isDemo</name>
</function>
<function>
<name>IsDirectory</name>
<args>( string directory)</args>
<desc>@brief Determines if a specified directory exists or not

@param directory String containing path in the form of "foo/bar"

@note Do not include trailing /, is case insensitive, directory must have files in it if you expect the directory to be in a zip
@ingroup FileSystem</desc>
</function>
<function>
<name>isEventPending</name>
<desc>isEventPending(%scheduleId);</desc>
</function>
<function>
<name>isFile</name>
<desc>isFile(fileName)</desc>
</function>
<function>
<name>isFunction</name>
<args>(string funcName)</args>
<desc>@brief Determines if a function exists or not

@param funcName String containing name of the function
@return True if the function exists, false if not
@ingroup Scripting</desc>
</function>
<function>
<name>isJoystickDetected</name>
<desc>isJoystickDetected()</desc>
</function>
<function>
<name>isJoystickEnabled</name>
<args>()</args>
<desc>@brief Queries input manager to see if a joystick is enabled

@return True if a joystick exists and is enabled
@ingroup Input</desc>
</function>
<function>
<name>isKoreanBuild</name>
<desc>isKoreanBuild()</desc>
</function>
<function>
<name>isMemberOfClass</name>
<args>(classA, classB)</args>
<desc>@brief Determines if a class is a member of another

@param classA Parent class
@param classB Class to check if child of classA
@return Returns true if classA &lt;: classB.
@ingroup Console</desc>
</function>
<function>
<name>isMethod</name>
<args>(string namespace, string method)</args>
<desc>@brief Determines if a class/namespace method exists

@param namespace Class or namespace, such as Player
@param method Name of the funciton to search for
@return True if the method exists, false if not
@ingroup Scripting</desc>
</function>
<function>
<name>isObject</name>
<desc>isObject(object)</desc>
</function>
<function>
<name>isPackage</name>
<desc>isPackage(packageName)</desc>
</function>
<function>
<name>isPointInside</name>
<desc>Check to see if a point in world space is inside of an interior.@hide</desc>
</function>
<function>
<name>isQueueRegistered</name>
<args>(string queueName)</args>
<desc>@brief Determines if a dispatcher queue exists

@param queueName String containing the name of queue
@ingroup Platform</desc>
</function>
<function>
<name>isScriptPathExpando</name>
<args>(string expando)</args>
<desc>@internal Editor use only</desc>
</function>
<function>
<name>isShippingBuild</name>
<args>()</args>
<desc>Test whether the engine has been compiled with TORQUE_SHIPPING, i.e. in a form meant for final release.

@return True if this is a shipping build; false otherwise.

@ingroup Platform</desc>
</function>
<function>
<name>isspace</name>
<args>( string str, int index )</args>
<desc>Test whether the character at the given position is a whitespace character.
Characters such as tab, space, or newline are considered whitespace.
@param str The string to test.
@param index The index of a character in @a str.
@return True if the character at the given index in @a str is a whitespace character; false otherwise.

@see isalnum
@ingroup Strings</desc>
</function>
<function>
<name>isToolBuild</name>
<args>()</args>
<desc>Test whether the engine has been compiled with TORQUE_TOOLS, i.e. if it includes tool-related functionality.

@return True if this is a tool build; false otherwise.

@ingroup Platform</desc>
</function>
<function>
<name>isValidObjectName</name>
<args>( string name )</args>
<desc>@brief Return true if the given name makes for a valid object name.

@param name Name of object
@return True if name is allowed, false if denied (usually because it starts with a number, _, or invalid character@ingroup Console</desc>
</function>
<function>
<name>isWebDemo</name>
</function>
<function>
<name>isWriteableFileName</name>
<desc>isWriteableFileName(fileName)@brief Determines if a file name can be written to using File I/O

@param fileName Name and path of file to check
@return True if the file name can be written to
@ingroup FileSystem</desc>
</function>
<function>
<name>isXInputConnected</name>
<args>( int controllerID )</args>
<desc>@brief Checks to see if an Xbox 360 controller is connected

@param controllerID Unique ID assigned to device at creation
@ingroup Input</desc>
</function>
<function>
<name>lightScene</name>
<args>( string completeCallbackFn=NULL, string mode=NULL )</args>
<desc>Will generate static lighting for the scene if supported by the active light manager.

If mode is "forceAlways", the lightmaps will be regenerated regardless of whether lighting cache files can be written to. If mode is "forceWritable", then the lightmaps will be regenerated only if the lighting cache files can be written.
@param completeCallbackFn The name of the function to execute when the lighting is complete.
@param mode Either "forceAlways" or "forceWritable".
@return Returns true if the scene lighting process was started.
@ingroup Lighting</desc>
</function>
<function>
<name>listGFXResources</name>
<args>( bool unflaggedOnly=false )</args>
<desc>Returns a list of the unflagged GFX resources. See flagCurrentGFXResources for usage details.
@ingroup GFX
@see flagCurrentGFXResources, clearGFXResourceFlags, describeGFXResources</desc>
</function>
<function>
<name>loadColladaLights</name>
<args>(string filename, SimGroup parentGroup=MissionGroup, SimObject baseObject=-1)</args>
<desc>Load all light instances from a COLLADA (.dae) file and add to the scene.
@param filename COLLADA filename to load lights from
@param parentGroup (optional) name of an existing simgroup to add the new lights to (defaults to MissionGroup)
@param baseObject (optional) name of an object to use as the origin (useful if you are loading the lights for a collada scene and have moved or rotated the geometry)
@return true if successful, false otherwise

@tsexample
// load the lights in room.dae
loadColladaLights( "art/shapes/collada/room.dae" );

// load the lights in room.dae and add them to the RoomLights group
loadColladaLights( "art/shapes/collada/room.dae", "RoomLights" );

// load the lights in room.dae and use the transform of the "Room"
object as the origin
loadColladaLights( "art/shapes/collada/room.dae", "", "Room" );
@endtsexample

@note Currently for editor use only
@ingroup Editors
@internal</desc>
</function>
<function>
<name>loadObject</name>
<args>( string filename )</args>
<desc>@brief Load a plain-text serialized object form the given file.

@param Name and path to text file containing the object
@ingroup Scripting
@ingroup Console</desc>
</function>
<function>
<name>loadSceneEvents</name>
<desc>loadSceneEvents(S32 scene_id || const char *filename)</desc>
</function>
<function>
<name>lockMouse</name>
<args>(bool isLocked)</args>
<desc>@brief Lock the mouse (or not, depending on the argument's value) to the window.

@ingroup Platform</desc>
</function>
<function>
<name>log</name>
<args>( String string )</args>
<desc>Log a message to the console log.
@param string The message text.
@ingroup Logging</desc>
</function>
<function>
<name>logError</name>
<args>( String string )</args>
<desc>@brief Log an error message to the console log.

@param string The message text.
@ingroup Logging</desc>
</function>
<function>
<name>logWarning</name>
<args>( String string )</args>
<desc>@brief Log a warning message to the console log.
@param string The message text.

@ingroup Logging</desc>
</function>
<function>
<name>ltrim</name>
<args>( string str )</args>
<desc>Remove leading whitespace from the string.
@param str A string.
@return A string that is the same as @a str but with any leading (i.e. leftmost) whitespace removed.

@tsexample
ltrim( "   string  " ); // Returns "string  ".
@endtsexample
@see rtrim
@see trim
@ingroup Strings</desc>
</function>
<function>
<name>m2Pi</name>
<args>()</args>
<desc>Return the value of 2*PI (full-circle in radians).
@returns The value of 2*PI.@ingroup Math</desc>
</function>
<function>
<name>mAbs</name>
<args>( float v )</args>
<desc>Calculate absolute value of specified value.
@param v Input Value.@returns Absolute value of specified value.@ingroup Math</desc>
</function>
<function>
<name>mAcos</name>
<args>( float v )</args>
<desc>Calculate the arc-cosine of v.
@param v Input Value (in radians).@returns The arc-cosine of the input value.@ingroup Math</desc>
</function>
<function>
<name>makeFullPath</name>
<args>(string path)</args>
<desc>@brief Converts a relative file path to a full path

For example, "./console.log" becomes "C:/Torque/t3d/examples/FPS Example/game/console.log"
@param path Name of file or path to check
@return String containing non-relative directory of path
@ingroup FileSystem</desc>
</function>
<function>
<name>makeRelativePath</name>
<args>(string path, [string to])</args>
<desc>@brief Turns a full or local path to a relative one

For example, "./game/art" becomes "game/art"
@returns String containing relative path
@ingroup FileSystem</desc>
</function>
<function>
<name>mAsin</name>
<args>( float v )</args>
<desc>Calculate the arc-sine of v.
@param v Input Value (in radians).@returns The arc-sine of the input value.@ingroup Math</desc>
</function>
<function>
<name>mAtan</name>
<args>( float rise, float run )</args>
<desc>Calculate the arc-tangent (slope) of a line defined by rise and run.
@param rise of line.@param run of line.@returns The arc-tangent (slope) of a line defined by rise and run.@ingroup Math</desc>
</function>
<function>
<name>mathInit</name>
<args>( ... )</args>
<desc>@brief Install the math library with specified extensions.

Possible parameters are:

- 'DETECT' Autodetect math lib settings.

- 'C' Enable the C math routines. C routines are always enabled.

- 'FPU' Enable floating point unit routines.

- 'MMX' Enable MMX math routines.

- '3DNOW' Enable 3dNow! math routines.

- 'SSE' Enable SSE math routines.

@ingroup Math</desc>
</function>
<function>
<name>MatrixCreate</name>
<args>( VectorF position, AngAxisF orientation )</args>
<desc>Create a transform from the given translation and orientation.
@param position The translation vector for the transform.
@param orientation The axis and rotation that orients the transform.
@return A transform based on the given position and orientation.
@ingroup Matrices</desc>
</function>
<function>
<name>MatrixCreateFromEuler</name>
<args>(Vector3F e)</args>
<desc>@brief Create a matrix from the given rotations.

@param Vector3F containing the rotation
@ingroup Matrices</desc>
</function>
<function>
<name>MatrixMulPoint</name>
<args>(MatrixF xfrm, Point3F pnt)</args>
<desc>@brief Multiply pnt by xfrm.

@ingroup Matrices</desc>
</function>
<function>
<name>MatrixMultiply</name>
<args>(Matrix4F left, Matrix4F right)</args>
<desc>@brief Multiply the two matrices.

@ingroup Matrices</desc>
</function>
<function>
<name>MatrixMulVector</name>
<args>(MatrixF xfrm, Point3F vector)</args>
<desc>@brief Multiply the vector by the transform.

@ingroup Matrices</desc>
</function>
<function>
<name>mCeil</name>
<args>( float v )</args>
<desc>Round v up to the nearest integer.
@param v Number to convert to integer.@returns Number converted to integer.@ingroup Math</desc>
</function>
<function>
<name>mClamp</name>
<args>( float v, float min, float max )</args>
<desc>Clamp the specified value between two bounds.
@param v Input value.@param min Minimum Bound.@param max Maximum Bound.@returns The specified value clamped to the specified bounds.@ingroup Math</desc>
</function>
<function>
<name>mCos</name>
<args>( float v )</args>
<desc>Calculate the cosine of v.
@param v Input Value (in radians).@returns The cosine of the input value.@ingroup Math</desc>
</function>
<function>
<name>mDegToRad</name>
<args>( float degrees )</args>
<desc>Convert specified degrees into radians.
@param degrees Input Value (in degrees).@returns The specified degrees value converted to radians.@ingroup Math</desc>
</function>
<function>
<name>messageBox</name>
<args>( string title, string message, MBButtons buttons=MBOkCancel, MBIcons icons=MIInformation )</args>
<desc>Display a modal message box using the platform's native message box implementation.

@param title The title to display on the message box window.
@param message The text message to display in the box.
@param buttons Which buttons to put on the message box.
@param icons Which icon to show next to the message.
@return A value identifying the button that the user pressed.
@tsexample
messageBox( "Error", "" );
@endtsexample

@ingroup Platform</desc>
</function>
<function>
<name>mFloatLength</name>
<args>( float v, int precision )</args>
<desc>Formats the specified number to the given number of decimal places.
@param v Number to format.@param precision Number of decimal places to format to (1-9).@returns Number formatted to the specified number of decimal places.@ingroup Math</desc>
</function>
<function>
<name>mFloor</name>
<args>( float v )</args>
<desc>Round v down to the nearest integer.
@param v Number to convert to integer.@returns Number converted to integer.@ingroup Math</desc>
</function>
<function>
<name>mFMod</name>
<args>( float v, float d )</args>
<desc>Calculate the remainder of v/d.
@param v Input Value.@param d Divisor Value.@returns The remainder of v/d.@ingroup Math</desc>
</function>
<function>
<name>mIsPow2</name>
<args>( int v )</args>
<desc>Returns whether the value is an exact power of two.
@param v Input value.@returns Whether the specified value is an exact power of two.@ingroup Math</desc>
</function>
<function>
<name>mLerp</name>
<args>( float v1, float v2, float time )</args>
<desc>Calculate linearly interpolated value between two specified numbers using specified normalized time.
@param v1 Interpolate From Input value.@param v2 Interpolate To Input value.@param time Normalized time used to interpolate values (0-1).@returns The interpolated value between the two specified values at normalized time t.@ingroup Math</desc>
</function>
<function>
<name>mLog</name>
<args>( float v )</args>
<desc>Calculate the natural logarithm of v.
@param v Input Value.@returns The natural logarithm of the input value.@ingroup Math</desc>
</function>
<function>
<name>mPi</name>
<args>()</args>
<desc>Return the value of PI (half-circle in radians).
@returns The value of PI.@ingroup Math</desc>
</function>
<function>
<name>mPow</name>
<args>( float v, float p )</args>
<desc>Calculate b raised to the p-th power.
@param v Input Value.@param p Power to raise value by.@returns v raised to the p-th power.@ingroup Math</desc>
</function>
<function>
<name>mRadToDeg</name>
<args>( float radians )</args>
<desc>Convert specified radians into degrees.
@param radians Input Value (in radians).@returns The specified radians value converted to degrees.@ingroup Math</desc>
</function>
<function>
<name>mRound</name>
<args>( float v )</args>
<desc>Round v to the nearest integer.
@param v Number to convert to integer.@returns Number converted to integer.@ingroup Math</desc>
</function>
<function>
<name>mSaturate</name>
<args>( float v )</args>
<desc>Clamp the specified value between 0 and 1 (inclusive).
@param v Input value.@returns The specified value clamped between 0 and 1 (inclusive).@ingroup Math</desc>
</function>
<function>
<name>mSin</name>
<args>( float v )</args>
<desc>Calculate the sine of v.
@param v Input Value (in radians).@returns The sine of the input value.@ingroup Math</desc>
</function>
<function>
<name>mSolveCubic</name>
<args>( float a, float b, float c, float d )</args>
<desc>Solve a cubic equation (3rd degree polynomial) of form a*x^3 + b*x^2 + c*x + d = 0.
@param a First Coefficient.@param b Second Coefficient.@param c Third Coefficient.@param d Fourth Coefficient.@returns A 4-tuple, containing: (sol x0 x1 x2). (sol) is the number of solutions(being 0, 1, 2 or 3), and (x0), (x1) and (x2) are the solutions, if any.@ingroup Math</desc>
</function>
<function>
<name>mSolveQuadratic</name>
<args>( float a, float b, float c )</args>
<desc>Solve a quadratic equation (2nd degree polynomial) of form a*x^2 + b*x + c = 0.
@param a First Coefficient.@param b Second Coefficient.@param c Third Coefficient.@returns A triple, containing: (sol x0 x1). (sol) is the number of solutions(being 0, 1, or 2), and (x0) and (x1) are the solutions, if any.@ingroup Math</desc>
</function>
<function>
<name>mSolveQuartic</name>
<args>( float a, float b, float c, float d, float e )</args>
<desc>Solve a quartic equation (4th degree polynomial) of form a*x^4 + b*x^3 + c*x^2 + d*x + e = 0.
@param a First Coefficient.@param b Second Coefficient.@param c Third Coefficient.@param d Fourth Coefficient.@param e Fifth Coefficient.@returns A 5-tuple, containing: (sol x0 x1 x2 c3). (sol) is the number of solutions(being 0, 1, 2, 3 or 4), and (x0), (x1), (x2) and (x3) are the solutions, if any.@ingroup Math</desc>
</function>
<function>
<name>mSqrt</name>
<args>( float v )</args>
<desc>Calculate the square-root of v.
@param v Input Value.@returns The square-root of the input value.@ingroup Math</desc>
</function>
<function>
<name>mTan</name>
<args>( float v )</args>
<desc>Calculate the tangent of v.
@param v Input Value (in radians).@returns The tangent of the input value.@ingroup Math</desc>
</function>
<function>
<name>nameToID</name>
<desc>nameToID(object)</desc>
</function>
<function>
<name>nextToken</name>
<args>( string str, string token, string delimiters )</args>
<desc>Tokenize a string using a set of delimiting characters.
This function first skips all leading charaters in @a str that are contained in @a delimiters. From that position, it then scans for the next character in @a str that is contained in @a delimiters and stores all characters from the starting position up to the first delimiter in a variable in the current scope called @a token.  Finally, it skips all characters in @a delimiters after the token and then returns the remaining string contents in @a str.

To scan out all tokens in a string, call this function repeatedly by passing the result it returns each time as the new @a str until the function returns "".

@param str A string.
@param token The name of the variable in which to store the current token.  This variable is set in the scope in which nextToken is called.
@param delimiters A string of characters.  Each character is considered a delimiter.
@return The remainder of @a str after the token has been parsed out or "" if no more tokens were found in @a str.

@tsexample
// Stores "a" in the variable %token and sets %remainder to "b c".
%remainder = nextToken( "a b c", "token", " " );
@endtsexample

@ingroup Strings</desc>
</function>
<function>
<name>nxCastRay</name>
<desc>Point3F start, Point3F dir, F32 force, F32 damage, DirtExplosion, BrickExplosion, WaterExplosion,BloodExplosion</desc>
</function>
<function>
<name>nxDelayCastRay</name>
<desc>Point3F start, Point3F dir, F32 force, F32 damage, DirtExplosion, BrickExplosion, WaterExplosion,BloodExplosion</desc>
</function>
<function>
<name>nxNum</name>
</function>
<function>
<name>nxSampleRagdoll</name>
</function>
<function>
<name>openFile</name>
<args>( string file )</args>
<desc>Open the given @a file through the system.  This will usually open the file in its associated application.
@param file Path of the file to open.

@ingroup FileSystem
@ingroup Platform</desc>
</function>
<function>
<name>openFolder</name>
<args>( string path )</args>
<desc>Open the given folder in the system's file manager.
@param path Path to a directory.

@ingroup FileSystem
@ingroup Platform</desc>
</function>
<function>
<name>pathConcat</name>
<args>(string path, string file)</args>
<desc>@brief Combines two separate strings containing a file path and file name together into a single string

@param path String containing file path
@param file String containing file name
@return String containing concatenated file name and path
@ingroup FileSystem</desc>
</function>
<function>
<name>pathCopy</name>
<args>( string fromFile, string toFile, bool noOverwrite=true )</args>
<desc>Copy a file to a new location.
@param fromFile %Path of the file to copy.
@param toFile %Path where to copy @a fromFile to.
@param noOverwrite If true, then @a fromFile will not overwrite a file that may already exist at @a toFile.
@return True if the file was successfully copied, false otherwise.
@ingroup FileSystem</desc>
</function>
<function>
<name>pathOnMissionLoadDone</name>
<args>()</args>
<desc>Load all path information from interiors.
@tsexample
// Inform the engine to load all path information from interiors.
pathOnMissionLoadDone();

@endtsexample
@ingroup Game</desc>
</function>
<function>
<name>physCreateScene</name>
</function>
<function>
<name>physDestroyScene</name>
</function>
<function>
<name>physEndingMission</name>
</function>
<function>
<name>physicsDebugDraw</name>
<desc>physicsDebugDraw( bool enable )</desc>
</function>
<function>
<name>physicsDestroy</name>
<desc>physicsDestroy()</desc>
</function>
<function>
<name>physicsDestroyWorld</name>
<desc>physicsDestroyWorld( String worldName )</desc>
</function>
<function>
<name>physicsGetTimeScale</name>
<desc>physicsGetTimeScale()</desc>
</function>
<function>
<name>physicsInit</name>
<desc>physicsInit( [string library] )</desc>
</function>
<function>
<name>physicsInitWorld</name>
<desc>physicsInitWorld( String worldName )</desc>
</function>
<function>
<name>physicsPluginPresent</name>
<desc>physicsPluginPresent()
Returns true if a physics plugin exists and is initialized.</desc>
</function>
<function>
<name>physicsRestoreState</name>
<desc>physicsRestoreState()</desc>
</function>
<function>
<name>physicsSetTimeScale</name>
<desc>physicsSetTimeScale( F32 scale )</desc>
</function>
<function>
<name>physicsSimulationEnabled</name>
<desc>physicsSimulationEnabled()</desc>
</function>
<function>
<name>physicsStartSimulation</name>
<desc>physicsStartSimulation( String worldName )</desc>
</function>
<function>
<name>physicsStopSimulation</name>
<desc>physicsStopSimulation( String worldName )</desc>
</function>
<function>
<name>physicsStoreState</name>
<desc>physicsStoreState()</desc>
</function>
<function>
<name>playJournal</name>
<args>(string filename, bool break=false)</args>
<desc>@brief Begin playback of a journal from a specified field, optionally breaking at the start.

@param filename Name and path of file journal file
@ingroup Platform</desc>
</function>
<function>
<name>playJournalToVideo</name>
<args>( string journalFile, string videoFile=NULL, string encoder="THEORA", float framerate=30.0f, Point2I resolution=Point2I( 0, 0 ) )</args>
<desc>Load a journal file and capture it video.
@ingroup Rendering</desc>
</function>
<function>
<name>popInstantGroup</name>
<args>()</args>
<desc>@brief Pop and restore the last setting of $instantGroup off the stack.

@note Currently only used for editors

@ingroup Editors
@internal</desc>
</function>
<function>
<name>populateAllFontCacheRange</name>
<args>( int rangeStart, int rangeEnd )</args>
<desc>Populate the font cache for all fonts with Unicode code points in the specified range.
@param rangeStart The start Unicode point.
@param rangeEnd The end Unicode point.
@note We only support BMP-0, so code points range from 0 to 65535.
@ingroup Font</desc>
</function>
<function>
<name>populateAllFontCacheString</name>
<args>( string string )</args>
<desc>Populate the font cache for all fonts with characters from the specified string.
@ingroup Font</desc>
</function>
<function>
<name>populateFontCacheRange</name>
<args>( string faceName, int fontSize, int rangeStart, int rangeEnd )</args>
<desc>Populate the font cache for the specified font with Unicode code points in the specified range.
@param faceName The name of the font face.
@param fontSize The size of the font in pixels.
@param rangeStart The start Unicode point.
@param rangeEnd The end Unicode point.
@note We only support BMP-0, so code points range from 0 to 65535.
@ingroup Font</desc>
</function>
<function>
<name>populateFontCacheString</name>
<args>( string faceName, int fontSize, string string )</args>
<desc>Populate the font cache for the specified font with characters from the specified string.
@param faceName The name of the font face.
@param size The size of the font in pixels.
@param string The string to populate.
@ingroup Font</desc>
</function>
<function>
<name>preloadClientDataBlocks</name>
<desc>Preload all datablocks in client mode.  (Server parameter is set to false).  This will take some time to complete.</desc>
</function>
<function>
<name>profilerDump</name>
<args>()</args>
<desc>@brief Dump the current state of the profiler.

@ingroup Debuggin</desc>
</function>
<function>
<name>profilerDumpToFile</name>
<args>(string filename)</args>
<desc>@brief Dump profiling stats to a file.

@filename Name and path of file to save to
@ingroup Debugging</desc>
</function>
<function>
<name>profilerEnable</name>
<args>(bool enable)</args>
<desc>@brief Turn on the profiler

@ingroup Debugging</desc>
</function>
<function>
<name>profilerMarkerEnable</name>
<args>( string markerName, bool enable=true )</args>
<desc>@brief Enable or disable a specific profile

@param Name of tag as a specific marker to start profiling
@param True to enable immediately
@ingroup Debugging</desc>
</function>
<function>
<name>profilerReset</name>
<args>()</args>
<desc>@brief Resets the profiler, clearing all of its data.

@ingroup Debugging</desc>
</function>
<function>
<name>pushInstantGroup</name>
<args>([group])</args>
<desc>@brief Pushes the current $instantGroup on a stack and sets it to the given value (or clears it).

@note Currently only used for editors
@ingroup Editors
@internal</desc>
</function>
<function>
<name>queryLanServers</name>
<desc>queryLanServers(...);</desc>
</function>
<function>
<name>queryMasterServer</name>
<desc>queryMasterServer(...);</desc>
</function>
<function>
<name>querySingleServer</name>
<desc>querySingleServer(address, flags);</desc>
</function>
<function>
<name>quit</name>
<args>()</args>
<desc>Shut down the engine and exit its process.
This function cleanly uninitializes the engine and then exits back to the system with a process exit status indicating a clean exit.

@see quitWithErrorMessage

@ingroup Platform</desc>
</function>
<function>
<name>quitWithErrorMessage</name>
<args>( string message )</args>
<desc>Display an error message box showing the given @a message and then shut down the engine and exit its process.
This function cleanly uninitialized the engine and then exits back to the system with a process exit status indicating an error.

@param message The message to log to the console and show in an error message box.

@see quit

@ingroup Platform</desc>
</function>
<function>
<name>redbookClose</name>
<desc>Close the current Redbook device.@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookGetDeviceCount</name>
<desc>get the number of redbook devices.@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookGetDeviceName</name>
<args>(int index)</args>
<desc>Get name of specified Redbook device.@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookGetLastError</name>
<desc>Get a string explaining the last redbook error.@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookGetTrackCount</name>
<desc>Return the number of tracks.@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookGetVolume</name>
<desc>Get the volume.@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookOpen</name>
<args>(string device=NULL)</args>
<desc>@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookPlay</name>
<args>(int track)</args>
<desc>Play the selected track.@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookSetVolume</name>
<args>(float volume)</args>
<desc>Set playback volume.@brief Deprecated

@internal</desc>
</function>
<function>
<name>redbookStop</name>
<desc>Stop playing.@brief Deprecated

@internal</desc>
</function>
<function>
<name>registerMessageListener</name>
<args>(queueName, listener)</args>
<desc>@brief Registers an event message

@param queueName String containing the name of queue to attach listener to
@param listener Name of event messenger
@ingroup Platform</desc>
</function>
<function>
<name>registerMessageQueue</name>
<args>(string queueName)</args>
<desc>@brief Registeres a dispatcher queue

@param queueName String containing the name of queue
@ingroup Platform</desc>
</function>
<function>
<name>reInitMaterials</name>
<desc>@brief Flushes all the procedural shaders and re-initializes all the active materials instances.

@ingroup Materials</desc>
</function>
<function>
<name>reloadResource</name>
<args>( string path )</args>
<desc>Force the resource at specified input path to be reloaded
@param path Path to the resource to be reloaded

@tsexample
reloadResource( "art/shapes/box.dts" );
@endtsexample

@note Currently used by editors only
@ingroup Editors
@internal</desc>
</function>
<function>
<name>reloadTextures</name>
<args>()</args>
<desc>Reload all the textures from disk.
@ingroup GFX</desc>
</function>
<function>
<name>removeField</name>
<args>( string text, int index )</args>
<desc>Remove the field in @a text at the given @a index.
Fields in @a text must be separated by newlines and/or tabs.
@param text A list of fields separated by newlines and/or tabs.
@param index The zero-based index of the field in @a text.
@return A new string with the field at the given index removed or the original string if @a index is out of range.

@tsexample
removeField( "a b" TAB "c d" TAB "e f", 1 ) // Returns "a b" TAB "e f"
@endtsexample

@see removeWord
@see removeRecord
@ingroup FieldManip</desc>
</function>
<function>
<name>removeGlobalShaderMacro</name>
<args>( string name )</args>
<desc>Removes an existing global macro by name.
@see addGlobalShaderMacro
@ingroup Rendering</desc>
</function>
<function>
<name>removeRecord</name>
<args>( string text, int index )</args>
<desc>Remove the record in @a text at the given @a index.
Records in @a text must be separated by newlines.
@param text A list of records separated by newlines.
@param index The zero-based index of the record in @a text.
@return A new string with the record at the given @a index removed or the original string if @a index is out of range.

@tsexample
removeRecord( "a b" NL "c d" NL "e f", 1 ) // Returns "a b" NL "e f"
@endtsexample

@see removeWord
@see removeField
@ingroup FieldManip</desc>
</function>
<function>
<name>removeScriptPathExpando</name>
<args>(string expando)</args>
<desc>@internal Editor use only</desc>
</function>
<function>
<name>removeTaggedString</name>
<args>(int tag)</args>
<desc>@brief Remove a tagged string from the Net String Table

@param The tag associated with the string

@ingroup Networking</desc>
</function>
<function>
<name>removeWord</name>
<args>( string text, int index )</args>
<desc>Remove the word in @a text at the given @a index.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param index The zero-based index of the word in @a text.
@return A new string with the word at the given index removed or the original string if @a index is out of range.

@tsexample
removeWord( "a b c d", 2 ) // Returns "a b d"
@endtsexample

@see removeField
@see removeRecord
@ingroup FieldManip</desc>
</function>
<function>
<name>resetFPSTracker</name>
<args>()</args>
<desc>@brief Reset FPS stats (fps::)

@ingroup Game</desc>
</function>
<function>
<name>resetLightManager</name>
<args>()</args>
<desc>@brief Deactivates and then activates the currently active light manager.This causes most shaders to be regenerated and is often used when global rendering changes have occured.
@ingroup Lighting</desc>
</function>
<function>
<name>resetXInput</name>
<desc>resetXInput()@brief Rebuilds the XInput section of the InputManager

@ingroup Input</desc>
</function>
<function>
<name>restartInstance</name>
<desc>restartInstance()</desc>
</function>
<function>
<name>restWords</name>
<args>( string text )</args>
<desc>Return all but the first word in @a text.
@param text A list of words separated by newlines, spaces, and/or tabs.
@return @a text with the first word removed.

@note This is equal to
@tsexample_nopar
getWords( text, 1 )
@endtsexample

@see getWords
@ingroup FieldManip</desc>
</function>
<function>
<name>rtrim</name>
<args>( string str )</args>
<desc>Remove trailing whitespace from the string.
@param str A string.
@return A string that is the same as @a str but with any trailing (i.e. rightmost) whitespace removed.

@tsexample
rtrim( "   string  " ); // Returns "   string".
@endtsexample
@see ltrim
@see trim
@ingroup Strings</desc>
</function>
<function>
<name>rumble</name>
<args>(string device, float xRumble, float yRumble)</args>
<desc>@brief Rumbles the specified controller with constant force feedback in the (x, y) direction.

Valid inputs for xRumble/yRumble are [0 - 1].
@param device Name of the device to rumble
@param xRumble Intensity to apply to xRumble motor
@param yRumble Intensity to apply to yRumble motor
@ingroup Input</desc>
</function>
<function>
<name>saveJournal</name>
<args>(string filename)</args>
<desc>Save the journal to the specified file.

@ingroup Platform</desc>
</function>
<function>
<name>saveObject</name>
<args>( object, string filename )</args>
<desc>@brief Save the given object to the given filename in plain-text form.

@param object Name or ID of object to save
@param filename Name and path of text file to save object to
@ingroup Scripting
@ingroup Console</desc>
</function>
<function>
<name>saveScene</name>
<desc>saveScene()</desc>
</function>
<function>
<name>saveSceneEvent</name>
<desc>saveSceneEvent(S32 eventID,S32 eventType,S32 physUser,F32 time,F32 duration,S32 node,Point3F value,const char *action)</desc>
</function>
<function>
<name>saveSceneEvents</name>
<desc>saveSceneEvents(const char *filename)</desc>
</function>
<function>
<name>schedule</name>
<desc>schedule(time, refobject|0, command, &lt;arg1...argN&gt;)</desc>
</function>
<function>
<name>screenShot</name>
<args>( string file, string format, int tileCount=1, float tileOverlap=0 )</args>
<desc>Takes a screenshot with optional tiling to produce huge screenshots.
@param file The output image file path.
@param format Either JPEG or PNG.
@param tileCount If greater than 1 will tile the current screen size to take a large format screenshot.
@param tileOverlap The amount of horizontal and vertical overlap between the tiles used to remove tile edge artifacts from post effects.
@ingroup GFX</desc>
</function>
<function>
<name>setArenaBot</name>
<desc>setArenaBot(shapebase_id);</desc>
</function>
<function>
<name>setClipboard</name>
<args>(string text)</args>
<desc>@brief Set the system clipboard.

@internal</desc>
</function>
<function>
<name>setCoreLangTable</name>
<args>(LangTable)</args>
<desc>@brief Sets the primary LangTable used by the game

@param LangTable ID of the core LangTable
@ingroup Localization</desc>
</function>
<function>
<name>setCurrentDirectory</name>
<args>( string path )</args>
<desc>Set the current working directory.

@param path The absolute or relative (to the current working directory) path of the directory which should be made the new working directory.

@return True if the working directory was successfully changed to @a path, false otherwise.

@ingroup FileSystem
@ingroup Platform</desc>
</function>
<function>
<name>setDebugRender</name>
</function>
<function>
<name>setDefaultFov</name>
<args>(defaultFov)</args>
<desc>@brief Set the default FOV for a camera.

@ingroup CameraSystem</desc>
</function>
<function>
<name>setDR</name>
</function>
<function>
<name>setEcstasyProject</name>
<desc>setEcstasyProject(const char *filename)</desc>
</function>
<function>
<name>setEventAction</name>
<desc>setEventAction(S32 eventID, const char *action)</desc>
</function>
<function>
<name>setEventCause</name>
<desc>setEventCause(S32 eventID,S32 causeID)</desc>
</function>
<function>
<name>setEventDuration</name>
<desc>setEventDuration(S32 eventID,F32 duration)</desc>
</function>
<function>
<name>setEventNode</name>
<desc>setEventNode(S32 eventID,S32 node)</desc>
</function>
<function>
<name>setEventPhysUser</name>
<desc>setEventPhysUser(S32 eventID,S32 actorID)</desc>
</function>
<function>
<name>setEventTime</name>
<desc>setEventTime(S32 eventID,F32 time)</desc>
</function>
<function>
<name>setEventType</name>
<desc>setEventType(S32 eventID,S32 type)</desc>
</function>
<function>
<name>setEventValue</name>
<desc>setEventValue(S32 eventID, Point3F value)</desc>
</function>
<function>
<name>setField</name>
<args>( string text, int index, string replacement )</args>
<desc>Replace the field in @a text at the given @a index with @a replacement.
Fields in @a text must be separated by newlines and/or tabs.
@param text A list of fields separated by newlines and/or tabs.
@param index The zero-based index of the field to replace.
@param replacement The string with which to replace the field.
@return A new string with the field at the given @a index replaced by @a replacement or the original string if @a index is out of range.

@tsexample
setField( "a b" TAB "c d" TAB "e f", 1, "g h" ) // Returns "a b" TAB "g h" TAB "e f"
@endtsexample

@see getField
@see setWord
@see setRecord
@ingroup FieldManip</desc>
</function>
<function>
<name>setFov</name>
<args>(fov)</args>
<desc>@brief Set the FOV of the camera.

@ingroup CameraSystem</desc>
</function>
<function>
<name>setInteriorFocusedDebug</name>
<args>(bool enable)</args>
<desc>@brief No longer properly supported

@internal</desc>
</function>
<function>
<name>setInteriorRenderMode</name>
<args>( int mode )</args>
<desc>Globally changes how InteriorInstances are rendered. Useful for debugging geometry and rendering artifacts
@note This does not work in shipping mode

@param mode The render mode can be one of:

NormalRender            = 0,
NormalRenderLines       = 1,
ShowDetail              = 2,

ShowAmbiguous           = 3,

ShowOrphan              = 4,

ShowLightmaps           = 5,

ShowTexturesOnly        = 6,

ShowPortalZones         = 7,

ShowOutsideVisible      = 8,

ShowCollisionFans       = 9,

ShowStrips              = 10,

ShowNullSurfaces        = 11,

ShowLargeTextures       = 12,

ShowHullSurfaces        = 13,

ShowVehicleHullSurfaces = 14,

ShowVertexColors        = 15,

ShowDetailLevel         = 16

@ingroup Game</desc>
</function>
<function>
<name>setLightManager</name>
<args>( string name )</args>
<desc>Finds and activates the named light manager.
@return Returns true if the light manager is found and activated.
@ingroup Lighting</desc>
</function>
<function>
<name>setLogMode</name>
<args>( int mode )</args>
<desc>Set the operational mode of the console logging system.
@param mode The logging mode.  This can be one of:
- 1: Open and close the console log file for each seperate string of output.  This will ensure that all parts get written out to disk and that no parts remain in intermediate buffers even if the process crashes.
- 2: Keep the log file open and write to it continuously.  This will make the system operate faster but if the process crashes, parts of the output may not have been written to disk yet and will be missing from the log.

Additionally, when changing the log mode and thus opening a new log file, either of the two mode values may be combined by binary OR with 0x4 to cause the logging system to flush all console log messages that had already been issued to the console system to the newly created log file.

@ingroup Logging</desc>
</function>
<function>
<name>setMissionName</name>
<desc>setMissionName(char *name)</desc>
</function>
<function>
<name>setMouseValue</name>
<desc>S32 value</desc>
</function>
<function>
<name>setNetPort</name>
<args>(int port, bool bind=true)</args>
<desc>@brief Set the network port for the game to use.  If bind is true, bind()will be called on the port.

This will trigger a windows firewall prompt. If you don't have firewall tunneling tech you can set this to false to avoid the prompt.

@ingroup Networking</desc>
</function>
<function>
<name>setPixelShaderVersion</name>
<args>( float version )</args>
<desc>@brief Sets the pixel shader version for the active device.
This can be used to force a lower pixel shader version than is supported by the device for testing or performance optimization.
@param version The floating point shader version number.
@note This will only affect shaders/materials created after the call and should be used before the game begins.
@see $pref::Video::forcedPixVersion
@ingroup GFX</desc>
</function>
<function>
<name>setRandomSeed</name>
<args>( int seed=-1 )</args>
<desc>Set the current seed for the random number generator.
Based on this seed, a repeatable sequence of numbers will be produced by getRandom().
@param seed The seed with which to initialize the randon number generator with.  The same seed will always leed tothe same sequence of pseudo-random numbers.
If -1, the current timestamp will be used as the seed which is a good basis for randomization.
@ingroup Random</desc>
</function>
<function>
<name>setRecord</name>
<args>( string text, int index, string replacement )</args>
<desc>Replace the record in @a text at the given @a index with @a replacement.
Records in @a text must be separated by newlines.
@param text A list of records separated by newlines.
@param index The zero-based index of the record to replace.
@param replacement The string with which to replace the record.
@return A new string with the record at the given @a index replaced by @a replacement or the original string if @a index is out of range.

@tsexample
setRecord( "a b" NL "c d" NL "e f", 1, "g h" ) // Returns "a b" NL "g h" NL "e f"
@endtsexample

@see getRecord
@see setWord
@see setField
@ingroup FieldManip</desc>
</function>
<function>
<name>setReflectFormat</name>
<args>( GFXFormat format )</args>
<desc>Set the reflection texture format.
@ingroup GFX</desc>
</function>
<function>
<name>setSceneName</name>
<desc>setSceneName(char *name)</desc>
</function>
<function>
<name>setSceneRecordGlobal</name>
<desc>setSceneRecordGlobal()</desc>
</function>
<function>
<name>setSceneRecordLocal</name>
<desc>setSceneRecordLocal()</desc>
</function>
<function>
<name>setScriptPathExpando</name>
<args>(string expando, string path[, bool toolsOnly])</args>
<desc>@internal Editor use only</desc>
</function>
<function>
<name>setServerInfo</name>
<desc>setServerInfo(index);</desc>
</function>
<function>
<name>setShadowManager</name>
<desc>string sShadowSystemName</desc>
</function>
<function>
<name>setShadowVizLight</name>
</function>
<function>
<name>setTweakerOne</name>
<desc>setTweakerOne(shapebase_id);</desc>
</function>
<function>
<name>setTweakerTwo</name>
<desc>setTweakerTwo(shapebase_id);</desc>
</function>
<function>
<name>setVariable</name>
<args>(string varName, string value)</args>
<desc>@brief Sets the value of the named variable.

@param varName Name of the variable to locate
@param value New value of the variable
@return True if variable was successfully found and set
@ingroup Scripting</desc>
</function>
<function>
<name>setVISBodyAxes</name>
<desc>bool</desc>
</function>
<function>
<name>setVISCollisionShapes</name>
<desc>bool</desc>
</function>
<function>
<name>setVISJointAxes</name>
<desc>bool</desc>
</function>
<function>
<name>setVISJointLimits</name>
<desc>bool</desc>
</function>
<function>
<name>setWord</name>
<args>( string text, int index, string replacement )</args>
<desc>Replace the word in @a text at the given @a index with @a replacement.
Words in @a text must be separated by newlines, spaces, and/or tabs.
@param text A whitespace-separated list of words.
@param index The zero-based index of the word to replace.
@param replacement The string with which to replace the word.
@return A new string with the word at the given @a index replaced by @a replacement or the original string if @a index is out of range.

@tsexample
setWord( "a b c d", 2, "f" ) // Returns "a b f d"
@endtsexample

@see getWord
@see setField
@see setRecord
@ingroup FieldManip</desc>
</function>
<function>
<name>setZoomSpeed</name>
<args>(speed)</args>
<desc>@brief Set the zoom speed of the camera, in ms per 90deg FOV change.

@ingroup CameraSystem</desc>
</function>
<function>
<name>sfxCreateDevice</name>
<args>( string provider, string device, bool useHardware, int maxBuffers )</args>
<desc>Try to create a new sound device using the given properties.
If a sound device is currently initialized, it will be uninitialized first.  However, be aware that in this case, if this function fails, it will not restore the previously active device but rather leave the sound system in an uninitialized state.

Sounds that are already playing while the new device is created will be temporarily transitioned to virtualized playback and then resume normal playback once the device has been created.

In the core scripts, sound is automatically set up during startup in the sfxStartup() function.

@param provider The name of the device provider as returned by sfxGetAvailableDevices().
@param device The name of the device as returned by sfxGetAvailableDevices().
@param useHardware Whether to enabled hardware mixing on the device or not.  Only relevant if supported by the given device.
@param maxBuffers The maximum number of concurrent voices for this device to use or -1 for the device to pick its own reasonable default.@return True if the initialization was successful, false if not.
@note This function must be called before any of the sound playback functions can be used.
@see sfxGetAvailableDevices
@see sfxGetDeviceInfo
@see sfxDeleteDevice

@ref SFX_devices
@ingroup SFX</desc>
</function>
<function>
<name>sfxCreateSource</name>
<args>( SFXTrack track | ( SFXDescription description, string filename ) [, float x, float y, float z ] )</args>
<desc>Creates a new paused sound source using a profile or a description and filename.  The return value is the source which must be released by delete().
@hide</desc>
</function>
<function>
<name>sfxDeleteDevice</name>
<args>()</args>
<desc>Delete the currently active sound device and release all its resources.
SFXSources that are still playing will be transitioned to virtualized playback mode. When creating a new device, they will automatically transition back to normal playback.

In the core scripts, this is done automatically for you during shutdown in the sfxShutdown() function.

@see sfxCreateDevice

@ref SFX_devices
@ingroup SFX</desc>
</function>
<function>
<name>sfxDeleteWhenStopped</name>
<args>( SFXSource source )</args>
<desc>Mark the given @a source for deletion as soon as it moves into stopped state.

This function will retroactively turn the given @a source into a play-once source (see @ref SFXSource_playonce).

@param source A sound source.

@ingroup SFX</desc>
</function>
<function>
<name>sfxDumpSources</name>
<args>( bool includeGroups=false )</args>
<desc>Dump information about all current SFXSource instances to the console.
The dump includes information about the playback status for each source, volume levels, virtualization, etc.
@param includeGroups If true, direct instances of SFXSources (which represent logical sound groups) will be included. Otherwise only instances of subclasses of SFXSources are included in the dump.
@see SFXSource
@see sfxDumpSourcesToString
@ingroup SFX</desc>
</function>
<function>
<name>sfxDumpSourcesToString</name>
<args>( bool includeGroups=false )</args>
<desc>Dump information about all current SFXSource instances to a string.
The dump includes information about the playback status for each source, volume levels, virtualization, etc.
@param includeGroups If true, direct instances of SFXSources (which represent logical sound groups) will be included. Otherwise only instances of subclasses of SFXSources are included in the dump.
@return A string containing a dump of information about all currently instantiated SFXSources.
@see SFXSource
@see sfxDumpSources
@ingroup SFX</desc>
</function>
<function>
<name>sfxGetActiveStates</name>
<args>()</args>
<desc>Return a newline-separated list of all active states.
@return A list of the form
@verbatim
stateName1 NL stateName2 NL stateName3 ...
@endverbatim
where each element is the name of an active state object.

@tsexample
// Disable all active states.
foreach$( %state in sfxGetActiveStates() )
%state.disable();
@endtsexample

@ingroup SFX</desc>
</function>
<function>
<name>sfxGetAvailableDevices</name>
<args>()</args>
<desc>Get a list of all available sound devices.
The return value will be a newline-separated list of entries where each line describes one available sound device.  Each such line will have the following format:@verbatim
provider TAB device TAB hasHardware TAB numMaxBuffers
@endverbatim
- provider: The name of the device provider (e.g. "FMOD").
- device: The name of the device as returned by the device layer.
- hasHardware: Whether the device supports hardware mixing or not.
- numMaxBuffers: The maximum number of concurrent voices supported by the device's mixer.  If this limit limit is exceeded, i.e. if there are more active sounds playing at any one time, then voice virtualization will start culling voices and put them into virtualized playback mode.  Voice virtualization may or may not be provided by the device itself; if not provided by the device, it will be provided by Torque's sound system.

@return A newline-separated list of information about all available sound devices.
@see sfxCreateDevice
@see sfxGetDeviceInfo

@see $SFX::DEVICE_INFO_PROVIDER

@see $SFX::DEVICE_INFO_NAME

@see $SFX::DEVICE_INFO_USEHARDWARE

@see $SFX::DEVICE_INFO_MAXBUFFERS

@ref SFX_devices
@ingroup SFX</desc>
</function>
<function>
<name>sfxGetDeviceInfo</name>
<args>()</args>
<desc>Return information about the currently active sound device.
The return value is a tab-delimited string of the following format:
@verbatim
provider TAB device TAB hasHardware TAB numMaxBuffers TAB caps
@endverbatim
- provider: The name of the device provider (e.g. "FMOD").
- device: The name of the device as returned by the device layer.
- hasHardware: Whether the device supports hardware mixing or not.
- numMaxBuffers: The maximum number of concurrent voices supported by the device's mixer.  If this limit limit is exceeded, i.e. if there are more active sounds playing at any one time, then voice virtualization will start culling voices and put them into virtualized playback mode.  Voice virtualization may or may not be provided by the device itself; if not provided by the device, it will be provided by Torque's sound system.
- caps: A bitfield of capability flags.

@return A tab-separated list of properties of the currently active sound device or the empty string if no sound device has been initialized.
@see sfxCreateDevice
@see sfxGetAvailableDevices

@see $SFX::DEVICE_INFO_PROVIDER

@see $SFX::DEVICE_INFO_NAME

@see $SFX::DEVICE_INFO_USEHARDWARE

@see $SFX::DEVICE_INFO_MAXBUFFERS

@see $SFX::DEVICE_INFO_CAPS

@see $SFX::DEVICE_CAPS_REVERB

@see $SFX::DEVICE_CAPS_VOICEMANAGEMENT

@see $SFX::DEVICE_CAPS_OCCLUSION

@see $SFX::DEVICE_CAPS_DSPEFFECTS

@see $SFX::DEVICE_CAPS_MULTILISTENER

@see $SFX::DEVICE_CAPS_FMODDESIGNER

@ref SFX_devices
@ingroup SFX</desc>
</function>
<function>
<name>sfxGetDistanceModel</name>
<args>()</args>
<desc>Get the falloff curve type currently being applied to 3D sounds.

@return The current distance model type.

@ref SFXSource_volume

@ref SFX_3d

@ingroup SFX</desc>
</function>
<function>
<name>sfxGetDopplerFactor</name>
<args>()</args>
<desc>Get the current global doppler effect setting.

@return The current global doppler effect scale factor (&gt;=0).

@see sfxSetDopplerFactor

@ref SFXSource_doppler

@ingroup SFX</desc>
</function>
<function>
<name>sfxGetRolloffFactor</name>
<args>()</args>
<desc>Get the current global scale factor applied to volume attenuation of 3D sounds in the logarithmic model.
@return The current scale factor for logarithmic 3D sound falloff curves.

@see sfxGetDistanceModel
@see SFXDistanceModel

@ref SFXSource_volume
@ref SFX_3d
@ingroup SFX</desc>
</function>
<function>
<name>sfxPlay</name>
<args>( SFXSource source | ( SFXTrack track [, float x, float y, float z ] ) )</args>
<desc>Start playing the given source or create a new source for the given track and play it.
@hide</desc>
</function>
<function>
<name>sfxPlayOnce</name>
<desc>SFXSource sfxPlayOnce( ( SFXTrack track | SFXDescription description, string filename ) [, float x, float y, float z, float fadeInTime=-1 ] ) Create a new play-once source for the given profile or description+filename and start playback of the source.
@hide</desc>
</function>
<function>
<name>sfxSetDistanceModel</name>
<args>( SFXDistanceModel model )</args>
<desc>Set the falloff curve type to use for distance-based volume attenuation of 3D sounds.

@param model The distance model to use for 3D sound.

@note This setting takes effect globally and is applied to all 3D sounds.

@ingroup SFX</desc>
</function>
<function>
<name>sfxSetDopplerFactor</name>
<args>( float value )</args>
<desc>Set the global doppler effect scale factor.
@param value The new doppler shift scale factor.
@pre @a value must be &gt;= 0.
@see sfxGetDopplerFactor

@ref SFXSource_doppler

@ingroup SFX</desc>
</function>
<function>
<name>sfxSetRolloffFactor</name>
<args>( float value )</args>
<desc>Set the global scale factor to apply to volume attenuation of 3D sounds in the logarithmic model.
@param value The new scale factor for logarithmic 3D sound falloff curves.

@pre @a value must be &gt; 0.
@note This function has no effect if the currently distance model is set to SFXDistanceModel::Linear.

@see sfxGetDistanceModel
@see SFXDistanceModel

@ref SFXSource_volume
@ref SFX_3d
@ingroup SFX</desc>
</function>
<function>
<name>sfxStop</name>
<args>( SFXSource source )</args>
<desc>Stop playback of the given @a source.
This is equivalent to calling SFXSource::stop().

@param source The source to put into stopped state.

@ingroup SFX</desc>
</function>
<function>
<name>sfxStopAndDelete</name>
<args>( SFXSource source )</args>
<desc>Stop playback of the given @a source (if it is not already stopped) and delete the @a source.

The advantage of this function over directly calling delete() is that it will correctly handle volume fades that may be configured on the source.  Whereas calling delete() would immediately stop playback and delete the source, this functionality will wait for the fade-out to play and only then stop the source and delete it.

@param source A sound source.

@ref SFXSource_fades

@ingroup SFX</desc>
</function>
<function>
<name>shellExecute</name>
<args>(executable, [args], [directory])</args>
<desc>@brief Launches an outside executable or batch file

@param executable Name of the executable or batch file
@param args List of arguments, in string format, to pass to the executable
@param directory Optional string containing path to output or shell
@ingroup Platform</desc>
</function>
<function>
<name>sizeof</name>
<desc>sizeof( object | classname)@brief Determines the memory consumption of a class or object

@param object The object or class being measured
@return Total size of an object and its members
@ingroup Debugging</desc>
</function>
<function>
<name>snapToggle</name>
<args>()</args>
<desc>@brief Prevents mouse movement from being processed

In the source, whenever a mouse move event occurs GameTSCtrl::onMouseMove() is called. Whenever snapToggle() is called, it will flag a variable that can prevent this from happening: gSnapLine. This variable is not exposed to script, so you need to call this function to trigger it.

@tsexample
// Snapping is off by default, so we will toggle
// it on first:
PlayGui.snapToggle();

// Mouse movement should be disabled
// Let's turn it back on
PlayGui.snapToggle();
@endtsexample

@ingroup GuiGame</desc>
</function>
<function>
<name>spawnObject</name>
<desc>spawnObject(class [, dataBlock, name, properties, script])@hide</desc>
</function>
<function>
<name>startArenaStreaming</name>
<desc>startArenaStreaming(char localIP,char sourceIP)</desc>
</function>
<function>
<name>StartClientReplication</name>
<args>()</args>
<desc>Activates the shape replicator.
@tsexample
// Call the function
StartClientReplication()
@endtsexample
@ingroup Foliage</desc>
</function>
<function>
<name>startFileChangeNotifications</name>
<desc>startFileChangeNotifications()@brief Start watching resources for file changes

@note Currently used by Editors only
@ingroup Editors
@internal</desc>
</function>
<function>
<name>StartFoliageReplication</name>
<args>()</args>
<desc>Activates the foliage replicator.
@tsexample
// Call the function
StartFoliageReplication();
@endtsexample
@ingroup Foliage</desc>
</function>
<function>
<name>startHeartbeat</name>
<desc>startHeartbeat()</desc>
</function>
<function>
<name>startPrecisionTimer</name>
<desc>startPrecisionTimer() - Create and start a high resolution platform timer. Returns the timer id.</desc>
</function>
<function>
<name>startSceneEvents</name>
<desc>startSceneEvents(F32 time)</desc>
</function>
<function>
<name>startsWith</name>
<args>( string str, string prefix, bool caseSensitive=false )</args>
<desc>Test whether the given string begins with the given prefix.
@param str The string to test.
@param prefix The potential prefix of @a str.
@param caseSensitive If true, the comparison will be case-sensitive; if false, differences in casing will not be taken into account.
@return True if the first characters in @a str match the complete contents of @a prefix; false otherwise.

@tsexample
startsWith( "TEST123", "test" ) // Returns true.
@endtsexample
@see endsWith
@ingroup Strings</desc>
</function>
<function>
<name>startVideoCapture</name>
<args>( GuiCanvas  canvas, string filename, string encoder="THEORA", float framerate=30.0f, Point2I resolution=Point2I( 0, 0 ) )</args>
<desc>Begins a video capture session.
@see stopVideoCapture
@ingroup Rendering</desc>
</function>
<function>
<name>stopArenaStreaming</name>
<desc>stopArenaStreaming()</desc>
</function>
<function>
<name>stopFileChangeNotifications</name>
<desc>stopFileChangeNotifications()@brief Stop watching resources for file changes@note Currently used by Editors only
@ingroup Editors
@internal</desc>
</function>
<function>
<name>stopHeartbeat</name>
<desc>stopHeartbeat();</desc>
</function>
<function>
<name>stopPrecisionTimer</name>
<desc>stopPrecisionTimer( S32 id ) - Stop and destroy timer with the passed id.  Returns the elapsed milliseconds.</desc>
</function>
<function>
<name>stopSampling</name>
<args>()</args>
<desc>@brief Stops the rendering sampler

@ingroup Rendering</desc>
</function>
<function>
<name>stopServerQuery</name>
<desc>stopServerQuery()</desc>
</function>
<function>
<name>stopVideoCapture</name>
<args>()</args>
<desc>Stops the video capture session.
@see startVideoCapture
@ingroup Rendering</desc>
</function>
<function>
<name>strasc</name>
<args>( string chr )</args>
<desc>Return the integer character code value corresponding to the first character in the given string.
@param chr a (one-character) string.
@return the UTF32 code value for the first character in the given string.
@ingroup Strings</desc>
</function>
<function>
<name>strchr</name>
<args>( string str, string chr )</args>
<desc>Find the first occurrence of the given character in @a str.
@param str The string to search.
@param chr The character to search for.  Only the first character from the string is taken.
@return The remainder of the input string starting with the given character or the empty string if the character could not be found.

@see strrchr
@ingroup Strings</desc>
</function>
<function>
<name>strchrpos</name>
<args>( string str, string chr, int start=0 )</args>
<desc>Find the first occurrence of the given character in the given string.
@param str The string to search.
@param chr The character to look for.  Only the first character of this string will be searched for.
@param start The index into @a str at which to start searching for the given character.
@return The index of the first occurrence of @a chr in @a str or -1 if @a str does not contain the given character.

@tsexample
strchrpos( "test", "s" ) // Returns 2.
@endtsexample
@ingroup Strings</desc>
</function>
<function>
<name>strcmp</name>
<args>( string str1, string str2 )</args>
<desc>Compares two strings using case-&lt;b&gt;sensitive&lt;/b&gt; comparison.
@param str1 The first string.
@param str2 The second string.
@return 0 if both strings are equal, -1 if the first character different in str1 has a smaller character code value than the character at the same position in str2, and 1 otherwise.

@tsexample
if( strcmp( %var, "foobar" ) == 0 )
echo( "%var is equal to 'foobar'" );
@endtsexample
@see stricmp
@see strnatcmp
@ingroup Strings</desc>
</function>
<function>
<name>strformat</name>
<args>( string format, string value )</args>
<desc>Format the given value as a string using printf-style formatting.
@param format A printf-style format string.
@param value The value argument matching the given format string.

@tsexample
// Convert the given integer value to a string in a hex notation.
%hex = strformat( "%x", %value );
@endtsexample
@ingroup Strings
@see http://en.wikipedia.org/wiki/Printf</desc>
</function>
<function>
<name>stricmp</name>
<args>( string str1, string str2 )</args>
<desc>Compares two strings using case-&lt;b&gt;insensitive&lt;/b&gt; comparison.
@param str1 The first string.
@param str2 The second string.
@return 0 if both strings are equal, -1 if the first character different in str1 has a smaller character code value than the character at the same position in str2, and 1 otherwise.

@tsexample
if( stricmp( "FOObar", "foobar" ) == 0 )
echo( "this is always true" );
@endtsexample
@see strcmp
@see strinatcmp
@ingroup Strings</desc>
</function>
<function>
<name>strinatcmp</name>
<args>( string str1, string str2 )</args>
<desc>Compares two strings using "natural order" case-&lt;b&gt;insensitive&lt;/b&gt; comparison.
Natural order means that rather than solely comparing single character code values, strings are ordered in a natural way.  For example, the string "hello10" is considered greater than the string "hello2" even though the first numeric character in "hello10" actually has a smaller character value than the corresponding character in "hello2".  However, since 10 is greater than 2, strnatcmp will put "hello10" after "hello2".
@param str1 The first string.
@param str2 The second string.
@tsexample

// Bubble sort 10 elements of %array using natural order
do
{
%swapped = false;
for( %i = 0; %i &lt; 10 - 1; %i ++ )
if( strnatcmp( %array[ %i ], %array[ %i + 1 ] ) &gt; 0 )
{
%temp = %array[ %i ];
%array[ %i ] = %array[ %i + 1 ];
%array[ %i + 1 ] = %temp;
%swapped = true;
}
}
while( %swapped );
@endtsexample
@see stricmp
@see strnatcmp
@ingroup Strings</desc>
</function>
<function>
<name>stripChars</name>
<args>( string str, string chars )</args>
<desc>Remove all occurrences of characters contained in @a chars from @a str.
@param str The string to filter characters out from.
@param chars A string of characters to filter out from @a str.
@return A version of @a str with all occurrences of characters contained in @a chars filtered out.

@tsexample
stripChars( "teststring", "se" ); // Returns "tttring".@endtsexample
@ingroup Strings</desc>
</function>
<function>
<name>stripExtension</name>
<desc>stripExtension(const char *filename)</desc>
</function>
<function>
<name>StripMLControlChars</name>
<args>( string inString )</args>
<desc>@brief Strip TorqueML control characters from the specified string, returning a 'clean' version.

@param inString String to strip TorqueML control characters from.
@tsexample
// Define the string to strip TorqueML control characters from
%string = "&lt;font:Arial:24&gt;How Now &lt;color:c43c12&gt;Brown &lt;color:000000&gt;Cow";

// Request the stripped version of the string
%strippedString = StripMLControlChars(%string);
@endtsexample

@return Version of the inputted string with all TorqueML characters removed.

@see References

@ingroup GuiCore</desc>
</function>
<function>
<name>stripTrailingNumber</name>
<args>( string str )</args>
<desc>Strip a numeric suffix from the given string.
@param str The string from which to strip its numeric suffix.
@return The string @a str without its number suffix or the original string @a str if it has no such suffix.

@tsexample
stripTrailingNumber( "test123" ) // Returns "test".
@endtsexample

@see getTrailingNumber
@ingroup Strings</desc>
</function>
<function>
<name>strIsMatchExpr</name>
<args>( string pattern, string str, bool caseSensitive=false )</args>
<desc>Match a pattern against a string.
@param pattern The wildcard pattern to match against.  The pattern can include characters, '*' to match any number of characters and '?' to match a single character.
@param str The string which should be matched against @a pattern.
@param caseSensitive If true, characters in the pattern are matched in case-sensitive fashion against this string.  If false, differences in casing are ignored.
@return True if @a str matches the given @a pattern.

@tsexample
strIsMatchExpr( "f?o*R", "foobar" ) // Returns true.
@endtsexample
@see strIsMatchMultipleExpr
@ingroup Strings</desc>
</function>
<function>
<name>strIsMatchMultipleExpr</name>
<args>( string patterns, string str, bool caseSensitive=false )</args>
<desc>Match a multiple patterns against a single string.
@param patterns A space- or tab-separated list of patterns.  Each pattern can include charaters, '*' to match any number of characters and '?' to match a single character.  Each of the patterns is tried in turn.
@param str The string which should be matched against @a patterns.
@param caseSensitive If true, characters in the pattern are matched in case-sensitive fashion against this string.  If false, differences in casing are ignored.
@return True if @a str matches any of the given @a patterns.

@tsexample
strIsMatchMultipleExpr( "*.cs *.gui *.mis", "mymission.mis" ) // Returns true.
@endtsexample
@see strIsMatchExpr
@ingroup Strings</desc>
</function>
<function>
<name>strlen</name>
<args>( string str )</args>
<desc>Get the length of the given string in bytes.
@note This does &lt;b&gt;not&lt;/b&gt; return a true character count for strings with multi-byte characters!
@param str A string.
@return The length of the given string in bytes.
@ingroup Strings</desc>
</function>
<function>
<name>strlwr</name>
<args>( string str )</args>
<desc>Return an all lower-case version of the given string.
@param str A string.
@return A version of @a str with all characters converted to lower-case.

@tsexample
strlwr( "TesT1" ) // Returns "test1"
@endtsexample
@see strupr
@ingroup Strings</desc>
</function>
<function>
<name>strnatcmp</name>
<args>( string str1, string str2 )</args>
<desc>Compares two strings using "natural order" case-&lt;b&gt;sensitive&lt;/b&gt; comparison.
Natural order means that rather than solely comparing single character code values, strings are ordered in a natural way.  For example, the string "hello10" is considered greater than the string "hello2" even though the first numeric character in "hello10" actually has a smaller character value than the corresponding character in "hello2".  However, since 10 is greater than 2, strnatcmp will put "hello10" after "hello2".
@param str1 The first string.
@param str2 The second string.

@tsexample
// Bubble sort 10 elements of %array using natural order
do
{
%swapped = false;
for( %i = 0; %i &lt; 10 - 1; %i ++ )
if( strnatcmp( %array[ %i ], %array[ %i + 1 ] ) &gt; 0 )
{
%temp = %array[ %i ];
%array[ %i ] = %array[ %i + 1 ];
%array[ %i + 1 ] = %temp;
%swapped = true;
}
}
while( %swapped );
@endtsexample
@see strcmp
@see strinatcmp
@ingroup Strings</desc>
</function>
<function>
<name>strpos</name>
<args>( string haystack, string needle, int offset=0 )</args>
<desc>Find the start of @a needle in @a haystack searching from left to right beginning at the given offset.
@param haystack The string to search.
@param needle The string to search for.
@return The index at which the first occurrence of @a needle was found in @a heystack or -1 if no match was found.

@tsexample
strpos( "b ab", "b", 1 ) // Returns 2.
@endtsexample
@ingroup Strings</desc>
</function>
<function>
<name>strrchr</name>
<args>( string str, string chr )</args>
<desc>Find the last occurrence of the given character in @a str.@param str The string to search.
@param chr The character to search for.  Only the first character from the string is taken.
@return The remainder of the input string starting with the given character or the empty string if the character could not be found.

@see strchr
@ingroup Strings</desc>
</function>
<function>
<name>strrchrpos</name>
<args>( string str, string chr, int start=0 )</args>
<desc>Find the last occurrence of the given character in the given string.
@param str The string to search.
@param chr The character to look for.  Only the first character of this string will be searched for.
@param start The index into @a str at which to start searching for the given character.
@return The index of the last occurrence of @a chr in @a str or -1 if @a str does not contain the given character.

@tsexample
strrchrpos( "test", "t" ) // Returns 3.
@endtsexample
@ingroup Strings</desc>
</function>
<function>
<name>strrepeat</name>
<args>( string str, int numTimes, string delimiter="" )</args>
<desc>Return a string that repeats @a str @a numTimes number of times delimiting each occurrence with @a delimiter.
@param str The string to repeat multiple times.
@param numTimes The number of times to repeat @a str in the result string.
@param delimiter The string to put between each repetition of @a str.
@return A string containing @a str repeated @a numTimes times.

@tsexample
strrepeat( "a", 5, "b" ) // Returns "ababababa".
@endtsexample
@ingroup Strings</desc>
</function>
<function>
<name>strreplace</name>
<args>( string source, string from, string to )</args>
<desc>Replace all occurrences of @a from in @a source with @a to.
@param source The string in which to replace the occurrences of @a from.
@param from The string to replace in @a source.
@param to The string with which to replace occurrences of @from.
@return A string with all occurrences of @a from in @a source replaced by @a to.

@tsexample
strreplace( "aabbccbb", "bb", "ee" ) // Returns "aaeeccee".
@endtsexample
@ingroup Strings</desc>
</function>
<function>
<name>strstr</name>
<args>( string string, string substring )</args>
<desc>Find the start of @a substring in the given @a string searching from left to right.
@param string The string to search.
@param substring The string to search for.
@return The index into @a string at which the first occurrence of @a substring was found or -1 if @a substring could not be found.

@tsexample
strstr( "abcd", "c" ) // Returns 2.
@endtsexample
@ingroup Strings</desc>
</function>
<function>
<name>strToPlayerName</name>
<desc>strToPlayerName( string )</desc>
</function>
<function>
<name>strupr</name>
<args>( string str )</args>
<desc>Return an all upper-case version of the given string.
@param str A string.
@return A version of @a str with all characters converted to upper-case.

@tsexample
strupr( "TesT1" ) // Returns "TEST1"
@endtsexample
@see strlwr
@ingroup Strings</desc>
</function>
<function>
<name>telnetSetParameters</name>
<args>(int port, string consolePass, string listenPass)</args>
<desc>@brief Initialize and open the telnet console.

@param port        Port to listen on for console connections (0 will shut down listening).
@param consolePass Password for read/write access to console.
@param listenPass  Password for read access to console.@param remoteEcho  [optional] Enable echoing back to the client, off by default.

@ingroup Debugging</desc>
</function>
<function>
<name>TestFunction2Args</name>
<desc>testFunction(arg1, arg2)</desc>
</function>
<function>
<name>testJavaScriptBridge</name>
<desc>testBridge(arg1, arg2, arg3)</desc>
</function>
<function>
<name>trace</name>
<args>( bool enable=true )</args>
<desc>Enable or disable tracing in the script code VM.

When tracing is on, the script code runtime will trace the invocation and returns from all functions that are called and log them to the console.  This is helpful in finding what the script program flow is.

@param enable New setting for script trace execution.
@ingroup Debugging</desc>
</function>
<function>
<name>trim</name>
<args>( string str )</args>
<desc>Remove leading and trailing whitespace from the string.
@param str A string.
@return A string that is the same as @a str but with any leading (i.e. leftmost) and trailing (i.e. rightmost) whitespace removed.

@tsexample
trim( "   string  " ); // Returns "string".
@endtsexample
@ingroup Strings</desc>
</function>
<function>
<name>tsUpdateImposterImages</name>
<desc>tsUpdateImposterImages( bool forceupdate )</desc>
</function>
<function>
<name>unitTest_runTests</name>
<args>([searchString[, bool skipInteractive]])</args>
<desc>@brief Run unit tests, or just the tests that prefix match against the searchString.

@ingroup Console</desc>
</function>
<function>
<name>unregisterMessageListener</name>
<args>(queueName, listener)</args>
<desc>@brief Unregisters an event message

@param queueName String containing the name of queue
@param listener Name of event messenger
@ingroup Platform</desc>
</function>
<function>
<name>unregisterMessageQueue</name>
<args>(queueName)</args>
<desc>@brief Unregisters a dispatcher queue

@param queueName String containing the name of queue
@ingroup Platform</desc>
</function>
<function>
<name>VectorAdd</name>
<args>( VectorF a, VectorF b )</args>
<desc>Add two vectors.
@param a The first vector.
@param b The second vector.
@return The vector @a a + @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorAdd( %a, %b );
//
// The sum of vector a, (ax, ay, az), and vector b, (bx, by, bz) is:
//
//     a + b = ( ax + bx, ay + by, az + bz )
//
//-----------------------------------------------------------------------------
%a = "1 0 0";
%b = "0 1 0";

// %r = "( 1 + 0, 0 + 1, 0 + 0 )";
// %r = "1 1 0";
%r = VectorAdd( %a, %b );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>VectorCross</name>
<args>( VectorF a, VectorF b )</args>
<desc>Calculcate the cross product of two vectors.
@param a The first vector.
@param b The second vector.
@return The cross product @a x @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorCross( %a, %b );
//
// The cross product of vector a, (ax, ay, az), and vector b, (bx, by, bz), is
//
//     a x b = ( ( ay * bz ) - ( az * by ), ( az * bx ) - ( ax * bz ), ( ax * by ) - ( ay * bx ) )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%b = "2 0 1";

// %r = "( ( 1 * 1 ) - ( 0 * 0 ), ( 0 * 2 ) - ( 1 * 1 ), ( 1 * 0 ) - ( 1 * 2 ) )";
// %r = "1 -1 -2";
%r = VectorCross( %a, %b );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>VectorDist</name>
<args>( VectorF a, VectorF b )</args>
<desc>Compute the distance between two vectors.
@param a The first vector.
@param b The second vector.
@return The length( @a b - @a a ).

@tsexample
//-----------------------------------------------------------------------------
//
// VectorDist( %a, %b );
//
// The distance between vector a, (ax, ay, az), and vector b, (bx, by, bz), is
//
//     a -&gt; b = ||( b - a )||
//            = ||( bx - ax, by - ay, bz - az )||
//            = mSqrt( ( bx - ax ) * ( bx - ax ) + ( by - ay ) * ( by - ay ) + ( bz - az ) * ( bz - az ) )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%b = "2 0 1";

// %r = mSqrt( ( 2 - 1 ) * ( 2 - 1) + ( 0 - 1 ) * ( 0 - 1 ) + ( 1 - 0 ) * ( 1 - 0 ) );
// %r = mSqrt( 3 );
%r = VectorDist( %a, %b );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>VectorDot</name>
<args>( VectorF a, VectorF b )</args>
<desc>Compute the dot product of two vectors.
@param a The first vector.
@param b The second vector.
@return The dot product @a a * @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorDot( %a, %b );
//
// The dot product between vector a, (ax, ay, az), and vector b, (bx, by, bz), is:
//
//     a . b = ( ax * bx + ay * by + az * bz )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%b = "2 0 1";

// %r = "( 1 * 2 + 1 * 0 + 0 * 1 )";
// %r = 2;
%r = VectorDot( %a, %b );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>VectorLen</name>
<args>( VectorF v )</args>
<desc>Calculate the magnitude of the given vector.
@param v A vector.
@return The length of vector @a v.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorLen( %a );
//
// The length or magnitude of  vector a, (ax, ay, az), is:
//
//     ||a|| = Sqrt( ax * ax + ay * ay + az * az )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";

// %r = mSqrt( 1 * 1 + 1 * 1 + 0 * 0 );
// %r = mSqrt( 2 );
// %r = 1.414;
%r = VectorLen( %a );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>VectorLerp</name>
<args>( VectorF a, VectorF b, float t )</args>
<desc>Linearly interpolate between two vectors by @a t.
@param a Vector to start interpolation from.
@param b Vector to interpolate to.
@param t Interpolation factor (0-1).  At zero, @a a is returned and at one, @a b is returned.  In between, an interpolated vector between @a a and @a b is returned.
@return An interpolated vector between @a a and @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorLerp( %a, %b );
//
// The point between vector a, (ax, ay, az), and vector b, (bx, by, bz), which is
// weighted by the interpolation factor, t, is
//
//     r = a + t * ( b - a )
//       = ( ax + t * ( bx - ax ), ay + t * ( by - ay ), az + t * ( bz - az ) )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%b = "2 0 1";
%v = "0.25";

// %r = "( 1 + 0.25 * ( 2 - 1 ), 1 + 0.25 * ( 0 - 1 ), 0 + 0.25 * ( 1 - 0 ) )";
// %r = "1.25 0.75 0.25";
%r = VectorLerp( %a, %b );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>VectorNormalize</name>
<args>( VectorF v )</args>
<desc>Brings a vector into its unit form, i.e. such that it has the magnitute 1.
@param v The vector to normalize.
@return The vector @a v scaled to length 1.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorNormalize( %a );
//
// The normalized vector a, (ax, ay, az), is:
//
//     a^ = a / ||a||
//        = ( ax / ||a||, ay / ||a||, az / ||a|| )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%l = 1.414;

// %r = "( 1 / 1.141, 1 / 1.141, 0 / 1.141 )";
// %r = "0.707 0.707 0";
%r = VectorNormalize( %a );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>VectorOrthoBasis</name>
<args>( AngAxisF aa )</args>
<desc>Create an orthogonal basis from the given vector.
@param aaf The vector to create the orthogonal basis from.
@return A matrix representing the orthogonal basis.
@ingroup Vectors</desc>
</function>
<function>
<name>VectorScale</name>
<args>( VectorF a, float scalar )</args>
<desc>Scales a vector by a scalar.
@param a The vector to scale.
@param scalar The scale factor.
@return The vector @a a * @a scalar.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorScale( %a, %v );
//
// Scaling vector a, (ax, ay, az), but the scalar, v, is:
//
//     a * v = ( ax * v, ay * v, az * v )
//
//-----------------------------------------------------------------------------

%a = "1 1 0";
%v = "2";

// %r = "( 1 * 2, 1 * 2, 0 * 2 )";
// %r = "2 2 0";
%r = VectorScale( %a, %v );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>VectorSub</name>
<args>( VectorF a, VectorF b )</args>
<desc>Subtract two vectors.
@param a The first vector.
@param b The second vector.
@return The vector @a a - @a b.

@tsexample
//-----------------------------------------------------------------------------
//
// VectorSub( %a, %b );
//
// The difference of vector a, (ax, ay, az), and vector b, (bx, by, bz) is:
//
//     a - b = ( ax - bx, ay - by, az - bz )
//
//-----------------------------------------------------------------------------

%a = "1 0 0";
%b = "0 1 0";

// %r = "( 1 - 0, 0 - 1, 0 - 0 )";
// %r = "1 -1 0";
%r = VectorSub( %a, %b );
@endtsexample

@ingroup Vectors</desc>
</function>
<function>
<name>warn</name>
<args>( string text... )</args>
<desc>Log a warning message to the console.
This function concatenates all given arguments to a single string and prints the string to the console as a warning message (in the in-game console, these will show up using a grey font by default).
A newline is added automatically after the text.

@param text Any number of string arguments.

@ingroup Logging</desc>
</function>
<function>
<name>writeFontCache</name>
<args>()</args>
<desc>Force all cached fonts to serialize themselves to the cache.
@ingroup Font</desc>
</function>
</exports>
